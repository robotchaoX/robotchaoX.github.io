{"./":{"url":"./","title":"Summary","keywords":"","body":"主页概要 主页 GitHubPages：https://robotchaox.github.io/ 谷歌云服务器链接 概要 Summary C++ C++基础 C++11 STL linux基础 Linux基本命令 linux工具 GCC GDB make json valgrind内存检测 linux系统编程 进程 进程间通信 信号 守护进程 线程 线程同步 linux网络编程 网络基础 TCP/UDP 多进程线程并发 多路IO转接 Web服务器 Untitled HTML HTML基础 HTTP协议 HTTP基础 https原理 设计模式 UML 设计模式 shell编程 shell基础 Python Python基础 vim编辑器 vim编辑器 doxygen doxygen源码文档 MarkDown MarkDown语法 GitBook GitBook笔记 Git Git&GitHub NVIDIA-jetson jetson笔记 OpenCV OpenCV笔记 数据库 MySQL MongoDB 数据结构与算法 "},"c++/":{"url":"c++/","title":"C++","keywords":"","body":"C++C++ C++基础 C++概述 c++ hello world ::作用域运算符 命名空间 C/C++中的const 引用(reference) 内联函数(inline function) 函数的默认参数 函数的占位参数 函数重载(overload) extern \"C\" C与C++的不同 全局变量检测增强 C++中所有的变量和函数都必须有类型 更严格的类型转换 struct类型加强 \"新增\"bool类型关键字 三目运算符功能增强 类和对象 类和对象的基本概念 对象的构造和析构 C++面向对象模型 友元 运算符重载 运算符重载基本概念 运算符重载碰上友元函数 可重载的运算符 自增自减(++/--)运算符重载 指针运算符(*、->)重载 赋值(=)运算符重载 等于和不等于(==、!=)运算符重载 函数调用符号()重载 不要重载&&、|| 符号重载总结 继承和派生 继承概述 派生类访问控制 继承中的构造和析构 继承中同名成员的处理方法 非自动继承的函数 继承中的静态成员特性 多继承 多态 多态基本概念 虚函数 抽象基类和纯虚函数 纯虚函数和多继承 虚析构函数 重写 重载 重定义 指向类成员的指针 C++模板 模板概论 函数模板 函数模板和普通函数区别 函数模板和普通函数在一起调用规则 模板机制剖析 模板的局限性 类模板 C++类型转换 静态转换(static_cast) 动态转换(dynamic_cast) 常量转换(const_cast) 重新解释转换(reinterpret_cast) C++异常 异常基本概念 异常语法 C++标准异常库 C++输入和输出流 流的概念和流类库的结构 标准I/O流 标准输入流 标准输出流 文件读写 "},"c++/c++-basic.html":{"url":"c++/c++-basic.html","title":"C++基础","keywords":"","body":"C++C++基础C++概述hello world作用域运算符::命名空间引用内联函数inline函数的默认参数函数的占位参数函数重载extern \"C\"C与C++的不同C/C++中的const类和对象类和对象的基本概念对象的构造和析构动态对象创建static静态成员C++类对象模型this指针const 常成员友元运算符重载运算符重载基本概念可重载的运算符自增自减(++或--)运算符重载指针运算符(*或->)重载赋值(=)运算符重载等于和不等于(==或!=)运算符重载函数调用符号()重载不要重载&&或||运算符和结合性符号重载总结继承和派生继承概述派生类访问控制继承中的构造和析构继承中同名成员的处理方法不能继承的函数继承中的静态成员特性多继承多态多态基本概念动态多态原理多态的成立条件虚函数纯虚函数(抽象类）虚析构函数重载 重定义 重写类成员的指针C++模板模板概论函数模板类模板模板实现原理模板的局限性C++类型转换静态转换(static_cast)动态转换(dynamic_cast)常量转换(const_cast)重新解释转换(reinterpret_cast)C++异常异常基本概念异常语法C++标准异常库C++输入和输出流流的概念和流类库的结构标准I/O流标准输入流标准输出流文件读写Python和C++比较C++11C++ C++基础 C++概述 hello world 作用域运算符:: 命名空间 引用 内联函数inline 函数的默认参数 函数的占位参数 函数重载 extern \"C\" C与C++的不同 C/C++中的const 类和对象 类和对象的基本概念 对象的构造和析构 动态对象创建 static静态成员 C++类对象模型 this指针 const 常成员 友元 运算符重载 运算符重载基本概念 可重载的运算符 自增自减(++或--)运算符重载 指针运算符(*或->)重载 赋值(=)运算符重载 等于和不等于(==或!=)运算符重载 函数调用符号()重载 不要重载&&或|| 运算符和结合性 符号重载总结 继承和派生 继承概述 派生类访问控制 继承中的构造和析构 继承中同名成员的处理方法 不能继承的函数 继承中的静态成员特性 多继承 多态 多态基本概念 动态多态原理 多态的成立条件 虚函数 纯虚函数(抽象类） 虚析构函数 重载 重定义 重写 类成员的指针 C++模板 模板概论 函数模板 类模板 模板实现原理 模板的局限性 C++类型转换 静态转换(static_cast) 动态转换(dynamic_cast) 常量转换(const_cast) 重新解释转换(reinterpret_cast) C++异常 异常基本概念 异常语法 C++标准异常库 C++输入和输出流 流的概念和流类库的结构 标准I/O流 标准输入流 标准输出流 文件读写 Python和C++比较 C++11 [TOC] C++基础 C++概述 C++简介 ​ C++起初也叫\"C with clsss\"，C++是对C的扩展，C++语言在c语言的基础上添加了面向对象编程和泛型编程的支持。C++继承了C语言高效，简洁，快速和可移植的传统。 C++融合了3种不同的编程方式: c语言代表的过程性语言。 C++在c语言基础上添加的类代表的面向对象语言。 C++模板支持的泛型编程。 面向过程 面向过程是一种以过程为中心的编程思想。 通过分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 面向过程编程思想的核心：功能分解，自顶向下，逐层细化（程序=数据结构+算法）。 面向过程编程语言存在的主要缺点是不符合人的思维习惯，而是要用计算机的思维方式去处理问题，而且面向过程编程语言重用性低，维护困难。 面向对象 面向对象编程（Object-Oriented Programming）简称 OOP 技术，是开发应用程序的一种新方法、新思想。过去的面向过程编程常常会导致所有的代码都包含在几个模块中，使程序难以阅读和维护。在做一些修改时常常牵一动百，使以后的开发和维护难以为继。而使用 OOP 技术，常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的，这样就增大了代码重用率，更加有利于软件的开发、维护和升级。 在面向对象中，算法与数据结构被看做是一个整体，称作对象，现实世界中任何类的对象都具有一定的属性和操作，也总能用数据结构与算法两者合一地来描述，所以可以用下面的等式来定义对象和程序： 对象 = 算法 + 数据结构 程序 = 对象 + 对象 + …… 从上面的等式可以看出，程序就是许多对象在计算机中相继表现自己，而对象则是一个个程序实体。 面向对象编程思想的核心：应对变化，提高代码复用。 面向对象三大特性 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。 继承 继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。 继承的作用：减少代码和数据冗余，提高代码复用。 多态 多态性可以简单地概括为\"一个接口，多种方法\"，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。 hello world #include using namespace std; int main(){ cout 分析: ``#include; // 预编译指令，引入头文件iostream. using namespace std; // 使用标准命名空间 cout C++头文件 在c语言中头文件使用扩展名.h,将其作为一种通过名称标识文件类型的简单方式。但是C++的用法改变了，C++头文件没有扩展名。但是有些c语言的库头文件被转换为C++的库头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为C++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。例如C++版本的math.h为cmath。 头文件类型 约定 示例 说明 c旧式风格 以.h结尾 math.h c/c++程序可用 c++转换自C头文件 加上前缀c,无扩展名 cmath c++程序可用，可使用非c特性，如namespace c++旧式风格 以.h结尾 iostream.h c++程序可用 c++新式风格 无扩展名 iostream c++程序可用，使用namespace std 作用域运算符:: 通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。 ::作用域运算符可以用来解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。 ::变量名表示访问全局变量 //全局变量 int a = 10; //局部变量和全局变量同名 void test(){ int a = 20; //打印局部变量a cout 命名空间 c语言可以通过static关键字来使得名字只得在本编译单元内可见，在C++中我们将通过一种通过命名空间namespace来控制对名字的访问可见性。 在C++中，名称可以是符号常量、变量、函数、结构、枚举、类和对象等等。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namespace（命名空间），可以更好地控制标识符的作用域。 命名空间定义 namespace创建一个命名空间 命名空间只能全局范围内定义 命名空间可嵌套命名空间 命名空间是开放的，即可以随时把新的成员加入已有的命名空间中 // 命名空间只能全局范围内定义 namespace A{ int a = 10; namespace AB{ // 嵌套命名空间 int ab = 20; } } // 原命名空间添加新成员 namespace A{ void func(){ cout 命名空间别名 namespace shortName = veryLongName; 无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接。 namespace{ int a = 10; void func(){ cout 命名空间内函数声明和实现可分离 仅函数声明 namespace MySpace{ void func1(); void func2(int param); } 函数实现 void MySpace::func1(){ cout using声明 using声明可使得指定的标识符可用 using opencv::Mat; using opencv::imshow(); using编译指令使整个命名空间标识符可用 using namespace opencv; 注意：使用using声明或using编译指令会增加命名冲突的可能性。也就是说，如果有名称空间，并在代码中使用作用域解析运算符，则不会出现二义性。 使用using定义类型的别名 using canID = unsigned int; using声明碰到函数重载 如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。 namespace A{ void func(){} void func(int x){} int func(int x,int y){} } void test(){ using A::func; func(); func(10); func(10, 20); } 命名空间使用 当引入一个全局的using编译指令时，就为该文件打开了该命名空间，它不会影响任何其他的文件，所以可以在每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多的using指令而产生的命名冲突，就要对该文件做个简单的改变，通过明确的限定或者using声明来消除名字冲突，这样不需要修改其他的实现文件。 引用 引用基本用法 在c/C++中指针的作用基本都是一样的，但是C++增加了另外一种给函数传递地址的途径，这就是按引用传递(pass-by-reference)，它也存在于其他一些编程语言中，并不是C++的发明。 变量名实质上是一段连续内存空间的别名，是一个标号(门牌号) 程序中通过变量来申请并命名内存空间 通过变量的名字可以使用存储空间 基本语法: int & ref = val; 注意事项： &在此不是求地址运算，而是起标识作用。 类型标识符是指目标变量的类型。 必须在声明引用变量时进行初始化。 引用初始化之后不能改变。 不能有NULL引用。必须确保引用是和一块合法的存储单元关联。 可以建立对数组的引用。 int arr[10]; //int & ref3[10] = arr; // error这样不能对数组建立引用 int (&arr_ref)[10] = arr; // 建立数组引用 函数中的引用 最常见看见引用的地方是在函数参数和返回值中。 函数参数传引用 当引用被用作函数参数的时，在函数内对任何引用的修改，将对函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。 //值传递 void ValueSwap(int m,int n){} //地址传递 void PointerSwap(int m,int n){} //引用传递 void ReferenceSwap(int& m,int& n){} 通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单： 1) 函数调用时传递的实参不必加\"&\"符 2) 在被调函数中不必在参数前加\"*\"符 引用作为其它变量的别名而存在，因此在一些场合可以代替指针。C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。 函数返回引用 如果从函数中返回一个引用，必须像从函数中返回一个指针一样对待。当函数返回值时，引用关联的内存一定要存在。 不能返回局部变量的引用。 函数当左值，必须返回引用。 指针引用 在c语言中如果想改变一个指针的指向而不是它所指向的内容，函数声明可能这样: void fun(int**){} C++指针引用，给指针变量取一个别名。 Type pointer = NULL; Type& = pointer; //指针间接修改teacher的年龄 void AllocateAndInitByPointer(Teacher** teacher){} 对于C++中的定义那个，语法清晰多了。函数参数变成指针的引用，用不着取得指针的地址。 //引用修改teacher年龄 void AllocateAndInitByReference(Teacher*& teacher){} 常量引用 const修饰的引用，常量引用，的定义格式: const Type& ref = val; const int& aRef = a; //此时aRef就是a const int& ref = 100; //int temp = 200; const int& ret = temp; 常量引用注意： const修饰的引用，不能通过引用修改原变量值。 int a = 100; const int& aRef = a; //此时aRef就是a //aRef = 200; 不能通过aRef的值 a = 100; //OK 字面量不能赋给引用，但是可以赋给const引用 > //不能把一个字面量赋给引用 //int &ref = 100; //但是可以把一个字面量赋给常引用 const int& ref = 100; //int temp = 200; const int& ret = temp; const常引用使用场景: 常量引用主要用在函数的形参，尤其是类的拷贝/复制构造函数。 void showValue(const Person &val) { } 将函数的形参定义为常量引用的好处: 引用不产生新的变量，减少形参与实参传递时的开销。 由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用。 引用的本质 引用的本质在C++内部实现是一个指针常量 Type & ref = val; // Type* const ref = &val; C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。 内联函数inline 宏的缺陷 在c中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。 使用预处理宏会出现两个问题： 宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。 预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数。 #define ADD(x,y) x+y int ret1 = ADD(10, 20) * 10; //希望的结果是300,实际210 #define COMPARE(x,y) ((x) 预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说预定义宏没有办法表示类的范围。 内联函数 内联函数(inline function)，内联函数本身也是一个真正的函数，唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，保持了预处理宏的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为类成员函数在类里访问自如。因此应该不使用宏，使用内联函数。 普通函数内联函数 在普通函数函数前面加上inline关键字使之成为内联函数。但是必须注意必须函数声明函数实现在一起，否则编译器将它作为普通函数来对待。 inline int func(int a){ return a++; } 内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。我们可以理解为内联函数是以空间换时间。 类内成员内联函数 在类内部定义内联函数时不需要inline关键字。类内实现的成员函数默认是内联函数，不需要加inline。 class Person{ public: void PrintPerson(){ cout 内联函数建议 内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。 以下情况编译器可能考虑不会将函数进行内联编译： 不能存在任何形式的循环语句 不能存在过多的条件判断语句 函数体不能过于庞大 不能对函数进行取址操作 函数的默认参数 C++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。 函数的默认参数从左向右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。 函数声明和定义 不能同时设置默认参数。 函数的占位参数 C++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。一般情况下，在函数体内部无法使用占位参数。函数调用时，占位参数也是参数，必须传参数。 void TestFunc01(int a,int b,int ){}函数内部无法使用占位参数 TestFunc01(10,20,30); 函数调用时，占位参数也是参数，必须传参数。 操作符重载的后置++要用到这个。 函数重载 在传统c语言中，函数名必须是唯一的，程序中不允许出现同名的函数。在C++中是允许出现同名的函数，这种现象称为函数重载。 实现函数重载的条件： 同一个作用域 参数个数不同 参数类型不同 参数顺序不同 返回值不能作为函数重载依据，即无法重载仅按返回值区分的函数。 为什么函数返回值不作为重载条件呢？ 我们在编写程序过程中可以忽略他的返回值。那么这个时候,一个函数为void func(int x);另一个为int func(int x); 当我们直接调用func(10),这个时候编译器就不确定调用那个函数。所以在C++中禁止使用返回值作为重载的条件。 注意: 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。 函数重载实现原理 函数重载的实现实际是编译器偷偷改了函数的名字来区分不同参数，编译器用不同的参数类型来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char。 void fun(){} void fun(int x){} void fun(int x,char y){} 以上三个函数在linux下生成的编译之后的函数名为: _Z4funv //v 代表void,无参数 _Z4funi //i 代表参数为int类型 _Z4funic //i 代表第一个参数为int类型，第二个参数为char类型 extern \"C\" extern \"C\"{ }的主要作用就是为了实现C++代码能够调用其他c语言代码。在头文件函数声明中加上extern \"C\"后，这部分代码编译器按c语言的方式进行编译和链接，而不是按C++的方式。 #ifdef __cplusplus // C++ extern \"C\"{ // 在C++中按c语言的方式进行编译和链接 #endif /*****按照C语言方式进行编译和链接*******/ void func1(); int func2(int a,int b); /*****按照C语言方式进行编译和链接*******/ #ifdef __cplusplus // C++ } #endif c函数: void MyFunc(){} ,被编译成函数: MyFunc C++函数: void MyFunc(){},被编译成函数: _Z6Myfuncv 由于C++中需要支持函数重载，所以c和C++中对同一个函数经过编译后生成的函数名是不相同的，这就导致了一个问题，如果在C++中调用一个使用c语言编写模块中的某个函数，那么C++是根据C++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误，以上例，C++中调用MyFunc函数，在链接阶段会去找_Z6Myfuncv，结果是没有找到的，因为这个MyFunc函数是c语言编写的，生成的符号是MyFunc。 C与C++的不同 全局变量检测增强 int a = 10; //赋值，c语言当做定义 int a; // 没有赋值，c语言当做声明，C++重复定义 在c下编译通过，在C++下编译失败，重复定义变量a。 函数类型检测增强 参数类型增强,返回值检测增强,函数调用参数检测增强，C++中所有的变量和函数都必须有类型。 在C语言中，int fun() 表示返回值为int，接受任意参数的函数，int fun(void) 表示返回值为int的无参函数。 在C++ 中，int fun() 和int fun(void) 具有相同的意义，都表示返回值为int的无参函数。 类型转换增强 在C++，更严格的类型转换，不同类型的变量一般是不能直接赋值的，需要相应的强转。 struct类型加强 c中定义结构体变量需要加上struct关键字， C++中定义结构体变量不需要加struct关键字。 c中的结构体只能定义成员变量，不能定义成员函数， C++结构体中即可以定义成员变量，也可以定义成员函数。 新增bool类型 标准C++的bool类型有两种内建的常量true(转换为整数1)和false(转换为整数0)表示状态。这三个名字都是关键字。 bool类型只有两个值，true(1值)，false(0值) bool类型占1个字节大小 给bool类型赋值时，非0值会自动转换为true(1)，0值会自动转换false(0) c语言中也有bool类型，在c99标准之前是没有bool关键字，c99标准已经有bool类型，包含头文件stdbool.h,就可以使用和C++一样的bool类型。 三目运算符功能增强 c语言三目运算表达式返回值为数据的值，为右值，不能赋值。 C++语言三目运算表达式返回值为变量(引用)，为左值，可以赋值。 (a > b ? a : b) = 100; //C++三目运算的结果是变量 左值和右值概念 在C++中可以放在赋值操作符左边的是左值，可以放到赋值操作符右面的是右值。 有些变量即可以当左值，也可以当右值。 左值为Lvalue，L代表Location，表示内存可以寻址，可以赋值。 右值为Rvalue，R代表Read,就是可以知道它的值。 比如:int temp = 10; temp在内存中有地址，10没有，但是可以Read到它的值。 C/C++中的const const概述 const单词字面意思为常数，不变的。它是c/C++中的一个关键字，它用来限定一个变量不允许改变，它将一个对象转换成一个常量。 C/C++中const的区别 C中的const c中的const理解为\"一个不能改变的普通变量\"，也就是认为const应该是一个只读变量，既然是变量那么就会给const分配内存，一个const总是需要一块内存空间，并且在c中const是一个全局只读变量，c语言中const修饰的只读变量是外部连接的。 C++中的const 在C++中，一个const不必创建内存空间，而在c中，一个const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般说来，如果一个const仅仅用来把一个名字用一个值代替(就像使用#define一样)，那么该存储局空间就不必创建。 如果存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。 不过，取一个const地址, 或者把它定义为extern,则会为该const创建内存空间。 在C++中，出现在所有函数之外的const作用于整个文件(也就是说它在该文件外不可见)，默认为内部连接，C++中其他的标识符一般默认为外部连接。 C/C++中const异同总结 全局const c语言全局const会被存储到只读数据段。 C++中全局const只有当声明extern或者对变量取地址时，编译器会分配存储地址，变量存储在只读数据段。 两个都受到了只读数据段的保护，不可修改。 局部const c语言中局部const存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以通过指针间接修改const值。 C++中对于局部const变量要区别对待： 对于基础数据类型，也就是const int A = 10这种，编译器会把它放到符号表中，不分配内存，只有当对其取地址时，会分配临时内存。指针也无法修改原真正局部const变量A，修改的是临时分配内存的值。 对于基础数据类型，如果用一个变量初始化const变量，如果const int a = b,那么也是会给a分配内存。 对于自定数据类型，比如类对象，那么也会分配内存。 //! 常量初始化的const是真正的常量，值不可以被指针修改 //! 变量初始化的const不是真正的const，值可以被指针修改 //! 自定义类型的const不是真正的const，值可以被指针修改 c中const默认为外部连接，C++中const默认为内部连接？？。当c语言两个文件中都有const int a的时候，编译器会报重定义的错误。而在C++中，则不会，因为C++中的const默认是内部连接的。如果想让C++中的const具有外部连接，必须extern显示声明为: extern const int a = 10; const替换#define ``#define MAX 1024; // 没有类型 我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经被替换为了1024，当我们使用这个常量获得一个编译错误信息时，可能会带来一些困惑，因为这个信息可能会提到1024，但是并没有提到MAX，你可能并不知道1024代表什么。 const int max= 1024; // 有类型 const和#define区别总结: define宏常量没有类型，所以调用了int类型重载的函数。 const有类型。宏常量不重视作用域。 类和对象 类和对象的基本概念 类的封装 封装特性包含两个方面，一个是属性和行为合成一个整体，一个是给属性和函数增加访问权限。 封装 把变量（属性）和函数（方法）合成一个整体，封装在一个类中。 对变量和函数进行访问控制。 访问权限 在类的内部(作用域范围内)，没有访问权限之分，所有成员可以相互访问 在类的外部(作用域范围外)，访问权限才有意义：public，private，protected 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承与派生时， private和protected是同等级的，外部不允许访问 将成员变量设置为private属性： 可赋予访问数据的一致性。 如果成员变量是private属性，唯一能够访问对象的方法就是通过成员函数，不需要考虑访问的成员需不需要添加()。 可划分变量的访问控制。 如果成员变量是private属性，我们可以实现\"不准访问\"、\"只读访问\"、\"只写访问\"、\"读写访问\"。 C和C++中struct区别 c语言struct只有变量 C++语言struct 既有变量，也有函数 struct和class的区别 class默认访问权限为private， struct默认访问权限为public 对象的构造和析构 构造函数和析构函数 类对象的构造函数和析构函数，完成对象初始化和对象清理工作，这两个函数将会被编译器自动调用。 对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化操作不会做任何事。 构造函数主要作用在于创建对象时为对象的成员属性赋值，编译器自动调用，无须手动调用。 析构函数主要用于对象销毁前系统自动调用，执行一些清理工作，编译器自动调用，无须手动调用。 构造函数语法： 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。 ClassName(){} ClassName(); 声明 ClassName::ClassName(){} 析构函数语法： 析构函数函数名是在类名前面加”~”组成,没有返回值，不能有void,不能有参数，不能重载。 ~ClassName(){} ~ClassName(); 声明 ~ClassName::ClassName(){} 构造函数的定义及调用 按参数类型：分为无参构造函数和有参构造函数 按类型分类：普通构造函数和拷贝构造函数(复制构造函数) 构造函数调用规则 默认情况下，C++编译器至少为我们写的类增加3个函数 默认构造函数(无参，函数体为空) 默认拷贝构造函数，对类中非静态成员属性简单值拷贝 默认析构函数(无参，函数体为空) 如果用户定义拷贝构造函数，C++不会再提供任何默认构造函数 如果用户定义了普通构造(非拷贝)，C++不在提供默认无参构造，但是会提供默认拷贝构造 构造函数定义 //1.无参构造函数 Person(){ mAge = 0; } //2.有参构造函数 Person(int age){ mAge = age; } //3.拷贝构造函数，使用另一个对象初始化本对象 Person(const Person& person){ // 常引用 mAge = person.mAge; } 构造函数的调用 //1.调用无参构造函数 Person person1; //2.调用有参构造函数 //第一种 括号法，最常用 Person person01(100); //第二种 匿名对象(显示调用构造函数) Person(200); //匿名对象，没有名字的对象 //第三种 =号法 隐式转换 Person person04 = 100; //Person person04 = Person(100) //3.调用拷贝构造函数 Person person02(person01); Person person05 = person04; //Person person05 = Person(person04) a0为A的实例化对象,A a1 = A(a0) 和 A(a0)的区别？? 当A(a0) 有变量来接的时候，那么编译器认为他是一个匿名对象，当没有变量来接的时候，编译器认为你A(a0) 等价于 A a0 拷贝构造函数的调用时机 用一个对象初始化另一个对象 以值传递的方式传给函数对象参数 以值传递的方式返回函数的局部对象 1. 旧对象初始化新对象 Person p(10); // 有参 Person p1(p); // 拷贝，初始化新对象 Person p2 = Person(p); // 拷贝 Person p3 = p; // 拷贝 // 相当于Person p2 = Person(p); 2. 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造 void doBussiness(Person p){} // 值传递传参 doBussiness(p); 3. 函数返回局部对象 Person MyBusiness(){ Person p(10); return p; // 返回局部变量 } 深拷贝和浅拷贝 浅拷贝 同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝 浅拷贝的问题： 一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题。 深拷贝 当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。 构造函数的初始化列表 构造函数和其他函数不同，除了有名字，参数列表，函数体之外还有初始化列表。 构造函数初始化列表简单使用: //构造函数初始化列表方式初始化 Person(int a, int b, int c):mA(a),mB(b),mC(c){ } 注意：初始化成员列表(参数列表)只能在构造函数使用。 类对象作为成员 在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做对象成员。 C++中对对象的初始化是非常重要的操作，当创建一个对象的时候，C++编译器必须确保调用了所有子对象的构造函数。 但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完成初始化的。 解决办法非常简单：对于组合类调用构造函数，C++为此提供了专门的语法，即构造函数初始化列表。 类组合构造顺序： 当调用构造函数时，首先按各对象成员在类定义中的顺序依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。 也就是说，先调用对象成员的构造函数，再调用本身的构造函数。 先构造成员，再构造自身。 析构函数和构造函数调用顺序相反，先构造，后析构。 explicit关键字 C++提供了关键字explicit，禁止通过构造函数进行的隐式转换。声明为explicit的构造函数不能在隐式转换中使用。 explicit MyString(int n){ } explicit注意 explicit用于修饰构造函数,防止隐式转化。 是针对单个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言。 动态对象创建 当我们创建数组的时候，总是需要提前预定数组的长度，然后编译器分配预定长度的数组空间，在使用数组的时，会有这样的问题，数组也许空间太大了，浪费空间，也许空间不足，所以对于数组来讲，如果能根据需要来分配空间大小再好不过。 为了解决这个普遍的编程问题，在运行中可以创建和销毁对象是最基本的要求。当然c早就提供了动态内存分配（dynamic memory allocation）,函数malloc和free可以在运行时从堆中分配存储单元。然而这些函数在C++中不能很好的运行，因为它不能帮我们完成对象的初始化工作。 C动态分配内存方法 为了在运行时动态分配内存，c在他的标准库中提供了一些函数,malloc以及它的变种calloc和realloc,释放内存的free,这些函数是有效的、但是原始的，需要程序员理解和小心使用。 问题： 1)程序员必须确定对象的长度。 2)malloc返回一个void*指针，C++不允许将void*赋值给其他任何指针，必须强转。 3)malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。 4)用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。 c的动态内存分配函数太复杂，容易令人混淆，是不可接受的，C++中我们推荐使用运算符new 和 delete。 C++对象创建 当创建一个C++对象时会发生两件事: 为对象分配内存 调用构造函数来初始化那块内存 new C++中解决动态内存分配的方案是把创建一个对象所需要的操作都结合在一个称为new的运算符里。当用new创建一个对象时，它就在堆里为对象分配内存并调用构造函数完成初始化。 Person* person1 = new Person; delete person1; new操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。 只需要一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。这样在堆创建一个对象和在栈里创建对象一样简单。 delete new表达式的反面是delete表达式。delete表达式先调用析构函数，然后释放内存。 正如new表达式返回一个指向对象的指针一样，delete需要一个对象的地址。 delete只适用于由new创建的对象。 如果使用一个由malloc或者calloc或者realloc创建的对象使用delete,这个行为是未定义的。因为大多数new和delete的实现机制都使用了malloc和free,所以很可能没有调用析构函数就释放了内存。 如果正在删除的对象的指针是NULL,将不发生任何事，因此建议在删除指针后，立即把指针赋值为NULL，以免对它删除两次，对一些对象删除两次可能会产生某些问题。 动态数组 使用new和delete在堆上创建数组 //创建字符数组 char* pStr = new char[100]; //创建整型数组 int* pArr1 = new int[100]; //创建整型数组并初始化 int* pArr2 = new int[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; //释放数组内存 delete[] pStr; delete[] pArr1; delete[] pArr2; 当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数，除了在栈上可以聚合初始化，必须提供一个默认的构造函数。?? 如果在new表达式中使用[]，必须在相应的delete表达式中也使用[].如果在new表达式中不使用[], 一定不要在相应的delete表达式中使用[]. delete void *不析构 如果对一个void*指针执行delete操作，它将不执行析构函数，这将可能成为一个程序错误，除非指针指向的内容是非常简单的。 void* person = new Person(\"john\",20); // void*指针 delete person; // 不执行析构函数 static静态成员 在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。静态成员属于类，所有对象共享。 静态成员变量 在一个类中，若将一个成员变量声明为static，这种成员称为静态成员变量。与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。 静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。 静态成员变量必须在类中声明，在类外定义。 静态数据成员属于类不属于某个对象，在为对象分配空间中不包括静态成员所占空间。 静态数据成员可以通过类名或者对象名来引用。 静态成员函数 在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。 静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。 静态成员函数只能访问静态变量，不能访问普通成员变量 静态成员函数的使用和静态成员变量一样，可以通过类名或者对象名来访问 静态成员函数也有访问权限 普通成员函数可访问静态成员变量、也可以访问非静态成员变量 static const常静态成员属性 如果一个类的成员，既要实现共享，又要实现不可改变，那就用 static const 修饰。 定义静态const数据成员时，最好在类内部初始化。 class Person{ public: // static const int mShare = 10; const static int mShare = 10; // 只读区，不可修改 }; C++类对象模型 成员变量和函数分开存储 C++类对象中的变量(属性)和函数(方法)是分开存储的。 C++中的非静态数据成员直接内含在类对象中。 成员函数虽然内含在class声明之内，却不出现在对象中。 每一个非内联成员函数只会诞生一份函数实例。 this指针 this指针工作原理 C++的数据和操作也是分开存储，并且每一个非内联成员函数(non-inline member function)只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。那么问题是：这一块代码是如何区分那个对象调用自己的呢？ C++通过提供特殊的对象指针，this指针，解决上述问题。 this指针指向被调用的成员函数所属的对象。 　 C++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含指针this，用以保存这个对象的地址，也就是说虽然我们没有写上this指针，编译器在编译的时候也是会加上的。因此this也称为\"指向本对象的指针\"，this指针并不是对象的一部分，不会影响sizeof(对象)的结果。 this指针永远指向当前对象。 成员函数通过this指针即可知道操作的是那个对象的数据。this指针是一种隐含指针，它隐含于每个类的非静态成员函数中。this指针无需定义，直接使用即可。 注意：静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。 this指针的使用 当形参和成员变量同名时，可用this指针来区分类内属性 在类的非静态成员函数中返回对象本身，可使用return *this或当前对象的指针return this const 常成员 const常成员函数 在普通成员函数括号后加const修饰，为常成员函数，函数内不可修改任何普通成员变量。 const常成员函数，成员函数体内不可以修改本类中的任何普通成员变量 除非普通成员变量类型符前用mutable声明， class Person{ public: //在函数括号后面加上const修饰，成员变量不可修改,除了mutable变量 void sonmeOperate() const{ // const常成员函数 //this->mAge = 200; //非mutable变量不可修改 this->mID = 10; // mutable变量 } private: int mAge; mutable int mID; // mutable变量 }; const修饰对象(常对象) 常对象只能调用const常成员函数 常对象可访问 const 或非 const 数据成员，不能修改成员属性，除非成员用mutable修饰 const Person person; // 常对象 友元 类的主要特点之一是数据隐藏，即类的私有成员无法在类的外部(作用域之外)访问。但是，有时候需要在类的外部访问类的私有成员，怎么办？ 解决方法是使用友元函数，友元函数是一种特权函数，C++允许这个特权函数访问私有成员。 比如你的家，有客厅，有你的卧室，那么你的客厅是Public的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的闺蜜好基友进去。 友元语法 friend关键字只出现在声明处 一个全局函数、某个类中的成员函数、甚至整个类都可声明为友元 友元函数不是类的成员，不带this指针 友元函数可访问对象任意成员属性，包括私有属性 友元全局函数 将全局函数声明为友元的写法如下： friend 返回值类型 函数名(参数表); //全局函数 void CleanBedRoom(Building& building){} // 声明友元 class Building{ //全局函数做友元函数 friend void CleanBedRoom(Building& building); public: Building(); private: int price; } 友元成员函数 将其他类的成员函数声明为友元的写法如下： friend 返回值类型 其他类的类名::成员函数名(参数表); 但是，不能把其他类的私有成员函数声明为友元。 class Building; // 前向声明，，以便后面的类使用 //类 class MyFriend{ public: //成员函数 void LookAtBedRoom(Building& building); }; // 声明友元 class Building{ //声明成员函数做友元函数 friend void MyFriend::LookAtBedRoom(Building& building); public: Building(); private: int price; } 友元类 一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。在类定义中声明友元类的写法如下： friend class 类名; //友元类 class MyFriend{ public: Building bld; void ModifyPrice(){ bld.price += 1000; //因MyFriend是Building的友元类，故此处可以访问其私有成员 } }; // 声明友元 class Building{ //友元类 friend class MyFriend; public: Building(); private: int price; } [友元类注意] 友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。 友元关系不能被继承。 友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。 运算符重载 运算符重载基本概念 运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。 运算符重载(operator overloading)只是一种”语法上的方便”,也就是它只是另一种函数调用的方式。 在C++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。 运算符重载语法： 定义重载的运算符就像定义函数，只是该函数的名字是operator@,这里的@代表了被重载的运算符。函数的参数中参数个数取决于两个因素。 运算符是一元(一个参数)的还是二元(两个参数)； 运算符被定义为全局函数(对于一元是一个参数，对于二元是两个参数)，还是成员函数(对于一元没有参数，对于二元是一个参数–此时该类的对象用作左参数) 可重载的运算符 几乎C中所有的运算符都可以重载，但运算符重载的使用时相当受限制的。特别是不能使用C中当前没有意义的运算符(例如用**求幂)不能改变运算符优先级，不能改变运算符的参数个数。 自增自减(++或--)运算符重载 重载的++和--运算符有点让人不知所措，因为我们总是希望能根据它们出现在所作用对象的前面还是后面来调用不同的函数。解决办法很简单，例如当编译器看到++a(前置++)，它就调用operator++(a),当编译器看到a++（后置++），它就会去调用operator++(a,int) 前置++ 前置++a形式，对象先++或--，返回当前对象，返回的是新对象。 public: //重载前置++ Complex& operator++(){ mA++; mB++; return *this; } 后置++ 后置a++形式是先返回，然后对象++或者--，返回的是对象的原值。 public: //重载后置++ Complex operator++(int){ Complex temp; // 后置需要临时对象 temp.mA = this->mA; temp.mB = this->mB; mA++; mB++; return temp; } 优先使用++和--的标准形式，优先调用前置++。 如果定义了++a，也要定义a++，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载operator++和operator--时应该模仿他们对应的内置操作符。 调用代码时候，要优先使用前置形式，除非确实需要后缀形式返回的原值，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前置形式少创建了一个临时对象。 指针运算符(*或->)重载 class SmartPointer{ public: SmartPointer(Person* person){ this->pPerson = person; } //重载指针的->操作符 Person* operator->(){ return pPerson; } //重载指针的*操作符 Person& operator*(){ return *pPerson; } ~SmartPointer(){ if (pPerson != NULL){ delete pPerson; } } public: Person* pPerson; }; 赋值(=)运算符重载 public: //重载赋值运算符 Person& operator=(const Person& person){ this->mID = person.mID; this->mAge = person.mAge; return *this; } void test01(){ Person person1(10, 20); Person person2 = person1; //调用拷贝构造 //person2从已有的person1来初始化创建，调用拷贝构造函数 person2 = person1; //调用重载operator=函数 //person2已经创建，不需要再调用构造函数，调用重载的赋值运算符 } 如果没有重载赋值运算符，编译器会自动创建默认的赋值运算符重载函数。行为类似默认拷贝构造，进行简单值拷贝。 等于和不等于(==或!=)运算符重载 public: //重载==号操作符 bool operator==(const Complex& complex){ if (strcmp(this->pName,complex.pName) == 0 && this->mID == complex.mID && this->mAge == complex.mAge){ return true; } return false; } //重载!=操作符 bool operator!=(const Complex& complex){ if (strcmp(this->pName, complex.pName) != 0 || this->mID != complex.mID || this->mAge != complex.mAge){ return true; } return false; } 函数调用符号()重载 class Complex{ public: int operator()(int x,int y){ return x + y; } }; void test01(){ Complex complex; // 对象当做函数来调用 // 重载() cout 声明友元，友元函数是一个全局函数，友元函数可以访问某个类私有数据。 案例: 重载左移操作符( //可以同时重载不同类对象类型 // 重载不要重载&&或|| 不能重载operator&& 和 operator|| 的原因是，无法实现短路规则。说得更具体一些，内置版本版本特殊之处在于：内置版本的&&和||首先计算左边的表达式，如果这完全能够决定结果，就无需计算右边的表达式了，而且能够保证不需要。我们都已经习惯这种方便的特性了。 运算符和结合性 符号重载总结 =, [], () 和 -> 操作符只能通过成员函数进行重载 >只能通过全局函数配合友元函数进行重载 不要重载 && 和 || 操作符，因为无法实现短路规则 常规建议 继承和派生 继承概述 继承基本概念 C++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。 一个B类继承于A类，或称从类A派生类B。这样的话，类A成为基类（父类）， 类B成为派生类（子类）。 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 派生类定义 派生类定义格式： Class 派生类名 : 继承方式 基类名 { //派生类新增的数据成员和成员函数 } 三种继承方式： public ： 公有继承 private ： 私有继承 protected ： 保护继承 从继承源上分： 单继承：指每个派生类只直接继承了一个基类的特征 多继承：指多个基类派生出一个派生类的继承关系,多继承的派生类直接继承了不止一个基类的特征 派生类访问控制 派生类继承基类，派生类拥有基类中全部成员变量和成员方法（除了构造和析构之外的成员方法），但是在派生类中，继承的成员并不一定能直接访问，不同的继承方式会导致不同的访问权限。 派生类的访问权限规则如下： 继承中的构造和析构 对象构造和析构的调用原则 继承中的构造和析构 子类对象在创建时会首先调用父类的构造函数 父类构造函数执行完毕后，才会调用子类的构造函数 当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数 析构函数调用顺序和构造函数相反 继承与组合混搭的构造和析构顺序 ==父类->对象成员->子类== 先构造父类，如果有嵌套类则优先构造嵌套类，最后构造当前最后子类 继承中同名成员的处理方法 当子类成员和父类成员同名时，子类依然从父类继承同名成员（占据空间），但是被隐藏了 如果子类有成员和父类同名，子类访问其成员默认访问子类的成员(本作用域，就近原则)，子类同名覆盖父类（重名覆盖，包括重载也被覆盖隐藏？？） 在子类通过类名限定符声明作用域父类::调用同名父类成员(在派生类中要使用基类的同名成员，显式使用类名限定符) 子类中重新定义基类中的一个重载函数，原来基类的函数将被隐藏，（重载） 不能继承的函数 不是所有的函数都能自动从基类继承到派生类中。 构造函数和析构函数用来处理对象的创建和析构操作，构造和析构函数只知道对它们的特定层次的对象做什么，也就是说构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。 另外operator=也不能被继承，因为它完成类似构造函数的行为。也就是说尽管我们知道如何由=右边的对象如何初始化=左边的对象的所有成员，但是这个并不意味着对其派生类依然有效。 在继承的过程中，如果没有创建这些函数，编译器会自动生成它们。（重名覆盖，包括重载也被覆盖隐藏） 继承中的静态成员特性 静态成员函数和非静态成员函数的共同点: 他们都可以被继承到派生类中。 如果重新定义一个静态成员函数，所有在基类中的其他重载函数会被隐藏。（重名覆盖，包括重载也被覆盖隐藏） 如果我们改变基类中一个函数的特征，所有使用该函数名的基类版本都会被隐藏。 静态成员函数不能是虚函数（virtual function）. 多继承 多继承概念 我们可以从一个类继承，我们也可以能同时从多个类继承，这就是多继承。但是由于多继承是非常受争议的，从多个类继承可能会导致函数、变量等同名导致较多的歧义。 多继承会带来一些二义性的问题， 如果两个基类中有同名的函数或者变量，通过类名::显式指定调用哪个基类的版本。 菱形继承和虚继承 两个派生类继承同一个基类而又有某个类同时继承者两个派生类，这种继承被称为菱形继承。 这种继承所带来的问题： 羊继承了动物的数据和函数，鸵同样继承了动物的数据和函数，当草泥马调用函数或者数据时，就会产生二义性。 草泥马继承自动物的函数和数据重复继承了两份数据，其实我们只需要一份就可以。 对于这种菱形继承所带来的两个问题，C++为我们提供了一种方式，采用虚继承方式虚基类。 class BigBase{}; class Base1 : ==virtual== public BigBase{}; class Base2 : ==virtual== public BigBase{}; class Derived : public Base1, public Base2{}; class BigBase{}; class Base1 : virtual public BigBase{}; class Base2 : virtual public BigBase{}; class Derived : public Base1, public Base2{}; 以上程序Base1 ，Base2采用虚继承方式继承BigBase,那么BigBase被称为虚基类。 通过virtual虚继承解决了菱形继承所带来的二义性问题。 虚继承实现原理 当使用虚继承时，虚基类是被共享的，也就是在继承体系中无论被继承多少次，对象内存模型中均只会出现一个虚基类的子对象（这和多继承是完全不同的）。即使共享虚基类，但是必须要有一个类来完成基类的初始化（因为所有的对象都必须被初始化，哪怕是默认的），同时还不能够重复进行初始化，那到底谁应该负责完成初始化呢？ C++标准中选择在每一次继承子类中都必须书写初始化语句（因为每一次继承子类可能都会用来定义对象）， 但是虚基类的初始化是由最后的子类完成初始化，其他的初始化语句都不会调用。 class BigBase{ public: BigBase(int x){mParam = x;} public: int mParam; }; class Base1 : virtual public BigBase{ // 虚继承 public: Base1():BigBase(10){ } //不立即调用BigBase构造 }; class Base2 : virtual public BigBase{ // 虚继承 public: Base2():BigBase(10){ } //不立即调用BigBase构造 }; class Derived : public Base1, public Base2{ // 多继承 public: Derived():BigBase(10){ } //调用BigBase构造 }; //每一次继承子类中都必须书写初始化语句，虽然不一定会被调用 注意： 工程开发中真正意义上的多继承是几乎不被使用，因为多重继承带来的代码复杂性远多于其带来的便利，多重继承对代码维护性上的影响是灾难性的，在设计方法上，任何多继承都可以用单继承代替。 多态 多态基本概念 多态是面向对象程序设计语言中数据封装和继承之外的第三个基本特征。 多态性(polymorphism)提供接口与具体实现之间的另一层隔离。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性，项目不仅在最初创建时期可以扩展，而且当项目在需要有新的功能时也能扩展。 C++支持编译时多态(静态多态)和运行时多态(动态多态)，运算符重载和函数重载就是==编译时多态==，而派生类和虚函数实现==运行时多态==，C++动态多态性是通过虚函数来实现的。 静态多态和动态多态的区别就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，就是说地址是早绑定的。而如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这这就属于晚绑定(动态多态,运行时多态)。 向上类型转换:对象可以作为自己的类或者作为它的基类的对象来使用。还能通过基类的地址来操作它。取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这种称为向上类型转换。 也就是说：父类引用或指针可以指向子类对象，通过父类的指针或引用来操作子类对象。 动态多态原理 首先，我们看看编译器如何处理虚函数。当编译器发现我们的类中有虚函数的时候，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指向对象的虚函数表的指针vpointer(缩写vptr)。在多态调用的时候，根据vptr指针，找到虚函数表来实现动态绑定。 在编译阶段，编译器秘密增加了一个vptr指针，但是此时vptr指针并没有初始化指向虚函数表(vtable),什么时候vptr才会指向虚函数表？在对象构建的时候，也就是在对象初始化调用构造函数的时候。编译器首先默认会在我们所编写的每一个构造函数中，增加一些vptr指针初始化的代码。如果没有提供构造函数，编译器会提供默认的构造函数，那么就会在默认构造函数里做此项工作，初始化vptr指针，使之指向本对象的虚函数表。 起初，子类继承基类，子类继承了基类的vptr指针，这个vptr指针是指向基类虚函数表，当子类调用构造函数，使得子类的vptr指针指向了子类的虚函数表。 多态的成立条件 有继承 子类重写父类虚函数方法 a) 返回值，函数名字，函数参数，必须和父类完全一致(析构函数除外) b) 子类中virtual关键字可写可不写，建议写 类型兼容，父类指针，父类引用 指向 子类对象 虚函数 C++动态多态性是通过虚函数来实现的，虚函数允许子类（派生类）重新定义父类（基类）成员函数，称为覆盖，或者称为重写(override)。 对于特定的函数进行动态绑定，C++要求在基类中声明这个函数的时候使用virtual关键字,动态绑定也就对virtual虚函数起作用。 为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，定义时候不需要 如果一个成员函数被声明为virtual，那么在所有派生类中它都是virtual虚函数，(virtual具有传递性) 在派生类中virtual函数的重定义称为重写(override) Virtual关键字只能修饰成员函数 构造函数不能为虚函数 class Animal{ public: // 虚函数 virtual void speak(){ cout 注意: 仅需要在基类中声明一个函数为virtual.调用所有匹配基类声明行为的派生类函数都将使用虚机制。虽然可以在派生类声明前使用关键字virtual(这也是无害的)，但这个样会使得程序显得冗余和杂乱。 纯虚函数(抽象类） 在设计时，常常希望基类仅仅作为其派生类的一个公共接口，而不希望用户实际的创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。 如果类中出现了纯虚函数(pure virtual function)，那么这个类是抽象类(abstract class)。 纯虚函数使用关键字==virtual==，并在其后面加上===0==。 抽象类不能实例化对象。 当继承一个抽象类的时候，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。 Virtual void fun() = 0;告诉编译器在vtable中为函数保留一个位置，但在这个特定位置不放地址。 // 抽象基类 class People{ public: // 纯虚函数 virtual void showName() = 0; } 建立公共接口目的是为了将子类公共的操作抽象出来，可以通过一个公共接口来操纵一组类，且这个公共接口不需要事先(或者不需要完全实现)。可以创建一个公共类。 纯虚函数和多继承 多继承带来了一些争议，但是接口继承可以说一种毫无争议的运用了。 绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念，C++中没有接口的概念，但是可以通过纯虚函数实现接口。 接口类中只有函数原型定义，没有任何数据定义。 多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。 注意:除了析构函数外，其他声明都是纯虚函数。？？ 虚析构函数 虚析构函数作用 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 class People{ public: // 虚析构函数 virtual ~People(){ cout 纯虚析构函数 纯虚析构函数在C++中是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。 class B{ public: //纯析构函数 virtual ~B() = 0; }; 纯虚析构函数和非纯析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。(如果类中出现了 纯虚函数，那么这个类是抽象类，抽象类 不可实例化对象) 如果类的目的不是为了实现多态，作为基类来使用，就不要声明虚析构函数???，反之，则应该为类声明虚析构函数。 重载 重定义 重写 重载，同一作用域的同名函数 同一个作用域 参数个数，参数顺序，参数类型不同 和函数返回值，没有关系 const也可以作为重载条件 //do(const Teacher& t){} do(Teacher& t){} 重定义（隐藏） 有继承 子类（派生类）重新定义父类（基类）的同名成员（非virtual函数） 重写（覆盖） 有继承 子类（派生类）重写父类（基类）的virtual虚函数 函数返回值，函数名字，函数参数，必须和基类中的虚函数一致 class A{ public: //同一作用域下，func1函数重载 void func1(int a){} void func1(int a,int b){} void func2(){} virtual void func3(){} // 虚函数 }; class B : public A{ // 继承 public: //重定义基类的func2,隐藏了基类的func2方法 void func2(){} //重写基类的func3virtual虚函数，也可以覆盖基类func3 virtual void func3(){} }; 类成员的指针 指向成员变量的指针 定义格式 ::* int A::*pPram; 类名::限定 赋值/初始化 ::* = &:: int A::*pParam = &A::param; &取地址+类名::限定 解引用 .* ->* a.*pParam; //对象 a->*pParam; //对象指针 通过对象/对象指针调用 示例： class A{ public: A(int param){ mParam = param; } public: int mParam; }; void test(){ A a1(100); int* p1 = &a1.mParam; cout *p2:\" *p2 指向成员函数的指针 定义指向成员变量的指针 (::*)（） 例如: void (A::*pFunc)(int,int); 赋值/初始化 （::*）（） = &:: 例如: void (A::pFunc)(int,int) = &A::func; 解引用 （.*）（） （->*）（） 例如: A a; (a.*pFunc)(10,20); (a->*pFunc)(10,20); 示例： class A{ public: int func(int a,int b){ return a + b; } }; void test(){ A a1; A* a2 = new A; //定义并初始化成员函数指针 int(A::*pFunc)(int, int) = &A::func; //指针解引用 cout *pFunc)(10,20):\" *pFunc)(10, 20) 指向静态成员的指针 指向类静态数据成员的指针 指向静态数据成员的指针的定义和使用与普通指针相同，仅需加类名::限定，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。 指向类静态成员函数的指针 指向静态成员函数的指针的定义和使用与普通指针相同，仅需加类名::限定，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。 示例： class A{ public: static void dis(){ // 向类静态成员函数 cout C++模板 模板概论 泛型编程（Generic Programming）是一种编程范式，通过将类型参数化来实现在同一份代码上操作多种数据类型，泛型是一般化并可重复使用的意思。泛型编程最初诞生于C++中，目的是为了实现C++的STL（标准模板库）。 模板（template）是泛型编程的基础，一个模板就是一个创建类或函数的蓝图或公式。例如，当使用一个vector这样的泛型类型或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。 C++提供两种模板机制:==函数模板==和==类模板== 总结： 模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为类属。 模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。 函数模板 C++所谓函数模板(function template.)，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就成为函数模板。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。 类型参数 一个模板类型参数（type parameter）表示的是一种类型。我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数前必须使用关键字class 或 typename： //class 和 typename都是一样的，用哪个都可以 template void MySwap(T& a,T& b){ T temp = a; a = b; b = temp; } 关键字typename和class是一样的作用，但显然typename比class更为直观，它更清楚地指出随后的名字是一个类型名。 编译器用模板类型实参为我们实例化（instantiate）特定版本的函数，一个版本称做模板的一个实例（instantiation）。当我们调用一个函数模板时，编译器通常用函数实参来为我们推断模板实参。当然如果函数没有模板类型的参数，则我们需要特别指出来： int a = 10, b = 20; cout (a,b) 指出模板参数为int 用模板是为了实现泛型，可以减轻编程的工作量，增强函数的重用性。 非类型参数 在模板中还可以定义非类型参数（nontype parameter），一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数： #include #include using namespace std; // 整形模板 template void add() { cout void func1(const char *str) { cout void func2(const char *str) { cout void func3(const char *c) { f(c); } // 全局函数 void print_str(const char *c) { cout (); func1(\"pointer\"); func2(\"reference\"); func3(\"template function pointer\"); return 0; } 当实例化时，非类型参数被一个用户提供的或编译器推断出的值所替代。一个非类型参数可以是一个整型，或者是一个指向对象或函数的指针或引用：绑定到整形（非类型参数）的实参必须是一个常量表达式，绑定到指针或引用（非类型参数）的实参必须具有静态的生存期（比如全局变量），不能把普通局部变量 或 动态对象绑定到指针或引用的非类型形参。 函数模板和普通函数调用规则 C++编译器优先考虑普通函数 可以通过空模板实参列表的语法限定编译器只能通过模板匹配 函数模板可以像普通函数那样可以被重载 如果函数模板可以产生一个更好的匹配，那么选择模板 函数模板和普通函数区别 调用函数模板，严格匹配类型 函数模板不允许自动隐式类型转化？？ 普通函数能够自动进行类型转化 类模板 类模板基本概念 有时，有两个或多个类，其功能是相同的，仅仅是数据类型不同。 类模板（class template）用于实现类所需数据的类型参数化，用来生成类的蓝图。 函数模板与类模板的异同 与函数模板的不同之处是，函数模板的实例化是由编译程序在处理函数调用时自动完成的，类模板不能自动推导模板参数类型，所以类模板的实例化必须由程序员在程序中显式地提供模板实参。即函数模板允许隐式调用和显式调用而类模板只能显示调用。 与函数模板一样，类模板参数可以是类型参数，也可以是非类型参数。 类模板类内实现 //类模板 类内实现 template class Person{ public: Person(NameType name, AgeType age){ this->mName = name; this->mAge = age; } void showPerson(){ cout mName mAge P1(\"小明\", 18);// 类模板 P1.showPerson(); } 类模板类外实现 与其他类一样，我们既可以在类模板内部，也可以在类模板外部定义其成员函数。定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。 默认情况下，对于一个实例化了的类模板，其成员函数只有在使用时才被实例化。如果一个成员函数没有被使用，则它不会被实例化。 每个类外实现再次加上template声明 // 类模板声明 template class Person{ public: Person(T1 name, T2 age); void showPerson(); public: T1 mName; T2 mAge; }; //类模板类外实现 template Person::Person(T1 name, T2 age){ this->mName = name; this->mAge = age; } //类外实现 template void Person::showPerson(){ cout mName mAge p(\"Obama\", 20); p.showPerson(); } 类模板和友元 当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板的友元，则友元被授权可以访问所有模板的实例。如果友元自身是模板，类可以授权给所有友元模板的实例，也可以只授权给特定实例。 // 前置声明，在将模板的一个特定实例声明为友元时要用到 template class Pal; // 普通类 class C { friend class Pal; // 用类C实例化的Pal是C的一个友元 template friend class Pal2; //Pal2所有实例都是C的友元;无须前置声明 }; // 模板类 template class C2 { // C2的每个实例将用相同类型实例化的Pal声明为友元,一对一关系 friend class Pal; // Pal2的所有实例都是C2的每个实例的友元，不需要前置声明 template friend class Pal2; // Pal3是普通非模板类，它是C2所有实例的友元 friend class Pal3; }; 类模板的static成员 类模板可以声明static成员。类模板的每一个实例都有其自己独有的static成员对象，对于给定的类型X，所有class_name类型的对象共享相同的一份static成员实例。 template class Foo { public: void print(); //...其他操作 private: static int i; // 静态成员 }; template void Foo::print() { cout int Foo::i = 10; // 初始化为10 int main() { Foo f1; Foo f2; Foo f3; f1.print(); // 输出11 f2.print(); // 输出12 f3.print(); // 输出11 return 0; } 我们可以通过类类型对象来访问一个类模板的static对象，也可以使用作用域运算符（::）直接访问静态成员。类似模板类的其他成员函数，一个static成员函数也只有在使用时才会实例化。 类模板做函数参数 //类模板做函数参数 void DoBussiness( Person& p ){ p.mAge += 20; p.mName += \"_vip\"; p.PrintPerson(); } void test01(){ Person p(\"John\", 30);// 类模板 DoBussiness(p);//类模板做函数参数 } 类模板派生普通类 子类实例化的时候需要具体化的父类，子类需要知道父类的具体类型是什么样的,这样C++编译器才能知道给子类分配多少内存 继承类模板的时候，必须要确定基类类模板的类型 //类模板 template class MyClass{ public: MyClass(T property){ this->mProperty = property; } public: T mProperty; }; //普通派生类 class SubClass : public MyClass{ // 父类类模板具体类型 public: SubClass(int b) : MyClass(20){ // 初始化父类 this->mB = b; } public: int mB; }; 类模板派生类模板 继承类模板的时候，必须要确定基类类模板的类型 //父类类模板 template cBase{ public: T m; }; //子类类模板 template class Child2 : public Base{ //继承类模板的时候，必须要确定基类的大小 public: T mParam; }; void test02(){ Child2 d2; //类模板 } 模板实现原理 c++编译过程 hello.cpp程序是高级c语言程序，这种程序易于被人读懂。为了在系统上运行hello.c程序，每一条c语句都必须转化为低级的机器指令。然后将这些机器指令打包成可执行目标文件格式，并以二进制形式存储于磁盘中。 预处理(Pre-processing) -> 编译(Compiling) ->汇编(Assembling) -> 链接(Linking) 模板实现机制 函数模板机制结论： 编译器并不是把函数模板处理成能够处理任何类型的函数，函数模板通过具体类型产生不同的函数 编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。 模板的局限性 template void f(T a, T b) { … } 如果代码实现时定义了赋值操作 a = b，但是T为数组，这种假设就不成立了 同样，如果里面的语句为判断语句 if(a>b),但T如果是结构体，该假设也不成立，另外如果是传入的数组，数组名为地址，因此它比较的是地址，而这也不是我们所希望的操作。 总之，编写的模板函数很可能无法处理某些类型，另一方面，有时候通用化是有意义的，但C++语法不允许这样做。为了解决这种问题，可以提供模板的重载，为这些特定的类型提供具体化的模板。 C++类型转换 类型转换(cast)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。 转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。 一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。 标准C++提供了一个显式的类型转换的语法，来替代旧的C风格的类型转换。 静态转换(static_cast) static_cast常用于基本数据类型之间的转换 如把int转换成char，把char转换成int。 //基础数据类型转换 void test01(){ char a = 'a'; double b = static_cast(a); } static_cast也可以用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。 实际一般用dynamic_cast更安全。 static_cast向上类型转换（把子类的指针或引用转换成父类）是安全的； static_cast向下类型转换（把基类指针或引用转换成子类），没有动态类型检查，所以是不安全的（不能检查出错误类型转化）。 //继承关系 指针 互相转换 void test02(){ //继承关系指针转换 Animal* animal01 = NULL; Dog* dog01 = NULL; //子类指针转成父类指针,安全 Animal* animal02 = static_cast(dog01); //父类指针转成子类指针，不安全 Dog* dog02 = static_cast(animal01); } //继承关系 引用 相互转换 void test03(){ Animal ani_ref; Dog dog_ref; //继承关系指针转换 Animal & animal01 = ani_ref; Dog & dog01 = dog_ref; //子类指针转成父类指针,安全 Animal& animal02 = static_cast(dog01); //父类指针转成子类指针，不安全 Dog& dog02 = static_cast(animal01); } 无继承关系指针无法转换。 //无继承关系指针转换 void test04(){ Animal* animal01 = NULL; Other* other01 = NULL; //转换失败 //Animal* animal02 = static_cast(other01); } 动态转换(dynamic_cast) dynamic_cast不可以用于基本数据类型之间的转换。 //普通类型转换 void test01(){ //不支持基础数据类型 int a = 10; //double a = dynamic_cast(a); // error } dynamic_cast主要用于类层次间的基类（父类）和派生类（子类）之间指针或引用的上行转换和下行转换； dynamic_cast在进行向上类型转换（把子类的指针或引用转换成父类）时，dynamic_cast和static_cast的效果是一样的，都是安全的； dynamic_cast在进行向下类型转换（把基类指针或引用转换成子类），dynamic_cast具有类型检查的功能，比static_cast更安全（可以检查出非法类型转换） //继承关系指针 void test02(){ Animal* animal01 = NULL; Dog* dog01 = new Dog; //子类指针转换成父类指针 可以 Animal* animal02 = dynamic_cast(dog01); animal02->ShowName(); //父类指针转换成子类指针 不可以 //Dog* dog02 = dynamic_cast(animal01); } //继承关系引用 void test03(){ Dog dog_ref; Dog& dog01 = dog_ref; //子类引用转换成父类引用 可以 Animal& animal02 = dynamic_cast(dog01); animal02.ShowName(); } 无继承关系指针无法转换。 //无继承关系指针转换 void test04(){ Animal* animal01 = NULL; Other* other = NULL; //不可以 //Animal* animal02 = dynamic_cast(other); } 常量转换(const_cast) const_cast用来去除指针/引用的const属性。但是不可去除普通变量的const 常量指针被转化成非常量指针，并且仍然指向原来的对象； 常量引用被转换成非常量引用，并且仍然指向原来的对象； //常量指针转换成非常量指针 void test01(){ const int* p = NULL; //常量指针 int* np = const_cast(p); //转为非常量指针 int* pp = NULL; //非常量指针 const int* npp = const_cast(pp); //转为常量指针？？ } //常量引用转换成非常量引用 void test02(){ int num = 10; int & refNum = num; //非常量引用 const int& refNum2 = const_cast(refNum); //转为常量引用？？ } 普通变量不能使用const_cast操作符去直接移除它的const const int a = 10; //不能对非指针或非引用进行转换 //int b = const_cast(a); // error 重新解释转换(reinterpret_cast) 这是最不安全的一种转换机制，最有可能出问题。 主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针。 C++异常 异常基本概念 提供异常的基本目的就是为了处理上面的问题。基本思想是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的调用者能够处理这个问题。也就是《C++ primer》中说的：将问题检测和问题处理相分离。 异常处理就是处理程序中的错误。所谓错误是指在程序运行的过程中发生的一些异常事件（如：除0溢出，数组下标越界，所要读取的文件不存在,空指针，内存不足等等）。 C语言如何处理异常？ 在C语言的世界中，对错误的处理总是围绕着两种方法：一是使用整型的返回值标识错误；二是使用errno宏（可以简单的理解为一个全局整型变量）去记录错误。当然C++中仍然是可以用这两种方法的。 这两种方法最大的缺陷就是会出现不一致问题。例如有些函数返回1表示成功，返回0表示出错；而有些函数返回0表示成功，返回非0表示出错。 还有一个缺点就是函数的返回值只有一个，你通过函数的返回值表示错误代码，那么函数就不能返回其他的值。当然，你也可以通过指针或者C++的引用来返回另外的值，但是这样可能会令你的程序略微晦涩难懂。 C++异常机制相比C语言异常处理的优势? 异常不可忽略。如果程序出现异常，但是没有被捕获，程序就会终止。而如果使用C语言的error宏或者函数返回值，调用者都有可能忘记检查，从而没有对错误进行处理，结果造成程序莫名其面的终止或出现错误的结果。 异常包含语义信息，有时你从类名就能够体现出来。 异常作为一个类，可以拥有自己的成员，这些成员就可以传递足够的信息。 异常处理可以在调用跳级。这是一个代码编写时的问题：假设在有多个函数的调用栈中出现了某个错误，使用异常处理的栈展开机制，只需要在一处进行处理就可以了，不需要每级函数都处理。 异常语法 异常基本语法 //抛出异常 throw 0; //处理异常 try{ } catch (int e){ } catch ( ... ){ } 总结: 若有异常则通过throw操作创建一个异常对象并抛出。 将可能抛出异常的程序段放到try块之中。 如果在try段执行期间没有引起异常，那么跟在try后面的catch字句就不会执行。 catch子句会根据出现的先后顺序被检查，匹配的catch语句捕获并处理异常(或继续抛出异常)。 如果匹配的处理未找到，则运行函数terminate将自动被调用，其缺省功能调用abort终止程序。 处理不了的异常，可以在catch的最后一个分支，使用throw，向上抛。 C++异常处理使得异常的引发和异常的处理不必在一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计对不同类型异常的处理。 异常严格类型匹配 异常机制和函数机制互不干涉,但是捕捉方式是通过严格类型匹配。 throw的异常是有类型的，可以是数字、字符串、类对象。 throw的异常是有类型的，catch需严格匹配异常类型。 void TestFunction(){ //throw 10; //抛出int类型异常 //throw 'a'; //抛出char类型异常 //throw \"abcd\"; //抛出char*类型异常 string exstr = \"string exception!\"; throw exstr; //抛出string类型异常 } int main(){ //尝试执行 try{ TestFunction(); } //捕获异常 catch (int e){ cout 函数的异常声明列表 为了增强程序的可读性和可维护性，使程序员在使用一个函数时就能看出这个函数可能会拋出哪些异常，C++ 允许在函数声明和定义时，加上它所能拋出的异常的列表 // 声明函数可以抛出的异常 void func() throw(int, double, myException); void func() throw(int, double, myException) { } // 函数不会拋出任何异常 void funcNone() throw(); // 默认可以拋出任何类型的异常 void funcAll(); 栈解旋(unwinding) 异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构，这一过程称为栈的解旋(unwinding)。 异常接口声明 为了加强程序的可读性，可以在函数声明中列出可能抛出异常的所有类型，例如：void func() throw(A,B,C);这个函数func能够且只能抛出类型A,B,C及其子类型的异常。 如果在函数声明中没有包含异常接口声明，则此函数可以抛任何类型的异常，例如:void func() 一个不抛任何类型异常的函数可声明为:void func() throw() 如果一个函数抛出了它的异常接口声明所不允许抛出的异常,unexcepted函数会被调用，该函数默认行为调用terminate函数中断程序。 //可抛出所有类型异常 void TestFunction01(){ throw 10; } //只能抛出int char char*类型异常 void TestFunction02() throw(int,char,char*){ string exception = \"error!\"; throw exception; } //不能抛出任何类型异常 void TestFunction03() throw(){ // throw 10; // 错误 } C++标准异常库 标准库介绍 标准库中也提供了很多的异常类，它们是通过类继承组织起来的。异常类继承层级结构图如下： 每个类所在的头文件在图下方标识出来。 标准异常类的成员： ① 在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。 ② logic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形式参数，用于异常信息的描述。 ③ 所有的异常类都有一个what()方法，返回const char* 类型（C风格字符串）的值，描述异常信息。 标准异常类的具体描述： 异常名称 描述 exception 所有标准异常类的父类 bad_alloc 当operator new and operator new[]，请求分配内存失败时 bad_exception 这是个特殊的异常，如果函数的异常抛出列表里声明了bad_exception异常，当函数内部抛出了异常抛出列表中没有的异常，这是调用的unexpected函数中若抛出异常，不论什么类型，都会被替换为bad_exception类型 bad_typeid 使用typeid操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出bad_typeid异常 bad_cast 使用dynamic_cast转换引用失败的时候 ios_base::failure io操作过程出现错误 logic_error 逻辑错误，可以在运行前检测的错误 runtime_error 运行时错误，仅在运行时才可以检测的错误 logic_error的子类： 异常名称 描述 length_error 试图生成一个超出该类型最大长度的对象时，例如vector的resize操作 domain_error 参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数 out_of_range 超出有效范围 invalid_argument 参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常 runtime_error的子类： 异常名称 描述 range_error 计算结果超出了有意义的值域范围 overflow_error 算术计算上溢 underflow_error 算术计算下溢 invalid_argument 参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常 #include void fun(int age){ if (age 150){ throw out_of_range(\"年龄应该在0-150岁之间!\"); } } int main(){ try{ fun(151); } catch (out_of_range& ex){ cout 编写自己的异常类 ① 标准库中的异常是有限的； ② 在自己的异常类中，可以添加自己的信息。（标准库中的异常类值允许设置一个用来描述异常的字符串）。 2. 如何编写自己的异常类？ ① 建议自己的异常类要继承标准异常类。因为C++中可以抛出任何类型的异常，所以我们的异常类可以不继承自标准异常，但是这样可能会导致程序混乱，尤其是当我们多人协同开发时。 ② 当继承标准异常类时，应该重载父类的what函数和虚析构函数。 ③ 因为栈展开的过程中，要复制异常类型，那么要根据你在类中添加的成员考虑是否提供自己的复制构造函数。 //自定义异常类 class MyOutOfRange : public exception{ public: // 构造 MyOutOfRange(const string errorInfo) { this->m_Error = errorInfo; } MyOutOfRange(const char * errorInfo) { // 构造重载 this->m_Error = string( errorInfo); } // 析构 virtual ~MyOutOfRange() { } // 拷贝构造 virtual const char * what() const { return this->m_Error.c_str() ; } string m_Error; }; C++输入和输出流 流的概念和流类库的结构 程序的输入指的是从输入文件将数据传送给程序， 程序的输出指的是从程序将数据传送给输出文件。 C++输入输出包含以下三个方面的内容： 对系统指定的标准设备的输入和输出。即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称标准I/O。 以外存磁盘文件为对象进行输入和输出，即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，简称文件I/O。 对内存中指定的空间进行输入和输出。通常指定一个字符数组作为存储空间(实际上可以利用该空间存储任何信息)。这种输入和输出称为字符串输入输出，简称串I/O。 C++编译系统提供了用于输入输出的iostream类库。iostream这个单词是由3个部 分组成的，即i-o-stream，意为输入输出流。在iostream类库中包含许多用于输入输出的 类。 ios是抽象基类，由它派生出istream类和ostream类，两个类名中第1个字母i和o分别代表输入(input)和输出(output)。 istream类支持输入操作，ostream类支持输出操作， iostream类支持输入输出操作。iostream类是从istream类和ostream类通过多重继承而派生的类。 C++对文件的输入输出需要用ifstrcam和ofstream类，两个类名中第1个字母i和o分别代表输入和输出，第2个字母f代表文件 (file)。ifstream支持对文件的输入操作， ofstream支持对文件的输出操作。类ifstream继承了类istream，类ofstream继承了类ostream，类fstream继承了 类iostream。 I/O类库中还有其他一些类，但是对于一般用户来说，以上这些已能满足需要了。 与输入和输出流类库有关的头文件 输入和输出流类类库中不同的类的声明被放在不同的头文件中，用户在自己的程序中用#include命令包含了有关的头文件就相当于在本程序中声明了所需要用到的类。可以换 —种说法：头文件是程序与类库的接口，输入和输出流类库的接口分别由不同的头文件来实现。 iostream 包含了对标准输入输出流进行操作所需的基本信息。 fstream 用于文件流I/O。 strstream 用于字符串流I/O。 iomanip 在使用格式化I/O时应包含此头文件。 stdiostream 用于混合使用C和C + +的I/O机制时，例如想将C程序转变为C++程序。 在iostream头文件中定义的流对象 在 iostream 头文件中定义的类有: ios，istream，ostream，iostream，istream 等。 在iostream头文件中不仅定义了有关的类，还定义了4种流对象， 对象 含义 对应设备 对应的类 c语言中相应的标准文件 cin 标准输入流 键盘 istream_withassign stdin cout 标准输出流 屏幕 ostream_withassign stdout cerr 标准错误流 屏幕 ostream_withassign stderr clog 标准错误流 屏幕 ostream_withassign stderr 在iostream头文件中定义cout流对象： ostream cout (stdout); //定义了cout流对象 在定义cout为ostream流类对象时，把标准输出设备stdout作为参数，这样它就与标准输出设备(显示器)联系起来，如果有 cout 就会在显示器的屏幕上输出3。 在iostream头文件中重载>运算符 在iostream头文件中对>进行了重载， 使它们能用作标准类型数据的输入和输出运算符。所以，在用它们的程序中必须用#include命令把iostream包含到程序中。 #include >> a; //将数据放入a对象中 cin >> a; 标准I/O流 标准I/O对象：cin，cout，cerr，clog cin流对象 cout流对象 cout是console output的缩写，意为在控制台（终端显示器）的输出。强调几点。 cout不是C++预定义的关键字，它是ostream流类的对象，在iostream中定义，并不是一个运算符。 顾 名思义，流是流动的数据，cout流是流向显示器的数据。cout流中的数据是用流插入 运算符“ 用“cout cout流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向cout流插人一个endl时，不论缓冲区是否已满，都立即输出流中所有数据，然后插入一个换行符， 并刷新流（清空缓冲区）。注意如果插人一个换行符”\\n“（如cout 在iostream中只对\">\"运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。如果用户声明了新的类型，并希望用\">\"运算符对其进行输入输出，按照重运算符重载来做。 cerr流对象 cerr流对象是标准错误流，cerr流已被指定为与显示器关联。cerr的作用是向标准错误设备(standard error device)输出有关出错信息。cerr与标准输出流cout的作用和用法差不多。但有一点不同：cout流通常是传送到显示器输出，但也可以被重定向输出到磁盘文件，而cerr流中的信息只能直接在显示器输出，cerr是不经过缓冲区，直接向显示器上输出有关信息。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时应该用cerr。cerr流中的信息是用户根据需要指定的。 clog流对象 clog流对象也是标准错误流，它是console log的缩写。它的作用和cerr相同，都是在终端显示器上显示出错信息。区别：cerr是不经过缓冲区，直接向显示器上输出有关信息，而clog中的信息存放在缓冲区中，缓冲区满后或遇endl时向显示器输出。 标准输入流 标准输入流对象cin，重点掌握的函数 cin.get() // 读取一个字符 char ch = cin.get(); //一次只能读取一个字符 cin.get(ch); //读一个字符赋给变量ch char buf[1024] = { 0 }; cin.get(buf.1024); //读字符串到buf cin.getline() // 读入一行字符 char buf[1024] = { 0 }; cin.getline(buf,1024); cin.ignore(n) // 忽略缓冲区当前n个字符 char buf[1024] = { 0 }; cin.ignore(2); //忽略缓冲区当前字符 cin.get(buf,1024); cout cin.putback() // 将数据放回缓冲区 //从缓冲区取走一个字符 char ch = cin.get(); cout cin.peek() // 偷窥下缓冲区的数据 char ch = cin.peek(); cout 标准输出流 字符输出 cout.flush() //刷新缓冲区 Linux下有效 //刷新缓冲区 cout.flush(); cout.put() // 向缓冲区写字符 cout.put('a'); cout.write() //从buffer中写num个字节到当前输出流中。 char* str = \"hello world!\"; cout.write(str, strlen(str)); 格式化输出 在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式输出一个整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。 1）使用控制符的方法； 2）使用流对象的有关成员函数。 控制符格式化输出 C++提供了在输入输出流中使用的控制符。 //使用控制符 void test02(){ int number = 99; cout 使用流对象的有关成员函数 通过调用流对象cout中用于控制输出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数如下： 流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标志时要在前面加上类名ios和域运算符“::”。格式标志见表13.5。 //通过流成员函数 void test01(){ int number = 99; cout.width(20); cout.fill('*'); cout.setf(ios::left); cout.unsetf(ios::dec); //卸载十进制 cout.setf(ios::hex); cout.setf(ios::showbase); cout.unsetf(ios::hex); cout.setf(ios::oct); cout 文件读写 文件流类和文件流对象 输入输出是以系统指定的标准设备（输入设备为键盘，输出设备为显示器）为对象的。在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。 和文件有关系的输入输出类主要在fstream.h这个头文件中被定义，在这个头文件中主要被定义了三个类，由这三个类控制对文件的各种输入输出操作，他们分别是ifstream、ofstream、fstream，其中fstream类是由iostream类派生而来，他们之间的继承关系见下图所示： 由于文件设备并不像显示器屏幕与键盘那样是标准默认设备，所以它在fstream头文件中是没有像cout那样预先定义的全局对象，所以我们必须自己定义一个该类的对象。ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。 fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。 C++打开文件 所谓打开(open)文件是一种形象的说法，如同打开房门就可以进入房间活动一样。 打开文件是指在文件读写之前做必要的准备工作，包括： 1）为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘文件。 2）指定文件的工作方式，如：该文件是作为输入文件还是输出文件，是ASCII文件还是二进制文件等。 以上工作可以通过两种不同的方法实现: 1) 调用文件流的成员函数open。如 ofstream outfile; //定义ofstream类(输出文件流类)对象outfile outfile.open(\"f1.dat\",ios::out); //使文件流与f1.dat文件建立关联 第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出文件， 文件流对象outfile将向磁盘文件f1.dat输出数据。ios::out是I/O模式的一种，表示 以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文件，接收从内存 输出的数据。 磁盘文件名可以包括路径，如\"c:\\\\new\\\\f1.dat\"，如缺省路径，则默认为当前目录下的文件。 2) 在定义文件流对象时指定参数 在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件的功能。因此， 可以在定义文件流对象时指定参数，调用文件流类的构造函数来实现打开文件的功能。 几点说明： 1) 新版本的I/O类库中不提供ios::nocreate和ios::noreplace。 2) 每一个打开的文件都有一个文件指针，该指针的初始位置由I/O方式指定，每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字节。当文件指针移到最后，就会遇到文件结束EOF（文件结束符也占一个字节，其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结束 了。 3) 可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行所示那样。还可以举出下面一些例子： ios::in | ios:: noreplace //打开一个输入文件，若文件不存在则返回打开失败的信息 ios::app | ios::nocreate //打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息 ios::out l ios::noreplace //打开一个新文件作为输出文件，如果文件已存在则返回打开失败的信息 ios::in l ios::out I ios::binary //打开一个二进制文件，可读可写 但不能组合互相排斥的方式，如 ios::nocreate l ios::noreplace。 4) 如果打开操作失败，open函数的返回值为0(假)，如果是用调用构造函数的方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如\\ if(outfile.open(\"f1.bat\", ios::app) ==0) cout C++关闭文件 在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用成员函数close。 outfile.close( ); //将输出文件流所关联的磁盘文件关闭 所谓关闭，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也失效，这样，就不能再通过文件流对该文件进行输入或输出。 C++对ASCII文件的读写操作 如果文件的每一个字节中均以ASCII代码形式存放数据,即一个字节存放一个字符,这个文件就是ASCII文件(或称字符文件)。程序可以从ASCII文件中读入若干个字符,也可以向它输出一些字符。 1) 用流插入运算符“>”对磁盘文件读写。 在对磁盘文件的操作中，可以通过文件流对象和流插入运算符“>”实现对磁盘 文件的读写，如同用cin、cout和>对标准设备进行读写一样。 2) 用文件流的put、get、geiline等成员函数进行字符的输入输出。 用C++流成员函数put输出单个字符、C++ get()函数读入一个字符和C++ getline()函数读入一行字符。 char* sourceFileName = \"./source.txt\"; char* targetFileName = \"./target.txt\"; //创建文件输入流对象 ifstream ism(sourceFileName, ios::in); //创建文件输出流对象 ofstream osm(targetFileName,ios::out); if (!ism){ cout C++对二进制文件的读写操作 二进制文件不是以ASCII代码存放数据的，它将内存中数据存储形式不加转换地传送到磁盘文件，因此它又称为内存数据的映像文件。因为文件中的信息不是字符数据，而是字节中的二进制形式的信息，因此它又称为字节文件。 对二进制文件的操作也需要先打开文件，用完后要关闭文件。在打开时要用ios::binary指定为以二进制形式传送和存储。二进制文件除了可以作为输入文件或输出文件外,还可以是既能输入又能输出的文件。这是和ASCII文件不同的地方。 用成员函数read和write读写二进制文件 对二进制文件的读写主要用istream类的成员函数read和write来实现。这两个成员函数的原型为 istream& read(char buffer,int len); ostream& write(const char buffer,int len); 字符指针buffer指向内存中一段存储空间。len是读写的字节数。调用的方式为： a. write(p1,50); b. read(p2,30); 上面第一行中的a是输出文件流对象，write函数将字符指针p1所给出的地址开始的50个字节的内容不加转换地写到磁盘文件中。在第二行中，b是输入文件流对象，read 函数从b所关联的磁盘文件中，读入30个字节(或遇EOF结束），存放在字符指针p2所指的一段空间内。 //对象写入文件 char* fileName = \"person.txt\"; //创建文件对象输出流,二进制模式读写文件 ofstream osm(fileName, ios::out | ios::binary); Person p1(\"John\",33); //Person对象写入文件 osm.write((const char*)&p1,sizeof(Person)); //关闭文件输出流 osm.close(); //从文件中读取对象 //创建文件对象输入流,,二进制模式读写文件 ifstream ism(fileName, ios::in | ios::binary); Person p3; //文件读入Person对象 ism.read((char*)&p3, sizeof(Person)); //关闭文件输入流 ism.close(); Python和C++比较 C++和Python都是面向对象的高级程序设计语言 C++是一门编译型语言，源程序经过预处理、编译和链接之后生成可执行文件 Python是一门解释型语言，Python解释器先把源代码转换成字节码文件，再由Python虚拟机一条一条地执行字节码指令 C++是一种强类型语言，每个变量的类型都需要事先声明 Python是一种动态类型语言，变量不需要声明即可直接赋值，变量名没有类型，类型属于对象，变量可以重新赋值为任意值 C++在堆区动态开辟内存时，需要手动开辟手动释放 Python依靠引用计数机制进行自动内存管理 C++支持多线程并发执行 Python的多线程不能利用多核CPU资源(c++解释器) C++有指针 Python没有指针 C++在类外对私有成员的访问是绝对禁止的 Python只是对私有成员的名称做了修饰 C++11 C++11新特性，所有知识点都在这了！ "},"c++/c++11.html":{"url":"c++/c++11.html","title":"C++11","keywords":"","body":"C++11auto 变量类型推导decltype 表达式类型推导左值右值列表初始化std::function对象std::bindlambda表达式模板的改进并发智能指针for遍历容器委托构造函数继承构造函数nullptrfinaloverridedefaultdeleteexplicitconstconstexprenum class非受限联合体sizeof(类属性)assertion自定义字面量内存对齐thread_local 变量基础数值类型随机数功能正则表达式chrono 时间新增数据结构新增算法referenceC++11 auto 变量类型推导 变量/表达式类型推导，C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。 auto：让编译器在编译期就推导出变量的类型，可以通过=右边的类型推导出变量的类型。 auto a = 10; // 10是int型，可以自动推导出a是int decltype 表达式类型推导 decltype：相对于auto用于推导变量类型，而decltype则用于让编译器在编译期就推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。 cont int &i = 1; int a = 2; decltype(i) b = 2; // b是const int& 关于auto和decltype的详细介绍请看：一文吃透C++11中auto和decltype知识点 左值右值 众所周知C++11新增了右值引用，这里涉及到很多概念： 左值：可以取地址并且有名字的东西就是左值。 右值：不能取地址的没有名字的东西就是右值。 纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。 将亡值：可以理解为即将要销毁的值。 左值引用：对左值进行引用的类型。 右值引用：对右值进行引用的类型。 移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。 完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。 返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。 这里的详细介绍请看：左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里 列表初始化 在C++11中可以直接在变量名后面加上初始化列表来进行对象的初始化，详细介绍一定要看这篇文章：学会C++11列表初始化 std::function对象 类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。 通常std::function是一个函数对象类，它包装其它任意的函数对象，被包装的函数对象具有类型为T1, …,TN的N个参数，并且返回一个可转换到R类型的值。std::function使用 模板转换构造函数接收被包装的函数对象；特别是，闭包类型可以隐式地转换为std::function。 最简单的理解就是： 通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象；让我们不再纠结那么多的可调用实体。 //代码出自链接：http://www.jellythink.com/archives/771 #include #include using namespace std; // 普通函数 int TestFunc(int a) { return a; } // Lambda表达式 auto lambda = [](int a) -> int { return a; }; // 仿函数(functor) class Functor { public: int operator()(int a) { return a; } }; // 1.类成员函数 // 2.类静态函数 class TestClass { public: int ClassMember(int a) { return a; } static int StaticMember(int a) { return a; } }; // function对象 std::function Functional; int main() { // 普通函数 Functional = TestFunc; int result = Functional(10); cout 注意的事项： 关于可调用实体转换为std::function对象需要遵守以下两条原则： 转换后的std::function对象的参数能转换为可调用实体的参数； 可调用实体的返回值能转换为std::function对象的返回值。 std::function对象最大的用处就是在实现函数回调（实际工作中就是用到了这一点），使用者需要注意，它不能被用来检查相等或者不相等，但是可以与NULL或者nullptr进行比较。 为什么要用std::function std::function实现了一套类型消除机制，可以统一处理不同的函数对象类型。以前我们使用函数指针来完成这些；现在我们可以使用更安全的std::function来完成这些任务。 std::bind lambda表达式 c++11新增了std::function、std::bind、lambda表达式等封装使函数调用更加方便，详细介绍请看：搞定c++11新特性std::function和lambda表达式 模板的改进 C++11关于模板有一些细节的改进： 模板的右尖括号 模板的别名 函数模板的默认模板参数 详细介绍请看：C++11的模板改进 并发 c++11关于并发引入了好多好东西，有： std::thread相关 std::mutex相关 std::lock相关 std::atomic相关 std::call_once相关 volatile相关 std::condition_variable相关 std::future相关 async相关 详细介绍请看：c++11新特性之线程相关所有知识点 这里也使用c++11来实现的线程池和定时器，可以看： C++线程池的实现之格式修订版 C++定时器的实现之格式修订版 智能指针 很多人谈到c++，说它特别难，可能有一部分就是因为c++的内存管理吧，不像java那样有虚拟机动态的管理内存，在程序运行过程中可能就会出现内存泄漏，然而这种问题其实都可以通过c++11引入的智能指针来解决，相反我还认为这种内存管理还是c++语言的优势，因为尽在掌握。 c++11引入了三种智能指针： std::unique_ptr std::shared_ptr std::weak_ptr 详细介绍请看：c++11新特性之智能指针 for遍历容器 // c++11之前，迭代器遍历 for (auto iter = vec.begin(); iter != vec.end(); iter++) { cout // c++11基于范围的for循环 for (int i : vec) { cout 委托构造函数 委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作，（类似初始化表里调用构造函数？） class A { A(int a) { a = a; } ==A(int a, int b) : A(a)=={ b = b; } } 不使用委托构造函数： class A { A(){} A(int a) { a_ = a; } A(int a, int b) { // 好麻烦 a_ = a; b_ = b; } A(int a, int b, int c) { // 好麻烦 a_ = a; b_ = b; c_ = c; } int a_; int b_; int c_; }; 使用委托构造函数： class A { A(){} A(int a) { a_ = a; } // 委托构造 A(int a, int b) : A(a) { b_ = b; } // 委托构造 A(int a, int b, int c) : A(a, b) { c_ = c; } int a_; int b_; int c_; }; 初始化变量是不是方便了许多。 继承构造函数 继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数。 只需要使用using Base::Base继承构造函数，就免去了很多重写代码的麻烦。 class Derived : Base { ==using Base::Base;== //子类继承构造函数 }; 不使用继承构造函数： struct Base { Base() {} Base(int a) { a_ = a; } Base(int a, int b) : Base(a) { b_ = b; } Base(int a, int b, int c) : Base(a, b) { c_ = c; } int a_; int b_; int c_; }; struct Derived : Base { Derived() {} Derived(int a) : Base(a) {} // 好麻烦 Derived(int a, int b) : Base(a, b) {} // 好麻烦 Derived(int a, int b, int c) : Base(a, b, c) {} // 好麻烦 }; int main() { Derived a(1, 2, 3); return 0; } 使用继承构造函数： struct Base { Base() {} Base(int a) { a_ = a; } Base(int a, int b) : Base(a) { b_ = b; } Base(int a, int b, int c) : Base(a, b) { c_ = c; } int a_; int b_; int c_; }; struct Derived : Base { using Base::Base; }; int main() { Derived a(1, 2, 3); return 0; } nullptr nullptr是c++11用来表示空指针，新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。 void func(void *ptr) { cout final c++11关于继承新增关键字，final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载 final用于修饰一个类 class Base ==final== {}; struct Base final { virtual void func() { cout override c++11关于继承新增关键字，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。 override修饰派生类中的成员函数 void mfunc() ==override== { …} struct Base { virtual void func() { // 虚函数 cout default c++11引入default特性，default生成默认能自动生成的特殊成员函数。 多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，如下代码： struct A { A(int i) { a = i; } int a; }; int main() { A a; // 编译出错 return 0; } 上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而通过default，程序员只需在函数声明后加上“=default;”，就可将该函数声明为 default 函数，编译器将为显式声明的 default 函数自动生成函数体，显式生成默认构造函数，如下： struct A { A() = default; //显式声明自动生成默认构造函数 A(int i) { a = i; } int a; }; int main() { A a; // ok return 0; } delete delete 禁用默认能自动生成的特殊成员函数。 c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，如下代码： struct A { A() = default; int a; A(int i) { a = i; } }; int main() { A a1; A a2 = a1; // 正确，调用编译器隐式生成的默认拷贝构造函数 A a3; a3 = a1; // 正确，调用编译器隐式生成的默认拷贝赋值操作符 } 而我们有时候想禁止对象的拷贝与赋值，可以使用delete修饰，如下： struct A { A() = default; A(const A&) = delete; A& operator=(const A&) = delete; int a; A(int i) { a = i; } }; int main() { A a1; A a2 = a1; // 错误，拷贝构造函数被禁用 A a3; a3 = a1; // 错误，拷贝赋值操作符被禁用 } delele函数在c++11中很常用，std::unique_ptr就是通过delete修饰来禁止对象的拷贝的。 explicit explicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换 不用explicit： struct A { A(int value) { // 没有explicit关键字 cout 使用explicit: struct A { explicit A(int value) { // explicit关键字 cout const 因为要讲后面的constexpr，所以这里简单介绍下const。 const字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。 主要用法如下： 常变量，用于定义常量，const的修饰的变量不可更改。 const int value = 5; 指针常量——指针类型的常量（int const p） 指针也可以使用const，这里有个小技巧，从右向左读，即可知道const究竟修饰的是指针还是指针所指向的内容。指针常量和常量指针 本质上一个常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。在指针常量中，指针自身的值是一个常量，不可改变，始终*指向同一个地址，但地址内容可以修改，在定义的同时必须初始化。用法如下： int a = 10, b = 20; int * const p = &a; // 指针本身是常量 *p = 30; // p指向的地址是一定的，但其内容可以修改 常量指针——指向“常量”的指针（const int p， int const p） 常量指针本质上是一个指针，常量表示指针指向的内容，说明该指针指向一个“常量”。在常量指针中，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。用法如下： int a = 10, b = 20; const int *p = &a; // 指针指向的变量为常量 p = &b; // 指针可以指向其他地址，但是内容不可以改变 常引用，在函数参数中使用const，一般会传递类对象时会传递一个const的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。 class A{};void func(const A& a); 常成员变量，const修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。 class A { const int m_value = 5; // 直接赋值 }; class B { B(int v) : m_value(v){} //初始化表赋值 const int m_value; }; 常成员函数，修饰类成员函数，表示在该函数内不可以修改该类的成员变量。 class A{ void func() const; }; 常对象，修饰类对象，类对象只能调用该对象的const成员函数。 class A { void func() const; }; const A a; a.func(); constexpr constexpr是c++11新引入的关键字，用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别： 两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而 constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码： #include using namespace std; constexpr int func(int i) { return i + 1; } int main() { int i = 2; func(i);// 普通函数 func(2);// 编译期间就会被计算出来 } enum class c++11新增有作用域的枚举类型，看代码 不带作用域的枚举代码： enum AColor { kRed, // 0 kGreen, kBlue }; enum BColor { kWhite, // 0 kBlack, kYellow }; int main() { if (kRed == kWhite) { // cout 如上代码，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的bug，而这种完全可以通过有作用域的枚举来规避。 有作用域的枚举代码： enum class AColor { kRed, kGreen, kBlue }; enum class BColor { kWhite, kBlack, kYellow }; int main() { if (AColor::kRed == BColor::kWhite) { // 编译失败 cout 使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug， 同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。 enum class AColor : char { kRed, kGreen, kBlue }; 我们平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。 非受限联合体 c++11之前union中数据成员的类型不允许有非POD类型，而这个限制在c++11被取消，允许数据成员类型有非POD类型，看代码： struct A { int a; int *b; }; union U { A a; // 非POD类型 c++11之前不可以这样定义联合体 int b; }; 对于什么是POD类型，大体上可以理解为对象可以直接memcpy的类型。 sizeof(类属性) c++11中sizeof可以用的类的数据成员上，看代码： sizeof(==A::m_data==) c++11前： struct A { int m_data[10]; int a; }; int main() { A a; cout c++11后： struct A { int m_data[10]; int a; }; int main() { cout 想知道类中数据成员的大小在c++11中是不是方便了许多，而不需要定义一个对象，在计算对象的成员大小。 assertion c++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。 static_assert(true/false, message); static_assert(true message); // ok，没有输出 static_assert(false, message); // 报错，打印信息 自定义字面量 c++11可以自定义字面量，我们平时c++中都或多或少使用过chrono中的时间，例如： std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 100ms std::this_thread::sleep_for(std::chrono::seconds(100)); // 100s 其实没必要这么麻烦，也可以这么写： std::this_thread::sleep_for(100ms); // c++14里可以这么使用，这里只是举个自定义字面量使用的例子 std::this_thread::sleep_for(100s); 这就是自定义字面量的使用，示例如下： struct mytype { unsigned long long value; }; constexpr mytype operator\"\" _mytype ( unsigned long long n ) { return mytype{n}; } mytype mm = 123_mytype; cout 关于自定义字面量，可以看下chrono的源代码。 内存对齐 什么是内存对齐 理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数N的倍数，这就是内存对齐。 为什么要内存对齐 硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。 提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。 在c++11之前如果想创建内存对齐需要： void align_cpp11_before() { static char data[sizeof(void *) + sizeof(A)]; const uintptr_t kAlign = sizeof(void *) - 1; char *align_ptr = reinterpret_cast(reinterpret_cast(data + kAlign) & ~kAlign); A *attr = new (align_ptr) A; } c++11关于内存对齐新增了一些函数： void align_cpp11_after() { static std::aligned_storage::type data; A *attr = new (&data) A; } 还有：alignof()、std::alignment_of()、alignas()，关于内存对齐详情可以看这篇文章：内存对齐之格式修订版 thread_local 变量 c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。 对于一个线程私有(局部)变量，一个线程拥有且只拥有一个该实例，类似于static，但仅限于当前线程。 #include #include class A { public: A() { } void test(const std::string &name) { //! thread_local 每一个线程都拥有并只拥有一个该变量的独立实例 thread_local int thLoc_count = 0; // 1 2 3 4 1 2 3 4 // static int thLoc_count = 0; // 1 2 3 4 5 6 7 8 // int thLoc_count = 0; // 1 1 1 1 1 1 1 1 ++thLoc_count; std::cout 输出： thread1_a1: 1 thread1_a1: 2 .... thread1_a2: 3 thread1_a2: 4 ----------- thread2_a1: 1 thread2_a1: 2 .... thread2_a2: 3 thread2_a2: 4 验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于static。 基础数值类型 c++11新增了几种数据类型：long long、char16_t、char32_t等 随机数功能 c++11关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，先看如下代码： #include #include #include using namespace std; int main() { std::default_random_engine random(time(nullptr)); std::uniform_int_distribution int_dis(0, 100); // 整数均匀分布 std::uniform_real_distribution real_dis(0.0, 1.0); // 浮点数均匀分布 for (int i = 0; i 输出： 38 100 93 7 66 0 68 99 41 7 0.232202 0.617716 0.959241 0.970859 0.230406 0.430682 0.477359 0.971858 0.0171148 0.64863 代码中举例的是整数均匀分布和浮点数均匀分布，c++11提供的概率分布类型还有好多，例如伯努利分布、正态分布等，具体可以见最后的参考资料。 正则表达式 c++11引入了regex库更好的支持正则表达式，见代码： #include #include #include #include int main() { std::string s = \"I know, I'll use2 regular expressions.\"; // 忽略大小写 std::regex self_regex(\"REGULAR EXPRESSIONS\", std::regex_constants::icase); if (std::regex_search(s, self_regex)) { std::cout N) { std::cout chrono 时间 c++11关于时间引入了chrono库，源于boost，功能强大，chrono主要有三个点： duration time_point clocks duration std::chrono::duration表示一段时间，常见的单位有s、ms等，示例代码： // 拿休眠一段时间举例，这里表示休眠100ms std::this_thread::sleep_for(std::chrono::milliseconds(100)); sleep_for里面其实就是std::chrono::duration，表示一段时间，实际是这样： typedef duration milliseconds; typedef duration seconds; duration具体模板如下： 1 template > class duration; Rep表示一种数值类型，用来表示Period的数量，比如int、float、double，Period是ratio类型，用来表示【用秒表示的时间单位】比如second，常用的duration已经定义好了，在std::chrono::duration下： ratio：hours ratio：minutes ratio：seconds ratio：milliseconds ratio：microseconds ratio：nanosecons ratio的具体模板如下： template class ratio; N代表分子，D代表分母，所以ratio表示一个分数，我们可以自定义Period，比如ratio表示单位时间是2秒。 time_point 表示一个具体时间点，如2020年5月10日10点10分10秒，拿获取当前时间举例： std::chrono::time_point Now() { return std::chrono::high_resolution_clock::now();} // std::chrono::high_resolution_clock为高精度时钟，下面会提到 三种时钟 时钟，chrono里面提供了三种时钟： steady_clock system_clock high_resolution_clock steady_clock 稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用now()肯定比前一次调用now()的数值大，可用于计时。 system_clock 表示当前的系统时钟，可以用于获取当前时间： int main() { using std::chrono::system_clock; system_clock::time_point today = system_clock::now(); std::time_t tt = system_clock::to_time_t(today); std::cout high_resolution_clock high_resolution_clock表示系统可用的最高精度的时钟，实际上就是system_clock或者steady_clock其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样，之前看gcc chrono源码中high_resolution_clock是steady_clock的typedef。 更多关于chrono的介绍可以看下：RAII妙用之计算函数耗时 新增数据结构 std::unordered_set：基于hash表实现的set，内部不会排序，使用方法和set类似 std::unordered_map：基于hash表实现的map，内部不会排序，使用方法和set类似 std::array：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组 std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存，提高了性能 std::forward_list fl = {1, 2, 3, 4, 5}; for (const auto &elem : fl) { cout std::tuple：元组类型，类似pair，但比pair扩展性好 std::tuple tp(0, 1, 2, 3); // 元组 cout (tp); cout (tp); cout (tp); cout (tp); 新增算法 all_of：检测表达式是否对范围[first, last)中所有元素都返回true，如果全部都满足，则返回true std::vector v(10, 2); bool ret = std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; }); if (ret) { std::cout any_of：检测表达式是否对范围[first, last)中至少一个元素返回true，如果满足，则返回true，否则返回false，用法和上面一样 none_of：检测表达式是否对范围[first, last)中所有元素都不返回true，如果都不满足，则返回true，否则返回false，用法和上面一样 find_if_not：找到第一个不符合要求的元素迭代器，和find_if相反 copy_if：复制满足条件的元素 itoa：对容器内的元素按序递增 std::vector l(10); std::iota(l.begin(), l.end(), 19); // 19为初始值 for (auto n : l) std::cout min_element,max_element：返回容器内最大元素和最小元素位置 int main() { std::vector v = {3, 9, 1, 4, 2, 5, 9}; auto result = std::minmax_element(v.begin(), v.end()); std::cout is_sorted、is_sorted_until：返回容器内元素是否已经排好序。 reference C++11新特性，所有知识点都在这了！ https://zh.cppreference.com/w/cpp/language/range-for https://juejin.im/post/5dcaa857e51d457f7675360b https://zhuanlan.zhihu.com/p/21930436 https://zh.wikipedia.org/wiki/Nullptr https://zh.wikipedia.org/wiki/Constexpr https://zh.cppreference.com/w/cpp/language/enum https://kheresy.wordpress.com/2019/03/27/using-enum-class/ https://zh.cppreference.com/w/cpp/language/union http://c.biancheng.net/view/7165.html https://zhuanlan.zhihu.com/p/77585472 http://www.cplusplus.com/reference/random/ https://zh.cppreference.com/w/cpp/regex https://www.cnblogs.com/jwk000/p/3560086.html https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of "},"c++/stl.html":{"url":"c++/stl.html","title":"STL","keywords":"","body":"STL(标准模板库)1. STL概论1.1 STL基本概念1.2 STL六大组件简介1.3 STL优点2. STL常用三大组件2.1 容器2.2 算法2.3 迭代器3. 常用容器3.1 string容器string容器基本概念string容器常用操作3.2 vector容器vector容器基本概念vector迭代器vector的数据结构vector容器常用操作vector小案例3.3 deque容器deque容器基本概念deque容器实现原理deque常用API3.4 stack容器stack容器基本概念stack没有迭代器stack常用API3.5 queue容器queue容器基本概念queue没有迭代器queue常用API3.6 list容器list容器基本概念list容器的迭代器list常用API3.7 set/multiset容器set/multiset容器基本概念set常用API3.8 map/multimap容器map/multimap基本概念map/multimap常用API3.9 STL容器比较4. 常用算法4.2 算法概述4.3 常用遍历算法4.4 常用查找算法4.5 常用排序算法4.6 常用拷贝和替换算法4.7 常用算数生成算法4.8 常用集合算法其他4.1 函数对象4.2 谓词4.3 STL内建函数对象函数对象适配器STL(标准模板库) 1. STL概论 长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法,让程序员的心血不止于随时间的迁移，人事异动而烟消云散，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。 复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。 为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。 1.1 STL基本概念 STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator),容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上。 1.2 STL六大组件简介 STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种类模板class template。 算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种函数模板function tempalte。 迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> , operator++,operator--等指针相关操作予以重载的类模板class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。 仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的类模板class tempalte。 STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。 1.3 STL优点 STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。 STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作。 程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。 STL 具有高可重用性，高性能，高移植性，跨平台的优点。 **高可重用性**：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。 **高性能**：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。 **高移植性**：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。 2. STL常用三大组件 2.1 容器 容器，置物之所也。 研究数据的特定排列方式，以利于搜索或排序或其他特殊目的，这一门学科我们称为数据结构。 几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。 常用的==数据结构==：数组(array)，链表(list)，tree(树)，栈(stack)，队列(queue)，集合(set)，映射表(map),根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。 ==序列式容器==强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。 ==关联式容器==是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器。 2.2 算法 算法，问题之解法也。 以有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)。 广义而言，我们所编写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都是用来解决或大或小的逻辑问题或数学问题。STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。 算法分为：质变算法和非质变算法。 质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等 2.3 迭代器 迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。在《Design Patterns》一书中提供了23中设计模式的完整描述，其中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。 迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。 迭代器的种类: 输入迭代器 提供对数据的只读访问 只读，支持++、==、！= 输出迭代器 提供对数据的只写访问 只写，支持++ 前向迭代器 提供读写操作，并能向前推进迭代器 读写，支持++、==、！= 双向迭代器 提供读写操作，并能向前和向后操作 读写，支持++、--， 随机访问迭代器 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器 读写，支持++、--、[n]、-n、、>= 3. 常用容器 3.1 string容器 string容器基本概念 C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件。 String和c风格字符串对比： char*是一个指针，string是一个类 string封装了char*，管理这个字符串，是一个char*型的容器。 string封装了很多实用的成员方法 查找find，拷贝copy，删除delete 替换replace，插入insert 不用考虑内存释放和越界 string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。 string容器常用操作 string 构造函数 string();//创建一个空的字符串 例如: string str; string(const string& str);//使用一个string对象初始化另一个string对象 string(const char* s);//使用字符串s初始化 string(int n, char c);//使用n个字符c初始化 assign =赋值操作 string& operator=(const char* s);//char*类型字符串 赋值给当前的字符串 string& operator=(const string &s);//把字符串s赋给当前的字符串 string& operator=(char c);//字符赋值给当前的字符串 string& assign(const char *s);//把字符串s赋给当前的字符串 string& assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串 string& assign(const string &s);//把字符串s赋给当前字符串 string& assign(int n, char c);//用n个字符c赋给当前字符串 string& assign(const string &s, int start, int n);//将s从start开始n个字符赋值给字符串 at []存取字符操作 char& operator[](int n);//通过[]方式取字符 char& at(int n);//通过at方法获取字符 append +拼接操作 string& operator+=(const string& str);//重载+=操作符 string& operator+=(const char* str);//重载+=操作符 string& operator+=(const char c);//重载+=操作符 string& append(const char *s);//把字符串s连接到当前字符串结尾 string& append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾 string& append(const string &s);//同operator+=() string& append(const string &s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾 string& append(int n, char c);//在当前字符串结尾添加n个字符c find rfind查找 int find(const string& str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 int rfind(const string& str, int pos = npos) const;//查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 replace替换 string& replace(int pos, int n, const string& str); //替换从pos开始n个字符为字符串str string& replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s compare比较操作 /* compare函数在>时返回 1，substr子串 string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串 insert插入操作 string& insert(int pos, const char* s); //插入字符串 string& insert(int pos, const string& str); //插入字符串 string& insert(int pos, int n, char c);//在指定位置插入n个字符c string& erase(int pos, int n = npos);//删除从Pos开始的n个字符 erase删除操作 string& erase(int pos, int n = npos);//删除从Pos开始的n个字符 string和c-style字符串转换 //string 转 char* string str = \"itcast\"; const char* cstr = str.c_str(); // .c_str() //char* 转 string char* s = \"itcast\"; string str(s); // 构造时转换 提示: 在c++中存在一个从const char到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string。 通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char时才将其转换为C_string。 提示:?? 为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误。 string s = \"abcdefg\"; char &a = s[1]; char &b = s[2]; a = '1'; b = '2'; cout 3.2 vector容器 vector容器基本概念 vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。 Vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间(不论多大)，一如刚所说，是”配置新空间-数据移动-释放旧空间”的大工程,时间成本很高，应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。 vector迭代器 Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*, operator->, operator++, operator--, operator+, operator-, operator+=, operator-=, 普通指针天生具备。Vector支持随机存取，而普通指针正有着这样的能力。所以vector提供的是随机访问迭代器(Random Access Iterators)。 根据上述描述，如果我们写如下的代码： Vector::iterator it1; // it1的型别其实就是Int* Vector::iterator it2; // it2的型别其实就是Teacher* vector v; for (int i = 0; i vector的数据结构 Vector所采用的数据结构非常简单，线性连续空间，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。 为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是容量的概念。换句话说，一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得重新分配空间。 注意： 所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。这是程序员容易犯的一个错误，务必小心。 vector容器常用操作 vector构造函数 vector v; //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem);//构造函数将n个elem拷贝给本身。 vector(const vector &vec);//拷贝构造函数。 //例子 使用第二个构造函数 我们可以... int arr[] = {2,3,4,1,9}; vector v1(arr, arr + sizeof(arr) / sizeof(int)); vector赋值操作 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 vector& operator=(const vector &vec); //重载等号操作符 swap(vec); // 将vec与本身的元素互换。 vector大小操作 size();//返回容器中元素的个数 empty();//判断容器是否为空 resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长>度的元素被删除。 capacity();//容器的容量 reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 vector数据存取操作 at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。 operator[]; //返回索引idx所指的数据，越界时，运行直接报错 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 vector插入和删除操作 insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele. push_back(ele); //尾部插入元素ele pop_back();//删除最后一个元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 erase(const_iterator pos);//删除迭代器指向的元素 clear();//删除容器中所有元素 // vector容器在其头部操作效率奇差，无法被接受。 vector小案例 swap收缩内存空间 reserve预留空间 3.3 deque容器 deque容器基本概念 Vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。 Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能. 虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque。 deque容器实现原理 Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。 Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。 既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。 Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。 deque常用API deque构造函数 deque deqT;//默认构造形式 deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem);//构造函数将n个elem拷贝给本身。 deque(const deque &deq);//拷贝构造函数。 deque赋值操作 assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem);//将n个elem拷贝赋值给本身。 deque& operator=(const deque &deq); //重载等号操作符 swap(deq);// 将deq与本身的元素互换 deque大小操作 deque.size();//返回容器中元素的个数 deque.empty();//判断容器是否为空 deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。 deque双端插入和删除操作 push_back(elem);//在容器尾部添加一个数据 push_front(elem);//在容器头部插入一个数据 pop_back();//删除容器最后一个数据 pop_front();//删除容器第一个数据 deque数据存取 at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。 operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。 front();//返回第一个数据。 back();//返回最后一个数据 deque插入操作 insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 deque删除操作 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 clear();//移除容器的所有数据 3.4 stack容器 stack容器基本概念 stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。 有元素推入栈的操作称为:push,将元素推出stack的操作称为pop. stack没有迭代器 Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。 stack常用API stack构造函数 stack stkT;//stack采用模板类实现， stack对象的默认构造形式： stack(const stack &stk);//拷贝构造函数 stack赋值操作 stack& operator=(const stack &stk);//重载等号操作符 stack读取 top();//返回栈顶元素 stack插入删除 push(elem);//向栈顶添加元素 pop();//从栈顶移除第一个元素 stack大小操作 empty();//判断堆栈是否为空 size();//返回堆栈的大小 3.5 queue容器 queue容器基本概念 Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。 queue没有迭代器 Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。q ueue不提供遍历功能，也不提供迭代器。 queue常用API queue构造函数 queue queT;//queue采用模板类实现，queue对象的默认构造形式： queue(const queue &que);//拷贝构造函数 queue数据读取 back();//返回最后一个元素 front();//返回第一个元素 queue插入和删除操作 push(elem);//往队尾添加元素 pop();//从队头移除第一个元素 queue赋值操作 queue& operator=(const queue &que);//重载等号操作符 queue大小操作 empty();//判断队列是否为空 size();//返回队列的大小 3.6 list容器 list容器基本概念 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。 List和vector是两个最常被使用的容器。 List容器是一个双向链表。 list容器不仅是一个双向链表，而且还是一个循环的双向链表。 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 链表灵活，但是空间和时间额外耗费较大 list容器的迭代器 List容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。 由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators. List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。 list常用API list构造函数 list lstT;//list采用采用模板类实现,对象的默认构造形式 list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem);//构造函数将n个elem拷贝给本身。 list(const list &lst);//拷贝构造函数。 list赋值操作 assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem);//将n个elem拷贝赋值给本身。 list& operator=(const list &lst);//重载等号操作符 swap(lst);//将lst与本身的元素互换。 list数据的存取 front();//返回第一个元素。 back();//返回最后一个元素。 list数据元素插入和删除 push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 clear();//移除容器的所有数据 list大小操作 size();//返回容器中元素的个数 empty();//判断容器是否为空 resize(num);//重新指定容器的长度为num， 若容器变长，则以默认值填充新位置。 如果容器变短，则末尾超出容器长度的元素被删除。 resize(num, elem);//重新指定容器的长度为num， 若容器变长，则以elem值填充新位置。 如果容器变短，则末尾超出容器长度的元素被删除。 list排序 sort(); //list排序 list反序 reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。 3.7 set/multiset容器 set/multiset容器基本概念 set容器基本概念 Set的特性是。所有元素都会根据元素的键值自动被排序。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。 不可以通过set的迭代器改变set元素的值，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator。 set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。 multiset容器基本概念 multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。 树的简单知识： 二叉树就是任何节点最多只允许有两个字节点。分别是左子结点和右子节点。 二叉搜索树，是指二叉树中的节点按照一定的规则进行排序，使得对二叉树中元素访问更加高效。二叉搜索树的放置规则是：任何节点的元素值一定大于其左子树中的每一个节点的元素值，并且小于其右子树的值。因此从根节点一直向左走，一直到无路可走，即得到最小值，一直向右走，直至无路可走，可得到最大值。那么在儿茶搜索树中找到最大元素和最小元素是非常简单的事情。下图为二叉搜索树： 上面我们介绍了二叉搜索树，那么当一个二叉搜索树的左子树和右子树不平衡的时候，那么搜索依据上图表示，搜索9所花费的时间要比搜索17所花费的时间要多，由于我们的输入或者经过我们插入或者删除操作，二叉树失去平衡，造成搜索效率降低。 所以我们有了一个平衡二叉树的概念，所谓的平衡不是指的完全平衡。 RB-tree(红黑树)为二叉树的一种。 set常用API set构造函数 set st;//set默认构造函数： mulitset mst; //multiset默认构造函数: set(const set &st);//拷贝构造函数 set赋值操作 set& operator=(const set &st);//重载等号操作符 swap(st);//交换两个集合容器 set大小操作 size();//返回容器中元素的数目 empty();//判断容器是否为空 set插入和删除操作 insert(elem);//在容器中插入元素。 clear();//清除所有元素 erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem);//删除容器中值为elem的元素。 set的插入insert返回值 set的返回值是对组pair，第一个是set迭代器，第二个是是否成功bool值。 set s; pair::iterator,bool> ret = s.insert(10); if (ret.second){ cout 指定set插入排序规则 set容器的第二个模板参数可以设置排序规则，默认规则是less // 指定排序规则 struct MyCompare02{ // 重载运算符() bool operator()(int v1,int v2){ return v1 > v2; } }; //set从大到小 void test02(){ //set容器的第二个模板参数可以设置排序规则，默认规则是less set s; for (int i = 0; i ::iterator it = s.begin(); it != s.end(); it ++){ cout set容器中存放对象，并指定排序规则 //set容器中存放对象 class Person{ public: Person(string name,int age){ this->mName = name; this->mAge = age; } public: string mName; int mAge; }; // 指定排序规则 struct MyCompare03{ bool operator()(const Person& p1,const Person& p2){ return p1.mAge > p2.mAge; } }; void test03(){ set s; Person p1(\"aaa\", 20); Person p2(\"bbb\", 30); Person p3(\"ccc\", 40); Person p4(\"ddd\", 50); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set::iterator it = s.begin(); it != s.end(); it++){ cout mName mAge set查找操作 find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key);//查找键key的元素个数 lower_bound(keyElem);//返回第一个key>=keyElem元素的迭代器。 upper_bound(keyElem);//返回第一个key>keyElem元素的迭代器。 equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 对组(pair) 对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。 类模板： template struct pair 创建对组 //第一种方法创建一个对组 pair pair1(string(\"name\"), 20); cout pair2 = make_pair(\"name\", 30); //pair=赋值 pair pair3 = pair2; 访问对组 pair1.first pair1.second 3.8 map/multimap容器 map/multimap基本概念 Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是对组pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。 不可以通过map的迭代器改变map的键值，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。 Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。 Multimap和map的操作类似，唯一区别multimap键值可重复。 Map和multimap都是以红黑树为底层实现机制。 map/multimap常用API map构造函数 map mapTT;//map默认构造函数 map(const map &mp);//拷贝构造函数 map赋值操作 map& operator=(const map &mp);//重载等号操作符 swap(mp);//交换两个集合容器 map大小操作 size();//返回容器中元素的数目 empty();//判断容器是否为空 map插入数据元素操作 map1.insert(...); //往容器插入元素，返回pair map1[key]=value map mapStu; // 第一种 通过pair的方式插入对象 mapStu.insert(pair(3, \"小张\")); // 第二种 通过make_pair的方式插入对象 mapStu.inset(make_pair(-1, \"校长\")); // 第三种 通过value_type的方式插入对象 mapStu.insert(map::value_type(1, \"小李\")); // 第四种 通过数组的方式插入值 mapStu[33] = \"小刘\"; // map1[key]=value mapStu[55] = \"小王\"; map删除操作 clear();//删除所有元素 erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(keyElem);//删除容器中key为keyElem的对组。 map查找操作 find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end(); count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。 lower_bound(keyElem);//返回第一个key>=keyElem元素的迭代器。 upper_bound(keyElem);//返回第一个key>keyElem元素的迭代器。 equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 3.9 STL容器比较 vector deque list set multiset map multimap 典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树 可随机存取 是 是 否 否 否 对key而言：不是 否 元素搜寻速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快 元素安插移除 尾端 头尾两端 任何位置 - - - - vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。 deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。 list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。 set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。 vector与deque的比较： vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。 如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。 deque支持头部的快速插入与快速移除，这是deque的优点。 4. 常用算法 4.2 算法概述 算法主要是由头文件， ， 组成。 是所有STL头文件中最大的一个，其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等... 定义了一些模板类,用以声明函数对象。 体积很小，只包括在几个序列容器上进行的简单运算的模板函数. 4.3 常用遍历算法 /* for_each遍历算法 遍历容器元素 @param beg 开始迭代器 @param end 结束迭代器 @param _callback 函数回调或者函数对象 @return 函数对象 */ for_each(iterator beg, iterator end, _callback); /* transform算法 将指定容器区间元素搬运到另一容器中 注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存 @param beg1 源容器开始迭代器 @param end1 源容器结束迭代器 @param beg2 目标容器开始迭代器 @param _cakkback 回调函数或者函数对象 @return 返回目标容器迭代器 */ transform(iterator beg1, iterator end1, iterator beg2, _callbakc) 4.4 常用查找算法 /* find算法 查找元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value 查找的元素 @return 返回查找元素的位置 */ find(iterator beg, iterator end, value) /* find_if算法 条件查找 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback 回调函数或者谓词(返回bool类型的函数对象) @return bool 查找返回true 否则false */ find_if(iterator beg, iterator end, _callback); /* adjacent_find算法 查找相邻重复元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param _callback 回调函数或者谓词(返回bool类型的函数对象) @return 返回相邻元素的第一个位置的迭代器 */ adjacent_find(iterator beg, iterator end, _callback); /* binary_search算法 二分查找法 注意: 在无序序列中不可用 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value 查找的元素 @return bool 查找返回true 否则false */ bool binary_search(iterator beg, iterator end, value); /* count算法 统计元素出现次数 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value回调函数或者谓词(返回bool类型的函数对象) @return int返回元素个数 */ count(iterator beg, iterator end, value); /* count算法 统计元素出现次数 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback 回调函数或者谓词(返回bool类型的函数对象) @return int返回元素个数 */ count_if(iterator beg, iterator end, _callback); 4.5 常用排序算法 /* merge算法 容器元素合并，并存储到另一容器中 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 */ merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest) /* sort算法 容器元素排序 注意:两个容器必须是有序的 @param beg 容器1开始迭代器 @param end 容器1结束迭代器 @param _callback 回调函数或者谓词(返回bool类型的函数对象) */ sort(iterator beg, iterator end, _callback) /* sort算法 对指定范围内的元素随机调整次序 @param beg 容器开始迭代器 @param end 容器结束迭代器 */ random_shuffle(iterator beg, iterator end) /* reverse算法 反转指定范围的元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 */ reverse(iterator beg, iterator end) 4.6 常用拷贝和替换算法 /* copy算法 将容器内指定范围的元素拷贝到另一容器中 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param dest 目标起始迭代器 */ copy(iterator beg, iterator end, iterator dest) /* replace算法 将容器内指定范围的旧元素修改为新元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param oldvalue 旧元素 @param oldvalue 新元素 */ replace(iterator beg, iterator end, oldvalue, newvalue) /* replace_if算法 将容器内指定范围满足条件的元素替换为新元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback函数回调或者谓词(返回Bool类型的函数对象) @param oldvalue 新元素 */ replace_if(iterator beg, iterator end, _callback, newvalue) /* swap算法 互换两个容器的元素 @param c1容器1 @param c2容器2 */ swap(container c1, container c2) 4.7 常用算数生成算法 /* accumulate算法 计算容器元素累计总和 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value累加值 */ accumulate(iterator beg, iterator end, value) /* fill算法 向容器中添加元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value t填充元素 */ fill(iterator beg, iterator end, value) 4.8 常用集合算法 /* set_intersection算法 求两个set集合的交集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址 */ set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest) /* set_union算法 求两个set集合的并集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址 */ set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest) /* set_difference算法 求两个set集合的差集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址 */ set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest) 其他 4.1 函数对象 重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor)，其实就是重载()操作符，使得类对象可以像函数那样调用。 注意: 1.函数对象(仿函数)是一个类，不是一个函数。 2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。 分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。 函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。 总结： 函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。 函数对象超出普通函数的概念，函数对象可以有自己的状态。 函数对象可内联编译，性能好。用函数指针几乎不可能。 模版函数对象使函数对象具有通用性，这也是它的优势之一。 4.2 谓词 谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。 4.3 STL内建函数对象 STL内建了一些函数对象。分为：算数类函数对象，关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include。 算数类函数对象,除了negate是一元运算，其他都是二元运算。 template T plus//加法仿函数 template T minus//减法仿函数 template T multiplies//乘法仿函数 template T divides//除法仿函数 template T modulus//取模仿函数 template T negate//取反仿函数 关系运算类函数对象,每一种都是二元运算。 template bool equal_to//等于 template bool not_equal_to//不等于 template bool greater//大于 template bool greater_equal//大于等于 template bool less//小于 template bool less_equal//小于等于 逻辑运算类运算函数,not为一元运算，其余为二元运算。 template bool logical_and//逻辑与 template bool logical_or//逻辑或 template bool logical_not//逻辑非 //取反仿函数 negate n; cout p; cout v; sort(v.begin(), v.end(), greater()); 函数对象适配器 1、函数适配器 函数适配器bind1st和bind2nd 总结： bind1st和bind2nd区别? bind1st ： 将参数绑定为函数对象的第一个参数 bind2nd ： 将参数绑定为函数对象的第二个参数 bind1st和bind2nd将二元函数对象转为一元函数对象 // 打印两个数之和 class MyPrint :public binary_function{ public: void operator()(int v1,int v2) const { cout v; for (int i = 0; i > x; for_each(v.begin(), v.end(), bind1st(MyPrint(), x)); //for_each(v.begin(), v.end(), bind2nd( MyPrint(),x )); } 2、取反适配器 not1 对一元函数对象取反 not2 对二元函数对象取反 class GreaterThenFive:public unary_function{ public: bool operator ()(int v) const { return v > 5; } }; //2、取反适配器 void test02(){ vector v; for (int i = 0; i ::iterator it = find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器 // vector::iterator it = find_if(v.begin(), v.end(), not1(GreaterThenFive())); //返回第一个小于5迭代器 //自定义输入 vector::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater(),5))); if (it == v.end()) { cout ())); for_each(v.begin(), v.end(), [](int val){cout 3、函数指针适配器 函数指针适配器 ptr_fun( )把一个普通的函数指针适配成函数对象 // 普通的函数 void MyPrint03(int v,int v2){ cout v; for (int i = 0; i 4、成员函数适配器 利用 mem_fun_ref 将Person内部成员函数适配 //如果容器存放的是对象指针， 那么用mem_fun //如果容器中存放的是对象实体，那么用mem_fun_ref // 类有成员函数 class Person{ public: Person(string name, int age) { m_Name = name; m_Age = age; } //打印成员函数 void ShowPerson(){ cout v; Person p1(\"aaa\", 10); //创建数据 Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); //for_each(v.begin(), v.end(), MyPrint04); // 普通函数指针 // 成员函数适配器 //利用 mem_fun_ref 将Person内部成员函数适配，容器中存放的是对象实体，用mem_fun_ref for_each(v.begin(), v.end(), mem_fun_ref(&Person::ShowPerson)); // for_each(v.begin(), v.end(), mem_fun_ref(&Person::Plus100)); } void test05(){ vector v1; Person p1(\"aaa\", 10);//创建数据 Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v1.push_back(&p1); v1.push_back(&p2); v1.push_back(&p3); v1.push_back(&p4); // 成员函数适配器 // 利用 mem_fun 将Person内部成员函数适配，容器存放的是对象指针，用mem_fun for_each(v1.begin(), v1.end(), mem_fun(&Person::ShowPerson)); // } "},"linux-basic/":{"url":"linux-basic/","title":"linux基础","keywords":"","body":"Linux基本命令Linux基本命令 Linux 是一种自由和开放源码的类UNIX操作系统。该操作系统的内核由芬兰人林纳斯·托瓦兹（Linus Torvalds）在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为Linux操作系统。 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、oracle linux等。 Linu简介 Linux系统的文件 基本指令 进阶命令 进程管理 正则表达式 字符串处理 压缩包管理 权限管理 用户管理 用户组管理 网络配置 文件传输 FTP / SFTP服务 SSH服务 vim编辑器 shell编程 Reference "},"linux-basic/linux-command.html":{"url":"linux-basic/linux-command.html","title":"Linux基本命令","keywords":"","body":"Linux基本命令Linu简介Linux系统的文件基本指令进阶命令进程管理正则表达式hellohello字符串处理压缩与解压软件包管理权限管理用户管理用户组管理网络配置文件传输FTP / SFTP服务SSH服务vim编辑器shell编程ReferenceLinux基本命令 [TOC] Linu简介 Linux系统的文件 基本指令 进阶命令 进程管理 正则表达式 字符串处理 压缩与解压 软件包管理 权限管理 用户管理 用户组管理 网络配置 文件传输 FTP / SFTP服务 SSH服务 vim编辑器 shell编程 Reference Linu简介 Linux 是一种自由和开放源码的类UNIX操作系统。该操作系统的内核由芬兰人林纳斯·托瓦兹（Linus Torvalds）在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为Linux操作系统。 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、oracle linux等。 Linux系统的文件 系统目录结构 /：根目录，一般根目录下只存放目录，在 linux 下有且只有一个根目录，所有的东西都是从这里开始 /bin ：binary二进制执行文件目录,存放着最经常使用的命令，如 ls、mv、cat 等 /sbin ：全称super binary，系统管理员专用的二进制代码存放目录，系统管理员使用的系统管理程序 /home：用户的家目录（除了root用户以外），在Linux中，每个用户都有一个自己的目录，，一般该目录名是以用户的账号命名的 /usr：用户数据目录，用户的很多自己安装的软件应用程序和文件都放在这个目录下。类似于windows下的program files /usr/bin：系统用户使用的应用程序 /usr/sbin ：超级用户使用的比较高级的管理程序和系统守护程序 /usr/share：存放共享数据？？ /usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local：存放软件升级包？？ /usr/share/doc：系统说明文件存放目录 /usr/share/man：程序说明文件存放目录 /usr/src：内核源代码默认的放置目录 /opt: (Optional Software Packages)可选程序包，额外第三方软件安装的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下 /dev：Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的，访问该目录下某个文件，相当于访问某个设备。 /media: media，媒介设备， linux系统会自动识别一些媒介设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下 /mnt：mount，临时文件系统挂载点。系统提供该目录是为了让用户临时挂载别的文件系统的，当外接设备需要临时挂载的时候，就需要挂载到mnt目录下，如我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /boot：放置 linux 系统启动时用到的一些核心文件，包括一些连接文件以及镜像文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下，这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件 /sys: sysfs文件系统，这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯，用于将系统中的设备组织成层次结构，并向用户模式程序提供详细的内核数据结构信息。其实，就是在用户态可以通过对sys文件系统的访问，来看内核态的一些驱动或者设备等。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。 /root：系统超级管理员root的家目录 /etc：系统配置文件存放的目录，重要的配置文件有/etc/hosts, /etc/resolv.conf, nsswitch.conf,/etc/inittab /etc/fstab /etc/init.d /etc/X11 /etc/sysconfig /etc/xinetd.d /lib、/usr/lib、/usr/local/lib：library，存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /proc：process，表示进程，该目录中存储的是Linux运行时候的进程，这个目录是一个虚拟的目录，它是系统内存的映射，而不占用外存空间，这个目录的内容不在硬盘上而是在内存里，它以文件系统的方式为访问系统内核数据的操作提供接口。用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数，我们可以通过直接访问这个目录来获取系统信息，如系统内核的状态cat /proc/cpuinfo，外部设备，网络状态，正在运行的进程的状态等，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all proc 文件系统可以被用于收集有用的关于系统和运行中的内核的信息。下面是一些重要的文件： /proc/cpuinfo - CPU 的信息(型号, 家族, 缓存大小等) /proc/meminfo - 物理内存、交换空间等的信息 /proc/mounts - 已加载的文件系统的列表 /proc/devices - 可用设备的列表 /proc/filesystems - 被支持的文件系统 /proc/modules - 已加载的模块 /proc/version - 内核版本 /proc/cmdline - 系统启动时输入的内核命令行参数 /tmp：temporary，存放系统运行时候产生的临时文件。每次系统重启之后，这个目录下的”临时”文件便会被清空 run：存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉 /var：virable，系统执行过程中经常变化的文件，如随时更改的日志文件。存放的系统/程序日志文件的目录。这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /srv：service 服务，存放服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内 在linux系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。 Linux一切皆文件 Linux 对数据文件(.mp3、.bmp)，程序文件(.c、.h、*.o)，设备文件（LCD、触摸屏、鼠标），网络文件( socket ) 等的管理都抽象为文件，使用统一的方式方法管理。 文件分类： 普通文件( 数据文件 ) 普通文件是用于存放数据、程序等信息的文件，一般都长期地存放在外存储器（磁盘）中。普通文件又分为文本文件和二进制文件。 目录文件 目录文件是文件系统中一个目录所包含的目录项所组成的文件。 可执行文件 压缩文件 链接文件 似于 windows 下的快捷方式，链接又可以分为软链接（符号链接）和硬链接。 设备文件 设备文件是用于为操作系统与设备提供连接的一种文件。在Linux系统中将设备作为文件来处理，操作设备就像是操作普通文件一样。每一个设备对应一个设备文件，存放在 /dev 目录中。 管道文件 管道文件主要用于在进程间传递数据的一种特殊文件。 套接口文件 主要用于不同计算机间网络通信的一种特殊文件。 ![](assets/linux-文件目录颜色.png) 文件路径 相对路径：表示相对一当前目录所在的目录位置,./当前目录下、../上一级目录下 绝对路径：从根目录/开始寻找目录位置,或从家目录~开始寻找目录位置 ./代表当前目录 ../代表上一级目录 /根目录 ~家目录 文件特点 ls -lah命令显示字符所代表的意义： -文件，d目录 rwx可读可写可执行权限,拥有者/组/其他人对应的权限 数字硬链接数，就是有多少种方式可以访问到该目录或文件 chao文件拥有者 chao所属组 .开头的文件为隐藏文件 软链接 一个文件分为文件名和文件数据，建立软连接时相当于通过一个渠道直接访问文件数据，但文件数据删除后便找不到访问的目标，即无法访问了 基本指令 终端快捷键 打开关闭终端 打开关闭终端 Ctrl + Alt + t 打开终端 Ctrl+Shift+t 打开新的标签页 Alt+数字 切换至对应的标签页 Ctrl + Tab 切换标签页 Ctrl+d 关闭标签页/终端 终端操作 终端操作 Ctrl + = 放大终端窗口的字体显示 Ctrl + - 缩小终端窗口的字体显示 Ctrl+0 原始字体大小 ==F11== 全屏切换 ==Shift+上 ↑/下 ↓== 终端上下==滚动行== Tab 自动补全 ==Ctrl+s== 阻断向终端输出(终端不显示输出类似输密码时) ==Ctrl+q== 恢复向终端输出 Ctrl+c 终止进程/命令 Ctrl+l 清屏, 相当于clear 复制/粘贴 复制/粘贴 Shift+Ctrl+c 复制 Shift+Ctrl+v 粘贴 删除 删除 Ctrl + h (Backspace)向前删除一位 Ctrl + d (Delet)向后删除一位 ==Ctrl + w== 删除前一个==单词== Alt + d 向后删除后一个单词 ==Ctrl + u== 删除到行首 ==Ctrl + k== 删除到行尾 光标移动 光标移动 ==Alt== + b 后跳到上一个==单词== ==Alt== + f 前跳到下一个==单词== Ctrl + b 向后移动光标 Ctrl + f 向前移动光标 Ctrl+==a== 光标移动到行首 Ctrl+==e== 光标移动到行尾 历史命令 历史命令 Ctrl + r 滚动搜索历史命令(reverse-i-search) history 命令历史记录 !num 执行history命令历史列表的第num条命令 !! 执行上一条命令 Ctrl+p 显示上一条命令 Ctrl+n 显示下一条命令 终端快捷键汇总 快捷键 Ctrl + Alt + t 打开终端 Ctrl+Shift+t 打开新的标签页 Ctrl+d 关闭标签页/终端 Ctrl + = 放大终端窗口的字体显示 Ctrl + - 缩小终端窗口的字体显示 Ctrl+0 原始字体大小 Tab 自动补全 Shift+Ctrl+c 复制 Shift+Ctrl+v 粘贴 ==Alt + b== 后跳到上一个单词 ==Alt + f== 前跳到下一个单词 Ctrl+b 向后移动光标 Ctrl+f 向前移动光标 Ctrl+a 光标移动到行首 Ctrl+e 光标移动到行尾 Ctrl + h 向前删除一位(Backspace) Ctrl + d 向后删除一位(Delet) Alt + d 向后删除一个单词 ==Ctrl + w== 删除一个单词 ==Ctrl + u== 删除到行首 ==Ctrl + k== 删除到行尾 Ctrl + r 搜索历史命令(reverse-i-search) history 命令历史记录 !num 执行history命令历史列表的第num条命令 !! 执行上一条命令 Ctrl+p 显示上一条命令 Ctrl+n 显示下一条命令 Ctrl+c 终止进程/命令 Ctrl+l 清屏, 相当于clear F11 全屏切换 终端命令格式 虚拟终端 tty 设备 ， 互不影响 tty1 - tty6 命令行模式 ctrl + alt + [F1-F6] tty7 图形界面 ctrl +　alt + F7 对用户输入的命令进行解析，调用对应的 执行程序 命令 [选项] [操作对象] - - help 帮助 查询command命令帮助手册 command命令 --help man 帮助手册 作用：manual，手册（包含了Linux中全部命令手册，英文） man 命令ls # 查询命令帮助手册 查看手册方法： 快捷键 功能 Enter 键 向下显示一行 f/空格键 下一屏 b 上一屏 q 退出 /关键词word 搜索 ==关键词word== ,高亮显示 ls 查看目录 ls 即 list(列出) ,列出当前工作目录下的所有文件/文件夹的名称 ls [-lah] [路径] -a：all 显示指定目录下的所有子目录和文件，包括隐藏文件 -l：list 以详细列表方式显示文件的详细信息 -h：以人性化的方式显示文件大小 -R: 递归显示子目录 pwd 当前路径 pwd 即 print wrok directory（打印工作目录）,查看当前所在文件夹路径 pwd cd 切换目录 cd 即 change directory（切换工作目录）,切换文件夹 cd [目录路径] cd:切换到当前目录的主目录（/home/用户目录） cd ~:切换到当前目录的主目录（/home/用户目录） cd .：保持当前目录不变 cd ..：切换到上一级目录 cd -：切换到上次访问的目录,(在最近两次工作目录之间来回切换) 注意：Linux 所有的 目录 和 文件名 都是大小写敏感的 touch 新建文件 touch 即 touch（摸）,如果文件不存在，新建文件,如文件已存在，可用于刷新文件修改时间 touch [文件名] touch a1.py b1.py /home/chao/c1.py # 新建三个文件 mkdir 新建目录 mkdir 即 make directory（创建目录）,创建目录 mkdir [目录路径] -p递归创建目录（mkdir -p a/b/c/d） 注意: 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 cp 复制 cp 即 copy（复制） 作用：复制文件或者目录 cp [参数] [源文件] [目标文件] cp [源文件] [目标文件] # 复制文件 cp -r [源文件] [目标文件] # 复制文件夹 cp {filename1,filename2,...} 目标文件 # 复制多个文件 -r：递归复制,递归复制该目录下的所有子目录和文件,复制==文件夹==时必须加上此==-r==参数 -i：覆盖文件前提示（输入y确认覆盖，输入n不覆盖） mv 移动 mv 即 move（移动） 作用：移动文件或者目录，还可以给文件重命名 mv -i [源文件] [目标文件] mv {filename1,filename2,...} 目标文件 # 移动多个文件 -i：覆盖前提示 rm 删除 rm 即 remove（删除） 作用:删除指定文件名（删除文件无法恢复） rm -r 新建文件夹/ # 删除文件夹下所有文件 rm aa.py bb.py # 删除多个文件 `` `-r`：递归删除目录下的内容，删除==**文件夹**==时必须加上此==-r==参数 `-f`：force 强制删除，忽略不存在文件，无需提示 #### tree 文件树 tree 即 tree（树） 作用：以树状图的方式列出文件目录结构 ​```shell tree [目录名] -d：只显示目录 有些系统可能没有此命令，需用：sudo apt-get install tree命令安装 vim编辑 vim是一款文本编辑器,vim文件不存在则新建 vim test.py cat 查看文件内容 cat 即 concatenate（连接合并） 作用：查看文件全部内容，一次性显示==全部内容==,创建文件、文件合并追加文件内容等功能（适合查看内容较少的文件） cat [选项] 文件名 cat -n test.py # 查看内容 cat a1.txt a2.txt > a3.txt # 合并a1,a2到a3 -b：对非空输出行编号（就是显示文件的行数，若某行为空白，则不计入行数） -n：对输出的所有行编号（就是显示文件行数，空白行也计入行数） nl 带行号显示 nl [-bnw] 文件 -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 more 查看大文件 more 即 more（更多） 作用：==分屏==显示文件内容，每次只显示一页内容（适合查看内容较多的文件） more 文件名 使用 more 的操作键： 快捷键 功能 Enter 键 向下显示一行 f/空格键 下一屏 b 上一屏 q 退出 /关键词word 搜索 ==关键词word== ,高亮显示 less 查看文件 作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车、空格键+上下方向键）查看更多 less 文件名 head 查看前几行 作用：查看一个文件的前n行，如果不指定n，则默认显示前10行。 head -n行 文件名 # 查看前n行 tail 查看后几行 作用1：查看一个文件的未n行，如果n不指定默认显示后10行 tail -后n行 文件的路径 # 查看后n行 tail -5 test.py # 查看后5行 tail 实时查看日志 作用2：可以通过tail指令来查看一个文件的动态变化内容【变化的内容不能是用户手动增加的】 tail -f xxx.log # 实时显示日志内容(自动更新) 该命令一般用于查看系统的日志比较多。 wc 字数统计 wc 即 word count (单词数量)作用：统计文件内容信息（包含行数、单词数、字节数） wc -lwc 文件名 # 文件统计信息 l：表示lines，行数 w：表示words，单词数 依照空格来判断单词数量 c：表示bytes，字节数 grep 查找文本 grep 即 globally search a regular expression 作用：查找文本文件内容,能用正则表达式 grep [参数] [查找内容] [文件名] grep -n print test.py # 在test.py中查找print -n: 显示匹配行以及行号 -v：显示不包含匹配文本的所有行（相当于求反） -i：不包含大小写的搜索文本 ^文本：行首，搜索以搜索文本开头的行（正则表达式） 文本$：行尾，搜索以搜索文本结尾的行（正则表达式） 通配符 //正则?? *：代表任意个数的字符 ?：代表任意一个字符，至少 1 个 [ ]：可以表示匹配括号内字符的任意一个, [abc]表示匹配 a、b、c 中的任意一个 [a-f]: 匹配从 a 到 f 范围内的的任意一个字符,[0-9]表示匹配0123456789中的任意一个 echo 回声 echo 即 echo(回声) 作用：让终端中显示参数指定文字，通常与重定向联合使用 echo -e 'hel\\nlo world' ; echo -n 'hello boy' n: 不换行输出 e: 输出转义字符 \\b退格 \\n换行 \\t制表符 \\r光标移至行首 | 管道 将 一个命令的输出 可以通过管道 做为 另一个命令的输入，前面的命令有个输出，后面需要先输入，然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入 cat test.py | grep print ls -lha ./ | grep -i ^d # 只显示当前文件夹(find) ls -lah ./ | grep -i ^- # 只显示当前文件 ls 目录| wc -l # 统计某个目录下的文档的总个数 ./test.sh | tee test.log # 输出日志并写到.log文件 sort?? tee ?? > 和 >> 输出重定向 一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。 >和>>将命令执行结果重定向写入到一个文件,文件不存在则新建 echo 'hello world' > h1.py # 覆盖 echo 'hello world' >> h1.py # 追加 > ：覆盖输出,覆盖文件原有内容 >> : 追加输出,将内容追加到已有文件的末尾 clear 清屏 clear 即 clear（清除） 作用：清屏,快捷键Ctrl+L clear # 清屏 date 日期 date 即 date（日） 作用：查询系统时间日期 date # 输出形式：2018年 3月 24日 星期六 15:54:28 date +%F # 输出：2018-03-24 等价于 # date “+%Y-%m-%d” date “+%F %T” # 输出的形式：2018-03-24 16:01:00 等价于 # date “+%Y-%m-%d %H:%M:%S” # 获取之前或者之后的某个时间（备份） date -d “-1 day” “+%Y-%m-%d %H:%M:%S” 符号的可选值：+（之后） 或者 - （之前） 单位的可选值：day（天）、month（月份）、year（年） %F：表示完整的年月日 %T：表示完整的时分秒 %Y：表示四位年份 %m：表示两位月份（带前导0） %d：表示日期（带前导0） %H：表示小时（带前导0） %M：表示分钟（带前导0） %S：表示秒数（带前导0） cal 日历 cal 即 calendar（日历）作用：查看日历 cal # 当前月份的日历 # cal -1 # 当前月份日历 # cal -3 # 当前三个月的日历 cal -y # 输出当前年份的日历 cal -y 2013 # 输出某一个年份的日历 -y：查询一年的日历 shutdown 关机 shutdown 对应英文:shutdown(关闭), 关机或重启 shutdown [选项] [时间] shutdown -r now # 立即重启 shutdown now # 立即关机 shutdown # 默认1分钟后关机 shutdown +10 # 再过十分钟后自动关机 shutdown 23:55 \"提示-将在23:55关机\" # 定时关机 shutdown -c # 取消关机或重启计划 -r：让电脑重新启动 now：表示立刻 20:18：20时18分关闭或重启电脑，其他时间同理 +10：使关机或重启时间延迟十分钟，延迟到其他时间同理 shutdown -c 取消关机或重新启动 不指定选项和参数，默认表示 1 分钟之后 关闭电脑 除了shutdown关机以外，还有以下几个关机命令： # init 0 # halt # poweroff reboot 重启 作用：重新启动计算机 reboot # 重启 w 模拟重启，但是不重启（只写关机与开机的日志信息） 进阶命令 hostname 主机名 输出完整的主机名 hostname # 输出完整的主机名 设置临时主机名 hostname 新主机名 # 设置临时主机名，重启后失效 当前终端下不会立即生效。重新打开一个终端窗口(通过ssh连接的终端需要重新连接)才会显示生效后的主机名 永久修改主机名 sudo vim /etc/hostname /etc/hostname中只有一行，就是主机名，将它替换掉并保存。再执行reboot命令重启机器即可 设置ip别名？？ /etc/hosts存放的是域名与ip的对应关系，域名与主机名没有任何关系，你可以为任何一个IP指定任意一个名字。 修改/etc/hosts配置文件 sudo vim /etc/hosts chao@deepin:~$ cat /etc/hosts 127.0.0.1 localhost 127.0.1.1 deepin ``#IP address alias 10.68.0.2 myserver 重启一下， ssh myserver 和ssh 10.68.0.2效果一样 id 用户id id 对应英文：IDentity（身份标识号码） 作用：查看一个用户的一些基本信息,包含UID（用户代号）和GID（组代号）信息，附加组id…，该指令如果不指定用户则默认当前用户。 id # 默认显示当前用户的基本信息 id 用户名 # 显示指定用户的基本信息 w 活动用户 w who 所有用户 who 对应英文：who（谁） 作用：查看当前在线用户的情况，登录的用户名，使用的设备终端（pts），登录到系统的时间 who chao@deepin:~$ who chao tty1 2019-10-27 10:38 (:0) 用户名 登录终端 登录时间 whoami 当前用户 whoami 对应英文：who am I（我是谁） 作用：显示当前登录的用户名 whoami last 用户登录日志 last uptime 在线时间 作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间） uptime time 计算程序运行时间 time python3 test.py # 计算 test.py 程序运行的时间 time ./test.sh # 计算 test.sh 程序运行的时间 uname 系统信息 作用：获取计算机操作系统相关信息 uname # 操作系统的类型 uname -a # 全部的操作系统信息 a: all 获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划） 查询Debian版本 cat /etc/debian_version which 查找命令 which 对应英文：which（哪个） 作用：查找系统PATH目录下的可执行文件命令保存系统中的位置。说白了就是查找那些我们已经安装好的可以直接执行的命令 which 终端命令/可执行文件 whereis 查找二进制（命令）、源文件、man文件。与which不同的是这条命令可以是通过文件索引数据库而非PATH来查找的，所以查找的面比which要广。 whereis 终端命令/可执行文件 find 查找文件 find 对应英文：find（找到） 作用：查找文件,包括隐藏文件 find [路径] -name “查找的名称” # 按照文档名称搜索 find [路径] -type f # 搜索路径下的所有文件 find [路径] -type d # 搜索路径下的所有文件夹 ==-name== ==-type== lsof 查看正在被使用的文件 losf命令是list open file的缩写 diff 比较文件差异 diff ： different 不同，比较两个文件的内容的不同或文件目录结构的不同 比较两个文件的内容的不同,以逐行的方式，比较文本文件的异同处。比较两个目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。 diff file_A file_B # 比较两个文件内容的不同 diff -y file_A file_B # 比较两个文件内容的不同,并排格式输出 diff dir_A dir_B # 比较两个文件目录结构的不同,而不管子目录 diff -r dir_A dir_B # 比较两个文件目录结构的不同， ==-r== ： --recursive 递归比较子目录中的文件 ==-y== ：以并列的方式显示文件的异同之处。 -a ：所有的文件都视为文本文件来逐行比较，甚至他们似乎不是文本文件. -b或--ignore-space-change 　不检查空格字符的不同。 -w或--ignore-all-space 　忽略全部的空格字符 -B或--ignore-blank-lines 　不检查空白行。 -c ：context显示全部内文，并标出不同之处。 -i或--ignore-case 　不检查大小写的不同 -x, --exclude=PAT 比较目录的时候排除指定PAT模式的文件名的比较 -s或--report-identical-files 　若没有发现任何差异，仍然显示信息 输出文件差异，没有任何输出则说明两个文件没有不同，完全相同 \"|\"表示前后2个文件内容有不同 \"\"表示后面文件比前面文件多了1行内容 diff -c file_A file_B # 显示全部内文，并标出不同之处 ＋ 比较的文件的后者比前着多一行 － 比较的文件的后者比前着少一行 ！ 比较的文件两者有差别的行 mount 挂载 -t ：vsftype指定文件系统类型 -r: readonly，只读挂载 -w: read and write, 读写挂载 -n: 不更新/etc/mtab； -l：显示已加载的文件系统列表 -a：自动挂载所有支持自动挂载的设备；(定义在了/etc/fstab文件中，且挂载选项中有“自动挂载”功能) -o ： options(挂载的选项) ro：只读， rw：读写方式挂载，默认 sync：同步模式，不适用缓存，所有操作直接读写磁盘； async：适用缓存，默认； noatime：每次访问文件时不更新文件的访问时间。 atime：每次访问文件时更新文件的访问时间，默认方式。 user：任何用户都可以挂载 nouser：只有超级用户才可以挂载 auto：系统开机自动挂载 noauto：系统开机不自动挂载 remount：重新挂载文件系统 loop：使用 loop 模式用来将一个文件当成硬盘分割挂上系统 mount　　＃ 查看当前已挂载 mount /dev/sdb8 /mnt # 挂载到/mnt mount -r /dev/hda1 /mnt # 只读挂载 mount -o loop CentOS-6.7-x86_64-bin-DVD1.iso /media/cdrom/ # 挂载ios镜像文件 umount /media/cdrom # 卸载 umount卸载挂载 umount /media/cdrom # 卸载 du 目录使用情况 du 对应英文：disk usage（磁盘使用） 作用：显示目录下文件大小,及其所有子目录(包含隐藏文件) du -h [目录名] # 当前目录下各文件的大小 du -sh # 当前目录使用总大小 du -h --max-depth=1 du -h -d 1 [目录名] # -d 显示文件夹深度(显示到二级目录) du -h -d 1 | sort -h # 按文件夹大小排序,升序 du -h -d 1 | sort -hr # 按文件夹大小排序,降序 -h：以人性化方式显示文件大小 -s: summaries，只显示汇总的大小 ==-d==: depth 显示文件夹深度(显示几级目录) df 磁盘剩余空间 df 对应英文：disk free（磁盘剩余空间）作用：显示磁盘剩余空间 df -h # 磁盘剩余空间 df -h ./ # 当前磁盘剩余空间 -h：以人性化的方式显示磁盘大小 free 查看剩余内存 作用：查看内存使用情况 free -m # 查看内存使用情况 m: 表示以mb为单位查看 tee ln 软链接 ln 对应英文link： 作用：建立文件的软或硬链接,默认的连接类型是硬连接,软链接类似于windows系统的快捷方式,不论是硬连结或软链结都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 ln [选项] 源文件或目录 目标文件或目录 ln -s 源文件 软连接文件(快捷方式) ln -s /usr/local/redis/bin/redis-cli /usr/local/bin/redis-cli　　＃ 建立软连接 -s：建立文件的软连接,如果不加\"-s\"选项，则建立硬链接文件； -f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件； -d : 允许系统管理者硬链结自己的目录 -i : 在删除与 dist 同档名的档案时先进行询问 -n : 在进行软连结时，将 dist 视为一般的档案 -s : 进行软链结(symbolic link) -v : 在连结之前显示其档名 -b : 将在链结时会被覆写或删除的档案进行备份 -S SUFFIX : 将备份的档案都加上 SUFFIX 的字 -V METHOD : 指定备份的方式 --help : 显示辅助说明 --version : 显示版本 注意: 建立的软链接 源文件一般要用绝对路径，不能使用相对路径，这样可以方便移动软链接文件后，仍然能够正常使用,(源和目标最好都用绝对路径),在使用 ln 创建链接时，如果没有 ==-s== 选项，会创建一个 硬链接，工作中几乎不会建立文件的硬链接 软链接(Soft Link)又称为符号链接（Symbolic link）,软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 软链接的特点（软链接的特点和 Windows 中的快捷方式完全一致）。 不论是修改源文件（check），还是修改硬链接文件（check-soft)，另一个文件中的数据都会发生改变。 删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。 软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。 软链接可以链接目录。 软链接可以跨分区。 硬链接硬连接指通过索引节点来进行连接。说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征。这些特征都使得硬链接并不常用，大家有所了解就好。 硬链接的特点如下： 不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变。 不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问。 硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。 硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的。 硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。 文件软硬链接的示意图 在 Linux 中，文件名 和 文件的数据 是分开存储的 ls -lh文件类型位置的“l”表示其类型为link（连接类型），后面的“->”指向的是原始文件路径 进程管理 pidof 查询进程号 pidof deepin-terminal # 查询 deepin-terminal 进程号 ps 进程 ps 对应英文：process status(程序进程) 作用：查看整个系统内部所运行的进程状况 ps -aux # 显示当前用户下所有进程 ps -aux | grep firefox a：all 显示终端上的所有进程，包括其他用户的进程 u：显示进程的详细信息，查看进程所有者及其他一些信息 x：显示没有控制终端的进程， -- 不能与用户进行交互的进程【输入、输出】 ps 默认只会显示当前用户通过终端启动的应用程序 列的含义： UID：user id 该进程执行的用户id； PID：process id 进程id； PPID：parent process ID该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程； C：Cpu的占用率，其形式是百分数； STIME：start time 进行的启动时间； TTY：Teletypes 终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起； TIME：进程的执行时间； CMD：该进程的名称或者对应的路径； 查看当前占用CPU或内存最多的n10个进程 ps -aux | sort -k4nr | head -10 说明：ps -aux中（a指代all——所有的进程，u指代userid——执行该进程的用户id，x指代显示所有程序，不以终端机来区分） sort -k4nr中（k代表从第几个位置开始，后面的数字4即是其开始位置，结束位置如果没有，则默认到最后；n指代numberic sort，根据其数值排序；r指代reverse，这里是指反向比较结果，输出时默认从小到大，反向后从大到小。）。本例中，可以看到%MEM在第4个位置，根据%MEM的数值进行由大到小的排序。 head -n（n指代行数，即输出前几位的结果） |为管道符号，将查询出的结果导到下面的命令中进行下一步的操作。 top 动态进程 top 对应英文：top（顶端） 作用：动态显示运行中的程序并排序 top 表头含义： PID：进程id； USER：该进程对应的用户； PR：优先级； VIRT：虚拟内存； RES：常驻内存； SHR：共享内存； S：表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）； %CPU：表示CPU的占用百分比； %MEM：表示内存的占用百分比； TIME+：执行的时间； COMMAND：进程的名称或者路径； 在运行top的时候，可以按下方便的快捷键： M：表示将结果按照内存（MEM）从高到低进行降序排列； P：表示将结果按照CPU使用率从高到低进行降序排列； 1：当服务器拥有多个cpu的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息； q: 退出页面 htop 进程 htop # top升级版 kill 结束进程 kill 对应英文：kill（杀死） 作用：杀死进程，用来终止指定的进程（terminate a process）的运行 kill 27890 # 终止指定代号的进程 kill -9 进程标识号PID # 向当前进程发送了9号信号（SIGKILL） -9 -SIGKILL： 查看信号编号 kill -l pkill 结束进程 pkill 进程名称 pkill ss-qt5 # 结束 ss-qt5 进程 killall 结束进程 与kill命令作用相似但是比kill更加好用的杀死进程的命令,作用同pkill killall 进程名称 service 服务 作用：用于控制一些软件的服务启动/停止/重启 service 服务名 start/stop/restart env 所有环境变量 env，enticement查看当前进程环境变量 env echo $PAHT # 只查看环境变量PATH的值 PATH：该环境变量中记录着shell命令解析器去查找命令的目录位置，从前往后的顺序查找 查看操作系统信息 uname -a cat /proc/version lsb_release -a 查询Debian版本 cat /etc/debian_version 查看CPU信息 lscpu # 查看CPU架构信息 cat /proc/cpuinfo # 查看CPU详细信息 查看内存信息 free -h # 内存的使用情况 cat /proc/meminfo # 查看内存详细信息 dmidecode -t memory # 查看内存硬件信息 查看硬盘信息 fdisk -l # 查看硬盘和分区的详细信息 df -h # 查看硬盘使用情况 lsblk # 查看硬盘和分区情况 查看交换分区 swapon -s # 查看所有交换分区 查看网络信息 ifconfig -a 查看某个网络接口的详细信息 ethtool enp1s0 查看网卡硬件信息 lspci | grep -i 'eth' 查看usb信息 lsusb lsusb -v # 详细的信息 查看pci信息 即主板所有硬件槽信息 lspci lspci -v # 更详细的信息 查看bios信息 dmidecode -t bios 查看所有硬件信息 dmidecode –q # dmidecode桌面管理接口 正则表达式 grep可以找出符合某个模式（Pattern）的一类字符串。例如找出所有符合yyy.yyy.yyy.yyy模式的字符串（也就是IP地址），要求y是0-9的数字，IP地址的每一部分可以有1-3个y字符。 规定一些特殊语法表示字符类、数量限定符和位置关系，然后用这些特殊语法和普通字符一起表示一个模式，这就是正则表达式（Regular Expression）。例如email地址的正则表达式可以写成[a-zA-Z0-9.-]+@[a-zA-Z0-9.-]+.[a-zA-Z0-9_.-]+，IP地址的正则表达式可以写成[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}。例如有这样一个文本文件testfile： testfile 192.168.1.1 1234.234.04.5678 123.4234.045.678 abcde $ egrep '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}' testfile 192.168.1.1 1234.234.04.5678 # 234.234.04.5678部分符合 ==egrep==相当于==grep -E==，表示采用Extended正则表达式语法。grep的正则表达式有Basic和Extended两种规范，它们之间的区别下一节再解释。另外还有fgrep命令，相当于grep -F，表示只搜索固定字符串而不搜索正则表达式模式，不会按正则表达式的语法解释后面的参数。 注意正则表达式参数用单引号括起来了，因为正则表达式中用到的很多特殊字符在Shell中也有特殊含义，只有用单引号括起来才能保证这些字符原封不动地传给grep命令，而不会被Shell解释掉。 192.168.1.1符合上述模式，由三个.隔开的四段组成，每段都是1到3个数字，所以这一行被找出来了，可为什么1234.234.04.5678也被找出来了呢？因为grep找的是包含某一模式的行，这一行包含一个符合模式的字符串234.234.04.567。相反，123.4234.045.678这一行不包含符合模式的字符串，所以不会被找出来。 grep是一种查找过滤工具，正则表达式在grep中用来查找符合模式的字符串。几乎所有这些语言都支持正则表达式。除了编程语言之外，很多UNIX命令和工具也都支持正则表达式，例如grep，vi，sed，awk，emacs等等。 基本语法 我们知道C的变量和Shell脚本变量的定义和使用方法很不相同，表达能力也不相同，C的变量有各种类型，而Shell脚本变量都是字符串。同样道理，各种工具和编程语言所使用的正则表达式规范的语法并不相同，有的正则表达式规范引入很多扩展，能表达更复杂的模式，但各种正则表达式规范的基本概念都是相通的。本节介绍egrep(1)所使用的正则表达式，它大致上符合POSIX正则表达式规范，详见regex(7)。 匹配单个字符 字符 功能 举例 . 匹配任意1个字符（除了\\n） a.c可以匹配abc，a8c等 [ ] 匹配[ ]中列举的字符 [abc]d 可以匹配ad，bd，cd等 [-] 匹配[ ]中列举的字符范围 [1-9]d 可以匹配1d，3d等[1-9a-zA-Z]d 可以匹配3d，ad，Ad等[a-z] 匹配所有的小写字母 [A-Z] 匹配所有的大写字母 [a-zA-Z] 匹配所有的字母 [0-9] 匹配所有的数字 [0-9.-] 匹配所有的数字，句号和减号 [ \\f\\r\\t\\n] 匹配所有的白字符 排除匹配[ ]中列举的字符 [ ^xyz]d 匹配除xyz之外的任意字符，可以匹配3d，ad，不匹配xd，yd，zd \\d 匹配数字，即0-9 Num\\d可以匹配Num0，Num9等 \\D 匹配非数字，即不是数字 \\s 匹配空白符，即 空格，tab键 \\S 匹配非空白 \\n 匹配一个换行符 \\t 匹配一个制表符 \\w 匹配单词字符，即a-z，A-Z，0-9，_，汉字 \\W 匹配非单词字符 匹配多个字符 字符 功能 举例 ? 匹配前一个字符出现0次或者1次，即至多有1次 [1-9]?[0-9]，可以匹配7,77 + 匹配前一个字符出现1次或者无限次，即至少有1次 [a-zA-Z]+，可以匹配Aab * 匹配前一个字符出现0次或者无限次，即可有可无 [A-Z][a-z]*，可以匹配Aabcdef {m} 匹配前一个字符出现m次 [a-zA-Z0-9_]{4}，可以匹配1234 {m,n} 匹配前一个字符出现从m到n次 [a-zA-Z0-9_]{8,20} 匹配开头结尾 字符 功能 举例 ^ 匹配字符串开头 ^once，可以匹配once time^\\d表示必须以数字开头 $ 匹配字符串结尾 [\\w]{4,20}@163\\.com$，可以匹配xiaoWang@163.com^bucket$，只匹配字符串\"bucket\"\\d$表示必须以数字结束 \\b 描述单词的前或后边界 \\B 表示非单词边界 匹配分组 字符 功能 举例 \\ 匹配左右任意一个表达式 `[1-9]?\\d$ 100`，可以匹配0-100之间 () 将括号中字符作为一个分组 \\num 引用分组num匹配到的字符串 )>)>.*可以匹配hello (?P) 分组起别名 (?P=name) 引用别名为name分组匹配到的字符串 \\w)>\\w)>.*可以匹配hello (?P) 字符类 数量限定符 再次注意grep找的是包含某一模式的行，而不是完全匹配某一模式的行。 例如有如下文本testfile： aaabc aad efg 查找a*这个模式的结果。会发现，三行都被找了出来。 $ egrep 'a*' testfile aaabc aad efg a匹配0个或多个a，而第三行包含0个a，所以也包含了这一模式。单独用a这样的正则表达式做查找没什么意义，一般是把a*作为正则表达式的一部分来用。 位置限定符 位置限定符可以帮助grep更准确地查找。 例如有如下文本testfile： 192.168.1.1 1234.234.04.5678 ab2.168.1.1 1234.234.04.edc.33 用^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$查找IP，就可以把1234.234.04.5678这一行过滤掉了。 $ egrep '^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$' testfile 192.168.1.1 其它特殊字符 Extended正则 以上介绍的是grep正则表达式的Extended规范，Basic规范也有这些语法，只是字符?+{}|()应解释为普通字符，要表示上述特殊含义则需要加\\转义。如果用grep而不是egrep，并且不加-E参数，则应该遵照Basic规范来写正则表达式。 字符串处理 grep Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。 grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。 grep [options] -c：只输出匹配行的计数。 -i：不区分大小写。 -r : 递归搜索子目录 -h：查询多文件时不显示文件名。 -l：查询多文件时只输出包含匹配字符的文件名。 ==-n==：显示匹配行及 行号。 -s：不显示不存在或无匹配文本的错误信息。 -v：显示不包含匹配文本的所有行。 --color=auto ：可以将找到的关键词部分加上颜色的显示。 pattern正则表达式主要参数: \\： 忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 $: 匹配正则表达式的结束行。 \\ >：到匹配正则表达式的行结束。 ：单个字符，如[A]即A符合要求 。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。 .：所有的单个字符。 *：所有字符，长度可以为0。 grep命令使用简单实例 $ grep ‘and’ ./LICENSE* $ grep ‘and’ LICENSE* 显示当前目录下所有以LICENSE开头的文件中包含字符串内容 and的行 $ grep ‘and’ aa.txt bb.txt cc.txt 显示在当前目录下aa.txt，bb.txt，cc.txt文件中匹配字符串内容and的行。 $ grep ‘[a-z]\\{5\\}’ aa.txt # 正则匹配 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。 $ grep ‘w\\(es\\)t.*\\1′ aa 如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.)，这些字符后面紧跟着 另外一个es(\\1)，找到就显示该行。如果用egrep或grep -E，就不用”\\”号进行转义，直接写成’w(es)t.\\1′就可以了。 明确要求搜索子目录： grep -r 或忽略子目录 grep -d skip 如果有很多输出时，您可以通过管道将其转到’less’上阅读： $ grep magic /usr/src/Linux/Documentation/* | less 有一点要注意，您必需提供一个文件过滤方式(搜索全部文件的话用 *)。如果您忘了，’grep’会一直等着，直到该程序被中断。如果您遇到了这样的情况，按 ，然后再试。 下面还有一些有意思的命令行参数： grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写 grep -l pattern files ：只列出匹配的文件名 grep -L pattern files ：列出不匹配的文件名 grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’) grep -C number pattern files ：匹配的上下文分别显示[number]行 grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行 例如：grep \"abc\\|xyz\" testfile 表示过滤包含abc或xyz的行 grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行 grep -n pattern files 即可显示行号信息 grep -c pattern files 即可查找总行数 还有些用于搜索的特殊符号：\\ 分别标注单词的开始与结尾。 例如： grep man * 会匹配 ‘Batman’、’manic’、’man’等 grep ‘\\’ * 匹配’Batman’和’man’，但不是’manic’ grep ‘\\’ 只匹配’man’，而不是’Batman’或’manic’等其他的字符串 find 由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只要你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 find 命令格式 find pathname -options [-print -exec -ok ...] find命令的参数； pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录，递归查找。 -print： find命令将匹配的文件输出到标准输出。 ==-exec==： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {} \\;，注意{}内部无空格，和\\；之间含有一个空格分隔符。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 find命令选项 ==-name== 按照文件名查找文件。 -perm 按照文件权限来查找文件。 -prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。 -user 按照文件属主来查找文件。 -group 按照文件所属的组来查找文件。 -mtime -n +n 按照文件的更改时间来查找文件，-n表示文件更改时间距现在n天以内，+n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。 -nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。 -nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。 -newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。 -type 查找某一类型的文件，诸如： b - 块设备文件。 d - 目录。 c - 字符设备文件。 p - 管道文件。 l - 符号链接文件。 f - 普通文件。 ==-size== n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。 -depth 在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。 -fstype 查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。 -mount 在查找文件时不跨越文件系统mount点。 -follow 如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 exec / ok 使用exec或ok来执行shell命令 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的。 在有些操作系统中只允许-exec选项执行诸如ls或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\\，最后是一个分号; 。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 例如：为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中 $ find . -type f -exec ls -l {} \\; 上面的例子中，find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。 在/logs目录中查找更改时间在5日以前的文件并显示它们： $ find logs -type f -mtime +5 -exec ls {} \\; 记住：在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。 在下面的例子中， find命令在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 $ find . -name \"*.conf\" -mtime +5 -ok rm {} \\; 按y键删除文件，按n键不删除。 任何形式的命令都可以在-exec选项中使用。 在下面的例子中我们使用grep命令。find命令首先匹配所有文件名为“ passwd*”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个itcast用户。 # find /etc -name \"passwd*\" -exec grep \"itcast\" {} \\; itcast:x:1000:1000::/home/itcast:/bin/bash find命令的例子； 1、 查找当前用户主目录下的所有文件： 下面两种方法都可以使用 $ find $HOME -print $ find ~ -print 2、 让当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件； $ find . -type f -perm 644 -exec ls -l {} \\; 3、 为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径； $ find / -type f -size 0 -exec ls -l {} \\; 4、 查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们； $ find /var/logs -type f -mtime +7 -ok rm {} \\; 5、 为了查找系统中所有属于root组的文件； $find . -group root -exec ls -l {} \\; 6、 find命令将删除当目录中访问时间在7日以来、含有数字后缀的admin.log文件。 该命令只检查三位数字，所以相应文件的后缀不要超过999。先建几个admin.log*的文件 ，才能使用下面这个命令 $ find . -name \"admin.log[0-9][0-9][0-9]\" -atime -7 -ok rm {} \\; 7、 为了查找当前文件系统中的所有目录并排序； $ find ./ -type d | sort | xargs xargs - build and execute command lines from standard input 在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现 溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。 find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。不像-exec选项那样一次获取全部文件。 在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 来看看xargs命令是如何同find命令一起使用的，并给出一些例子。 下面的例子查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件(file关键子) $ find ./ -type f -print | xargs file 在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限： $ find . -perm -7 -print | xargs chmod o-w 用grep命令在所有的普通文件中搜索hello这个词： $ find . -type f -print | xargs grep \"hello\" 用grep命令在当前目录下的所有普通文件中搜索hello这个词： $ find . -name \\* -type f -print | xargs grep \"hello\" 注意，在上面的例子中， \\用来取消find命令中的*在shell中的特殊含义。 find命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。 find 命令的参数例子 下面是find一些常用参数的例子，有用到的时候查查就行了，也可以用man。 1、 使用name选项 文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。 可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。 不管当前路径是什么，如果想要在自己的根目录HOME中查找文件名符合∗.txt的文件，使用‘~’作为 ‘pathname’ 的参数，波浪号代表了你的HOME目录。 $ find ~ -name \"*.txt\" -print 想要在当前目录及子目录中查找所有的‘ *.txt’文件，可以用： $ find . -name \"*.txt\" -print 想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用： $ find . -name \"[A-Z]*\" -print 想要在/etc目录中查找文件名以host开头的文件，可以用： $ find /etc -name \"host*\" -print 想要查找$HOME目录中的文件，可以用： $ find ~ -name \"*\" -print 或find . –print 要想让系统高负荷运行，就从根目录开始查找所有的文件： $ find / -name \"*\" -print 如果想在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是.txt的文件，下面的命令就能够返回例如名为ax37.txt的文件： $find . -name \"[a-z][a-z][0-9][0-9].txt\" -print 2、 用perm选项 按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。 如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用： $ find . -perm 755 -print 还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-006相当于666 # ls -l # find . -perm 006 # find . -perm -006 -perm mode:文件许可正好符合mode -perm +mode:文件许可部分符合mode -perm -mode: 文件许可完全符合mode 3、 忽略某个目录 如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略。 如果希望在/apps目录下查找文件，但不希望在/apps/bin目录下查找，可以用： $ find /apps -path \"/apps/bin\" -prune -o -print 4、 使用find查找文件的时候怎么避开某个文件目录 比如要在/home/itcast目录下查找不在dir1子目录之内的所有文件 find /home/itcast -path \"/home/itcast/dir1\" -prune -o -print 避开多个文件夹 find /home ( -path /home/itcast/f1 -o -path /home/itcast/f2 ) -prune -o -print 注意(前的\\，注意(后的空格。 5、 使用user和nouser选项 按文件属主查找文件，如在$HOME目录中查找文件属主为itcast的文件，可以用： $ find ~ -user itcast -print 在/etc目录下查找文件属主为uucp的文件： $ find /etc -user uucp -print 为了查找属主帐户已经被删除的文件，可以使用-nouser选项。这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名；find命令能够为你完成相应的工作。 例如，希望在/home目录下查找所有的这类文件，可以用： $ find /home -nouser -print 6、 使用group和nogroup选项 就像user和nouser选项一样，针对文件所属于的用户组， find命令也具有同样的选项，为了在/apps目录下查找属于itcast用户组的文件，可以用： $ find /apps -group itcast -print 要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件 $ find / -nogroup -print 7、 按照更改时间或访问时间等查找文件 如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。 用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 希望在系统根目录下查找更改时间在5日以内的文件，可以用： $ find / -mtime -5 -print 为了在/var/adm目录下查找更改时间在3日以前的文件，可以用： $ find /var/adm -mtime +3 -print 8、 查找比某个文件新或旧的文件 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项。它的一般形式为： newest_file_name ! oldest_file_name 其中，！是逻辑非符号。 9、 使用type选项 在/etc目录下查找所有的目录，可以用： $ find /etc -type d -print 在当前目录下查找除目录以外的所有类型的文件，可以用： $ find . ! -type d -print 在/etc目录下查找所有的符号链接文件，可以用 $ find /etc -type l -print 10、 使用size选项 可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为N c；以块计量文件长度只用数字表示即可。 在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。 在当前目录下查找文件长度大于1 M字节的文件： $ find . -size +1000000c -print 在/home/apache目录下查找文件长度恰好为100字节的文件： $ find /home/apache -size 100c -print 在当前目录下查找长度超过10块的文件（一块等于512字节）： $ find . -size +10 -print 11、 使用depth选项 在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。 在下面的例子中， find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。 它将首先匹配所有的文件然后再进入子目录中查找。 $ find / -name \"CON.FILE\" -depth -print 12、 使用mount选项 在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件： $ find . -name \"*.XC\" -mount -print sed sed意为流编辑器（Stream Editor），在Shell脚本和Makefile中作为过滤器使用非常普遍，也就是把前一个程序的输出引入sed的输入，经过一系列编辑命令转换为另一种格式输出。sed和vi都源于早期UNIX的ed工具，所以很多sed命令和vi的末行命令是相同的。 sed命令行的基本格式为 sed option 'script' file1 file2 ... sed option -f scriptfile file1 file2 ... --version 显示sed版本。 --help 显示帮助文档。 -n,--quiet,--silent 静默输出，默认情况下，sed程序在所有的脚本指令执行完毕后，将自动打印模式空间中的内容，这些选项可以屏蔽自动打印。 -e script 允许多个脚本指令被执行。 -f script-file, --file=script-file 从文件中读取脚本指令，对编写自动脚本程序来说很棒！ -i,--in-place 直接修改源文件，经过脚本指令处理后的内容将被输出至源文件（源文件被修改）慎用！ -l N, --line-length=N 该选项指定l指令可以输出的行长度，l指令用于输出非打印字符。 --posix 禁用GNU sed扩展功能。 -r, --regexp-extended 在脚本指令中使用扩展正则表达式 -s, --separate 默认情况下，sed将把命令行指定的多个文件名作为一个长的连续的输入流。而GNU sed则允许把他们当作单独的文件，这样如正则表达式则不进行跨文件匹配。 -u, --unbuffered 最低限度的缓存输入与输出。 以上仅是sed程序本身的选项功能说明，至于具体的脚本指令（即对文件内容做的操作）后面我们会详细描述，这里就简单介绍几个脚本指令操作作为sed程序的例子。 a, append 追加 i, insert 插入 d, delete 删除 s, substitution 替换 如：$ sed \"2a itcast\" ./testfile 在输出testfile内容的第二行后添加\"itcast\"。 $ sed \"2,5d\" testfile sed处理的文件既可以由标准输入重定向得到，也可以当命令行参数传入，命令行参数可以一次传入多个文件，sed会依次处理。sed的编辑命令可以直接当命令行参数传入，也可以写成一个脚本文件然后用-f参数指定，编辑命令的格式为： /pattern/action 其中pattern是正则表达式，action是编辑操作。sed程序一行一行读出待处理文件，如果某一行与pattern匹配，则执行相应的action，如果一条命令没有pattern而只有action，这个action将作用于待处理文件的每一行。 常用sed命令 /pattern/p 打印匹配pattern的行 /pattern/d 删除匹配pattern的行 /pattern/s/pattern1/pattern2/ 查找符合pattern的行，将该行第一个匹配pattern1的字符串替换为pattern2 /pattern/s/pattern1/pattern2/g 查找符合pattern的行，将该行所有匹配pattern1的字符串替换为pattern2 使用p命令需要注意，sed是把待处理文件的内容连同处理结果一起输出到标准输出的，因此p命令表示除了把文件内容打印出来之外还额外打印一遍匹配pattern的行。比如一个文件testfile的内容是 testfile 123 abc 456 打印其中包含abc的行 $ sed '/abc/p' testfile 123 abc abc 456 要想只输出处理结果，应加上-n选项，这种用法相当于grep命令 $ sed -n '/abc/p' testfile abc 使用d命令就不需要-n参数了，比如删除含有abc的行 $ sed '/abc/d' testfile 123 456 注意，sed命令不会修改原文件，删除命令只表示某些行不打印输出，而不是从原文件中删去。 使用查找替换命令时，可以把匹配pattern1的字符串复制到pattern2中，比如： $ sed 's/bc/-&-/' testfile 123 a-bc- 456 pattern2中的&表示原文件的当前行中与pattern1相匹配的字符串 再比如： $ sed 's/\\([0-9]\\)\\([0-9]\\)/-\\1-~\\2~/' testfile -1-~2~3 abc -4-~5~6 pattern2中的\\1表示与pattern1的第一个()括号相匹配的内容，\\2表示与pattern1的第二个()括号相匹配的内容。sed默认使用Basic正则表达式规范，如果指定了-r选项则使用Extended规范，那么()括号就不必转义了。如： sed -r 's/([0-9])([0-9])/-\\1-~\\2~/' out.sh 替换结束后，所有行，含有连续数字的第一个数字前后都添加了“-”号；第二个数字前后都添加了“~”号。 可以一次指定多条不同的替换命令，用“;”隔开： $ sed 's/yes/no/;s/static/dhcp/' ./testfile 注：使用分号隔开指令。 也可以使用 -e 参数来指定不同的替换命令，有几个替换命令需添加几个 -e 参数： $ sed -e 's/yes/no/' -e 's/static/dhcp/' testfile 注：使用-e选项。 如果testfile的内容是 testfile Hello World Welcome to the world of regexp! 现在要去掉所有的HTML标签，使输出结果为： Hello World Welcome to the world of regexp! 怎么做呢？如果用下面的命令 $ sed 's/>//g' testfile 结果是两个空行，把所有字符都过滤掉了。这是因为，正则表达式中的数量限定符会匹配尽可能长的字符串，这称为贪心的(Greedy)。比如sed在处理第一行时，>匹配的并不是或这样的标签，而是 Hello World 这样一整行，因为这一行开头是。那么这条命令怎么改才对呢？留给同学们思考练习。 awk sed以行为单位处理文件，awk比sed强的地方在于不仅能以行为单位还能以列为单位处理文件。awk缺省的行分隔符是换行，缺省的列分隔符是连续的空格和Tab，但是行分隔符和列分隔符都可以自定义，比如/etc/passwd文件的每一行有若干个字段，字段之间以:分隔，就可以重新定义awk的列分隔符为:并以列为单位处理这个文件。awk实际上是一门很复杂的脚本语言，还有像C语言一样的分支和循环结构，但是基本用法和sed类似，awk命令行的基本形式为： awk option 'script' file1 file2 ... awk option -f scriptfile file1 file2 ... 和sed一样，awk处理的文件既可以由标准输入重定向得到，也可以当命令行参数传入，编辑命令可以直接当命令行参数传入，也可以用-f参数指定一个脚本文件，编辑命令的格式为： /pattern/{actions} condition{actions} 和sed类似，pattern是正则表达式，actions是一系列操作。awk程序一行一行读出待处理文件，如果某一行与pattern匹配，或者满足condition条件，则执行相应的actions，如果一条awk命令只有actions部分，则actions作用于待处理文件的每一行。比如文件testfile的内容表示某商店的库存量： ProductA 30 ProductB 76 ProductC 55 打印每一行的第二列: $ awk '{print $2;}' testfile 30 76 55 自动变量$1、$2分别表示第一列、第二列等，类似于Shell脚本的位置参数，而$0表示整个当前行。再比如，如果某种产品的库存量低于75则在行末标注需要订货： $ awk '$2=75 {print $0;}' testfile ProductA 30 REORDER ProductB 76 ProductC 55 REORDER 可见awk也有和C语言非常相似的printf函数。awk命令的condition部分还可以是两个特殊的condition－BEGIN和END，对于每个待处理文件，BEGIN后面的actions在处理整个文件之前执行一次，END后面的actions在整个文件处理完之后执行一次。 awk命令可以像C语言一样使用变量（但不需要定义变量），比如统计一个文件中的空行数 $ awk '/^ *$/ {x=x+1;} END {print x;}' testfile 就像Shell的环境变量一样，有些awk变量是预定义的有特殊含义的： awk常用的内建变量 FILENAME 当前输入文件的文件名，该变量是只读的 NR 当前行的行号，该变量是只读的，R代表record NF 当前行所拥有的列数，该变量是只读的，F代表field OFS 输出格式的列分隔符，缺省是空格 FS 输入文件的列分融符，缺省是连续的空格和Tab ORS 输出格式的行分隔符，缺省是换行符 RS 输入文件的行分隔符，缺省是换行符 例如打印系统中的用户帐号列表 $ awk 'BEGIN {FS=\":\"} {print $1;}' /etc/passwd awk也可以像C语言一样使用if/else、while、for控制结构。可自行扩展学习。 压缩与解压 拓展名 压缩 解压 .zip ==zip== FileName.zip DirName ==unzip== file.zip .rar ==rar a== FileName.rar DirName ==unrar e== FileName.rar .Z compress FileName uncompress FileName.Z .tar tar cvf xxx.tar DirName tar xvf xxx.tar .gz ==gzip== FileName ==gunzip== file.gzgzip -d FileName.gz .bz2 ==bzip2== FileName ==bunzip2== file.bz2 bzip2 -d FileName.bz2 .tar.gz / .tgz ==tar zcvf== FileName.tar.gz DirName ==tar zxvf== file.tar.gz .tar.bz2 tar jcvf FileName.tar.bz2 DirName tar xvIf file.tar.bz2 tar 打包 tar 对应英文： 作用：打包文件 tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。tar命令chan常用于备份文件，此命令可以把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件 打包文件 tar -cvf 打包名.tar 被打包的文件路径 # 打包 tar -cvf bak.tar a1.py b2.py c3.py # 打包多个文件到一个tar包 tar -cvf bak.tar a1.py --exclude *.log # 打包文件排除指定文件 tar -zcvf 打包名.tar.gz 被压缩的文件/路径... # 打包并gzip压缩文件 tar -jcvf 打包名.tar.gz 被压缩的文件/路径... # 打包并bzip2压缩文件 tar -uvf bak.tar a1.py # 更新原来tar包中的文件 tar -rvf sysconfig.tar append/ # 将目录append/目录下的文件追加到文件sysconfig.tar文件中去 tar -N \"2019/11/11\" -zcvf log17.tar.gz test # 比某个日期新的文件才被打包 tar -tvf sysconfig.tar　　# 查看文件sysconfig.tar包里的所有文件目录 # 打包备份系统文件 sudo tar -zcvf sysconfig.tar.gz /etc/ --same-permissions --same-owner # 保持原有的权限和owner -c：--create创建打包文件 -v：列出归档解档的详细过程，显示指令执行过程 -f：指定归档文件名称xxx.tar，-f是必须的，-f后面一定是.tar文件，所以-f必须放到最后 -z：自动调用g==z==ip命令 -j：自动调用bzip2命令 -Z或--compress或--uncompress自动调用compress压缩文件 --exclude：tar打包时，排除某些子目录或者指定文件，自动递归查找？？ -N或--newer= 只将较指定日期后更新的文件保存到备份文件里 -u：或--update 仅将较新的文件更新到存档中 -r：或--append 追加新增文件到已存在的备份文件的结尾部分 -A：或--catenate 将一存档与已有的存档合并 --delete：从tar包中删除指定的文件 -t：或--list 列出tar包的所有文件目录 -d：或--diff, --compare 比较存档与当前文件的不同之处 --remove-files：建立存档后删除源文件 --totals：备份文件建立后，列出文件大小。 ==自动递归==打包所有子目录 打包的文件若是多个文件，用空格分开 解包文件 tar -xvf 打包文件名.tar # 解包 tar -zxvf 打包文件名.tar.gz # 解包并解压缩gzip文件 tar -jxvf 打包文件名.tar.bz2 # 解包并解压缩bzip2文件 # 解压到指定目录 tar -zxvf 打包文件名.tar.gz -C 解压目录 # 解包并解压缩gzip文件到指定目录 # 解包备份系统文件 sudo tar -zxvf sysconfig.tar.gz --same-permissions --same-owner # 保持原有的权限和owner -x：解开档案文件 -C：--directory= 解包到指定的目录 ==--same-owner==：尝试以相同的文件拥有者还原文件 ==--same-permissions==或==-p==：用原来的文件权限还原文件 --same-order或-s：还原文件的顺序和备份文件内的存放顺序相同 ==-k==：或--keep-old-files 解开备份文件时，保存已有文件，不覆盖已有的文件,(默认覆盖) -m或--modification-time 还原文件时，不变更文件的更改时间 默认解包到当前目录 一般在打包或解包文件时==-cvf==或==-xvf==是必须输入的 gzip 压缩 gzip 对应英文： 作用：压缩解压文件 只压缩 gzip 需要压缩的文件 # 压缩后，不保留原文件 gzip -k 需要压缩的文件 # 压缩后，保留原文件 -k --keep 压缩或者解压过程中，保留原文件 不能对目录进行压缩 gzip file1.txt file2.txt分别压缩多个文件，用空格分隔,压缩之后各自分开的 只解压 gunzip 需解压的文件 # 解压.gz文件 gzip -dv 需解压的文件 # 解压.gz文件，并列出详细信息 -d: --decompress 解开压缩文件 -v : --verbose 显示指令执行过程 tar 只负责打包文件，但不压缩,用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz 如果想在建立tar文件时就压缩加一个==-z==选项就行，解压缩也只用在tar解包命令下多加一个==-z==就行（如：tar -zcvf py.tar.gz *） 打包并压缩文件 tar -zcvf 打包文件.tar.gz 被压缩的文件／路径... # 打包并压缩文件 自动递归打包所有子目录 解包并解压缩文件 tar -zxvf 打包文件.tar.gz # 解包并解压缩文件 tar -zxvf 打包文件.tar.gz -C 目标路径 # 解压缩到指定路径 -C解压到指定路径 zcat 查看压缩日志 zcat test.py # 查看压缩日志 bzip2 压缩 bzip2 对应英文：作用：压缩文件（和gzip相似） # 只压缩 bzip2 需要压缩的文件 bzip2 -k 需要压缩的文件 # 保留源文件 # 只解压 bunzip2 FileName.bz2 bzip2 -d FileName.bz2 -k --keep 压缩或者解压过程中，保留原文件 如果想在建立tar文件时就压缩加一个==-j==选项就行，解压缩也只用在tar解包命令下多加一个==-j==就行（如：tar -jcvf py.tar.bz2 *） # 打包并压缩文件 tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径... # 打包并解压缩文件 tar -jxvf 打包文件.tar.bz2 -C选项可以解压到指定路径：tar -jxvf 打包文件.tar.bz2 -C 目标路径） zip 压缩 zip命令为打包压缩命令，一般为了更windows交互才会用的，不涉及windows推荐使用tar配合gzip,bzip2,xz 压缩文件，必须指明压缩后的.zip文件名，若压缩包已经存在则更新压缩包，结果与重新压缩相同 只压缩 # 压缩文件 zip test.zip test.txt # 压缩文件，生成压缩包 zip -m test.zip test1.txt # 移动文件到压缩包，删除源文件 zip -d test.zip test.txt # 从压缩包中删除test.txt # 压缩目录 zip -r test2.zip test2/ # 打包目录，包含其子目录 zip test2.zip test2/ # 打包目录而不包含其子目录下的文件，忽略其子目录（不推荐） zip -r test.zip ./* # 压缩当前全部文件到test.zip zip test3.zip tests/* -x tests/ln.log # 压缩目录,除了tests/ln.log # 设置密码 zip -r test.zip ./* -e #交互设置密码(安全) zip -r test.zip ./* -P 123 #设置密码(明文设置密码不太安全) # 设置压缩比 #-0不压缩，-9最高压缩，默认为-6 zip test.zip test.txt -6 ==-m== : (move)把文件移到压缩文件中，即将文件压缩包后，删除原始文件 -d : (delet)从压缩文件内删除指定的文件 ==-r== : ==递归==处理，所有文件和子目录一并处理，对目录打包 -x : 压缩时排除的文件 -v : (view)显示指令执行过程 -q : (quiet)不显示指令执行过程 -c 替每个被压缩的文件加上注释 -z 替压缩文件加上注释 -e 交互设置密码 -P 直接设置密码 -0-9 : 压缩效率是一个介于1-9的数值 只解压 unzip xxx.zip # 解压.zip文件到当前目录 unzip xxx.zip -d /home/chao/ # 解压到/home/chao/目录下 -d : 解压到指定目录下 ==-o== : 解压缩时==覆盖==原有的文件 ==-n== : 解压缩时==不要覆盖==原有的文件 -f 更新现有的文件 -u 与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中 [文件] : 指定要处理.zip压缩文件中的哪些文件 -x : 解压时排除的文件 -v : (view)执行是时显示详细的信息 -q : (quiet)不显示指令执行过程 -l : 显示压缩文件内所包含的文件 -t：检查压缩文件的完整性 rar压缩 rar a 压缩文件名 压缩的源文件 rar a -r 压缩文件名 压缩的源目录 a 添加文件到操作文档 r 递归子目录 打包的生成的新文件不需要指定后缀 rar x newdir.rar rar x all.rar 指定目录 # 解压到指定目录 x 带路径解压文档中内容到当前目录 软件包管理 apt-get软件管理 apt 对应英文：Advanced Packaging Tool（高级包工具） 作用:安装/卸载软件 安装软件 sudo apt-get install # 安装包 sudo apt-get install --reinstall # 重新安装包 sudo apt-get -f install # 修复安装 sudo apt-get build-dep # 安装相关的编译环境 sudo apt-get source # 下载该包的源代码 #安装deb软件包 # sudo dpkg -i 卸载软件 sudo apt-get remove # 卸载包 sudo apt-get --purge remove # 卸载已安装的软件包，同时清除配置 sudo apt-get autoclean # 清理无用过时的软件包 sudo apt-get autoremove # 自动卸载不需要的软件 sudo apt-get autoremove --purge # 自动卸载不需要的包及其依赖的软件包+配置文件 #卸载deb软件包 # sudo dpkg -r 更新包索引 sudo apt-get update # 更新源 升级有可用更新 sudo apt-get upgrade # 更新已安装的包 升级系统 sudo apt-get dist-upgrade # 升级系统 已安装软件 sudo apt list --installed # 查看所有已安装的软件 sudo dpkg -l # 查看所有已安装的软件 sudo apt list --installed sougou* # 查找已安装的软件全名 sudo dpkg -l sougou* # 查找已安装的软件全名 查询软件信息 #apt-cache 加上不同的子命令和参数的使用可以实现查找,显示软件,包信息及包信赖关系等功能 sudo apt-cache search # 搜索软件包 sudo apt-cache show # 获取包的详细信息，如说明、大小、版本等 sudo apt-cache depends package # 了解使用该包依赖那些包 sudo apt-cache rdepends package # 查看该包被哪些包依赖 sudo apt-get check # 检查是否有损坏的依赖 列出更多命令和选项 sudo apt-get help dpkg包管理工具 dpkg -i 手动安装Debian软件包 dpkg -r 卸载软件包,保留配置文件 dpkg -P 完全清除一个已安装的包，删除所有的配制文件 dpkg -l 列出当前系统中所有的包 dpkg -L 查询系统中已安装的软件包所安装的位置 dpkg -s 查询已安装的包的详细信息 dpkg -S 查询系统中某个文件属于哪个软件包. dpkg -reconfigure 重新配置一个已经安装的包 安装deb包 （Debian软件包格式的文件扩展名） 安装deb软件包，sudo dpkg -i 卸载deb软件包，sudo dpkg -r 安装rpm软件包 rpm软件包转换为deb包再安装 1）安装alien程序，默认情况下Ubuntu并没有安装alien工具。 在终端输入：sudo apt-get install alien 2）将rpm文件转换为deb文件包 在终端使用管理员权限运行以下命令：sudo alien package_file.rpm 完成后会生成一个同名的package_file.deb文件 4）使用dpkg来安装转换后的软件包，在终端输入：sudo dpkg -i package_file.deb 注意：用alien转换的deb包并不能保证100%顺利安装 源码编译安装程序 对源码包进行相应的解压操作: 进入源码目录下： cd ${解压路径} 创建临时文件夹，存放编译日志等信息: mkdir build && cd build 配置软件包的编译环境：(可选) vim ./configure 进行预编译 cmake .. -DCMAKE_INSTALL_PREFIX=/usr 编译： make -j4 安装： sudo make install 注意：在进行源码编译安装前请确认已经建立好必要的编译环境，如：安装必需的Libraries、Compilers、Headers pip python包管理 一般情况 pip 对应的是 Python 2.7，pip3 对应的是 Python 3.x pip 对应的安装路径是 python2.7/site-packages，pip3 对应的安装路径是 python3.6/site-packages 安装pip sudo apt-get install python3 sudo apt-get install python3-pip 查看版本和路径 pip3 --version 升级 pip3 install --upgrade pip 安装包 pip3 install SomePackage # 最新版本 pip3 install opencv-python # 安装opencv-python pip3 install SomePackage==1.0.4 # 指定版本 pip3 install 'SomePackage>=1.0.4' # 最小版本 卸载包 pip3 uninstall SomePackage 搜索包 pip3 search SomePackage 显示安装包信息 pip3 show SomePackage # 概述信息 pip3 show --files SomePackage # 详细信息 列出已安装的包 pip3 list 查看可升级的包 pip3 list --outdated 升级包 pip3 install --upgrade SomePackage python虚拟环境管理 设置镜像源 Ubantu有一个主服务器，上面保存有所有可以安装的软件安装包，当使用apt命令安装软件时，就会去主服务器查找对应软件安装包，接着下载到本地，再进行安装 主服务器在国外，所以国内有很多镜像服务器，方便国内用户下载安装包 在Ubantu设置镜像源需要进入系统设置，点击软件和更新，在下载自选项中修改 树莓派国内软件源?? 备份源文件 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak 修改树莓派软件更新源 sudo nano /etc/apt/sources.list #deb http://raspbian.raspberrypi.org/raspbian/ stretch main contrib non-free rpi #Uncomment line below then 'apt-get update' to enable 'apt-get source' #deb-src http://raspbian.raspberrypi.org/raspbian/ stretch main contrib non-free rpi #中科大源 deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi #deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 修改树莓派系统更新源 sudo nano /etc/apt/sources.list.d/raspi.list #deb http://archive.raspberrypi.org/debian/ stretch main ui #Uncomment line below then 'apt-get update' to enable 'apt-get source' #deb-src http://archive.raspberrypi.org/debian/ stretch main ui #科大源 deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui #deb-src http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui 同步更新源 sudo apt-get update 更新升级以安装软件包 sudo apt-get upgrade wine 安装win软件 原来通过wine安装的快捷方式保存在.local/share/applications/wine目录下 命令别名 作用：相当于创建一些属于自己的自定义命令 别名机制依靠一个别名映射文件：~/.bashrc vim ~/.bashrc 添加 alias cls=‘clear’ 例如：在windows下有cls命令，在Linux下可能因为没有这个命令而不习惯清屏。现在可以通过别名机制来解决这个问题，可以自己创造出cls命令 注意：如果想新创造的命令生效，必须要重新登录当前用户。 运行模式 查看当前的运行级别 runlevel # 查看当前的运行级别 runlevel显示上次的运行级别和当前的运行级别，“N”表示没有上次的运行级别 在linux中存在一个进程：init （initialize，初始化），进程id是1。 查看进程：#ps -ef|grep init 该进程存在一个对应的配置文件：inittab（系统运行级别配置文件，位置/etc/inittab） 根据上述的描述，可以得知，Centos6.5中存在7中运行级别/模式。 0 — 表示关机级别（不要将默认的运行级别设置成这个值） 1 — 单用户模式 2 — 多用户模式，不带NFS（Network File Syetem） 3 — 示切换到命令行模式，完全的多用户模式（不带桌面的，纯命令行模式） 4 — 没有被使用的模式（被保留模式） 5 — X11，完整的图形化界面模式 6 — 表示重启级别（不要将默认的运行级别设置成这个值） 切换运行级别 init 0 # 关机 init 6 # 重启 init 3 # 示切换到命令行模式 init 5 # 切换到图形界面 这些命令其实都是调用的init进程，将数字（运行级别）传递给进程，进程去读配置文件执行对应的操作。 开机自启动服务管理 安装sysv-rc-conf sudo apt-get install sysv-rc-conf 查看服务情况 sudo sysv-rc-conf # 进入交互界面 sudo sysv-rc-conf --list # 直接打印服务列表 sysv-rc-conf --list server_name # 查看某服务启动级别 sysv-rc-conf --level 345 service_name on # 设置某服务启动级别 多条命令执行 cd ~/Desktop/ && touch test.py # 切换到桌面并新建文件(必须在第一条命令执行成功才会执行后一条命令) 权限管理 在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限 Linux系统一般将文件可存/取访问的身份分为3个类别：owner、group、others，且3种身份各有read、write、execute等权限。 在Linux中分别有读、写、执行权限： 读权限： 对于文件夹来说，读权限影响用户是否能够列出目录结构 对于文件来说，读权限影响用户是否可以查看文件内容 写权限： 对文件夹来说，写权限影响用户是否可以在文件夹下“创建/删除/复制到/移动到”文档 对于文件来说，写权限影响用户是否可以编辑文件内容 执行权限： 一般都是对于文件来说，特别脚本文件。 在Linux中分别有owner、group、others3个类别身份 Owner身份（文件所有者，默认为文档的创建者） Group身份（与文件所有者同组的用户） Others身份（其他人，相对于所有者） Root用户（超级用户） ls -l 可以查看文件夹下文件的详细信息，从左到右依次是： 文档类型: d表示文件夹、-表示文件、l表示软连接、s表示套接字 文件权限 对 文件/目录 的权限包括： | 序号 | 权限 | 英文 | 缩写 | 数字代号 | | ---- | ---- | ------ | ---- | -------- | | 01 | 读 | read | r | 4 | | 02 | 写 | write | w | 2 | | 03 | 执行 | excute | x | 1 | 文档所有者的权限情况，第2位表示读权限的情况，取值有r、-；第3位表示写权限的情况，w表示可写，-表示不可写，第4位表示执行权限的情况，取值有x、-。 与所有者同一个组的用户的权限情况， 其他用户的权限情况 权限分配中,均是rwx的三个参数组合，且位置顺序不会变化。没有对应权限就用– 代替。 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录/文件 拥有者，家目录下 文件/目录 的拥有者通常都是当前用户 组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲 大小 时间 名称 chmod 修改权限 chmod 对应英文：changemod（切换模式） 作用：修改 用户/组 对 文件/目录 的权限 ,注意点：如果想要给文档设置权限，操作者要么是root用户，要么就是文档的所有者。 chmod [选项] 权限形式 文件 -R：递归设置权限 （当文档类型为文件夹的时候） 权限形式：就是该文档需要设置的权限信息,有字母形式和数字形式两种 字母形式权限: 给谁设置： u：表示拥有者身份（user） g ：表示给所有者同组用户设置（group） o ：表示others，给其他用户设置权限 a ：表示all，给所有人（包含ugo部分）设置权限 如果在设置权限的时候不指定给谁设置，则默认给所有用户设置 权限字符： r ：读 w ：写 x ：表示执行 # -：表示没有权限 权限分配方式： +：表示给具体的用户新增权限（相对当前） -：表示删除用户的权限（相对当前） =：表示将权限设置成具体的值（注重结果）【赋值】?? 数字形式权限: 常见数字组合有（u表示用户／g表示组／o表示其他）： 777 ===> u=rwx,g=rwx,o=rwx 755 ===> u=rwx,g=rx,o=rx 644 ===> u=rw,g=r,o=r chmod -R +/-rwx 文件名/目录名 # 默认给所有用户all设置权限（+增加权限，-取消权限，rwx读写执行） chmod -R u+rwx,g+rx,o-x test.py # 分别赋予权限 chown 修改所有者 chown 对应英文：change owner（切换主人） 作用：修改文件或目录拥有者 chown [选项-R] 用户名 文件/目录名 chown 用户名 文件名|目录名 # 修改文件|目录的拥有者 chgrp -R 组名 文件名|目录名 # 递归修改文件|目录的组 chmod -R 755 文件名|目录名 # 递归修改文件权限 chmod -R username:groupname 文件名|目录名 # 同时修改所有者和所属组 ==-R==：==递归==的修改目录下所有文件 chgrp 修改所属组 chgrp 对应英文：change group（切换组） 作用：递归修改文件或者目录所属组 chgrp [选项-R] 组名 文件/目录名 ==-R==：==递归==的修改目录下所有文件 sudo 超级用户 sudo 对应英文：subtitute user do（使用另一个用户的身份） 作用：sudo预设的身份为 root,以超级用户身份执行某些操作 切换到超级用户 sudo su 退出超级用户 exit 普通用户使用超级用户权限执行命令 sudo 任何命令 sudo -l # 查看当前用户所具有的特殊权限 用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码 将用户添加到sudo用户组 将使名为 username 的用户成为 sudo 组的成员，用户就使用 sudo 命令，普通用户授予 sudo 权限 sudo usermod -a -G sudo username # sudo adduser username sudo # 普通用户授予 sudo 权限 # sudo deluser username sudo # 移除用户的 sudo 权限 a:表示添加 G：指定组名 赋予用户sudo权限 sudo 命令默认只有 root 用户可以运行，将用户名添加到sudo权限组，sudo权限配置文件/etc/sudoers，可以直接修改sudoers，也可以额使用visudo sudo visudo # 编辑sudo权限 # sudo vim /etc/sudoers 或者 #User privilege specification root ALL=(ALL:ALL) ALL # root用户 #Allow members of group sudo to execute any command %sudo ALL=(ALL:ALL) ALL # sudo用户组 chao ALL=(ALL:ALL) ALL # 给chao赋予了所有权限 #新添加一行，chao这个用户，可以使用所有的命令，使用单个命令(比如useradd)，可以将ALL改成/user/sbin/add 系统给我们提供的 2 个模板，分别用于添加用户和群组，使其能够使用 sudo 命令 root ALL=(ALL:ALL) ALL # root用户 用户名 被管理主机的地址 = （可使用的身份） 授权命令 用户管理 Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统,并且对于不同的系统资源拥有不同的使用权限,可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限。 注意三个用户管理文件： /etc/passwd 存储用户的关键信息 /etc/group 存储用户组的关键信息 /etc/shadow 存储用户的密码信息 查看所有用户信息 用户信息 用户信息储存在/etc/passwd文件下 cat /etc/passwd 用户名: x :用户代号:组代号::用户家目录:登录Shell x的意思是用户拥有密码，用户家目录前面是空的，意思为用户的全名，如果没有设置则用用户名作为用户的全名 组代号信息储存在/etc/group文件下（推荐用：cat -n /etc/group | grep 组名 方式查询） 一个用户创建时的-g选项设置的是该用户的主组，如没设置则主动创建一个和该用户名相同的组作为该用户的主组 附加组通常用来指定用户的附加权限 useradd 添加用户 useradd 对应英文：user add（添加用户） 作用：给计算机添加一个用户 useradd [选项-m] 用户名 sudo useradd -s /bin/bash -m chao # 指定shell为/bin/bash 同时创建家目录 -m：自动给该用户添加用户家目录（一般都要用这个参数，否则自己添加很麻烦） -g：指定用户所在的用户主组组，否则就会建立一个与用户同名的组 如：sudo useradd -m -g dev zhangsan（创建一个张三用户自动添加家目录并将其归属于dev组） -d： 用户家目录 -G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名 -u：uid，用户的id（用户的标识符），系统默认会从500之后按顺序分配uid，如果不想使用系统分配的，可以通过该选项自定义【类似于腾讯QQ的自选靓号情况】 -c: comment 添加注释 注意：在不添加选项的时候，执行useradd之后会，useradd只是创建了一个用户名，如 （useradd +用户名 ），它==不会在/home目录下创建同名家目录==，也没有创建同名的用户组，也没有创建密码，因此利用这个用户登录系统，是登录不了的，为了避免这样的情况出现，可以用 （useradd -m +用户名）的方式创建，它会在/home目录下创建同名文件夹，然后利用（ passwd + 用户名）为指定的用户名设置密码。 可以直接利用adduser创建新用户（adduser +用户名）这样在/home目录下会自动创建同名文件夹 注意:出现这种开头是 ==$== 而不是 用户名@主机名 开头的原因是没有指定shell为好用的/bin/bash passwd 设置密码 Linux不允许没有密码的用户登录到系统，因此前面创建的用户目前都处于锁定状态，需要设置密码之后才能登录计算机。 passwd 对应英文：password（密码） 作用：设置用户密码 passwd 用户名 sudo passwd chao # 设置chao的密码 sudo passwd root # 设置root的密码 sudo passwd # ？？ 此命令需要超级用户权限，输入该指令后控制台自动要求输入密码，在设置密码的时候也是没有任何输入提示的，确保两次输入的密码一致，按下回车即可。 用户密码文件/etc/passwd 文件格式 用户名:密码:用户ID:用户组ID:注释:家目录:解释器shell 用户名：创建新用户名称，后期登录的时候需要输入； 密码：此密码位置一般情况都是“x”，表示密码的占位； UID：用户标识； GID：组标识； 注释：用户全名或本地帐号； 家目录：用户登录进入系统之后默认的位置； 解释器shell：用户进入系统之后，用户输入指令之后，该解释器会收集用户输入的指令，传递给内核处理； 锁定用户 sudo passwd -l 用户名 # --- 锁定用户 sudo usermod -L 用户名 -l lock 锁定 解锁用户 sudo passwd -u 用户名 # --- 解锁用户 sudo usermod -U 用户名 -u unlock 解锁 查看状态 sudo passwd -S 用户名 # --- 查看状态 passwd -S 用户名 S status 状态 xxx is not in the sudoers file.This incident will be reported. 解决办法 切换到root用户下 sudo su 添加sudo文件的写权限 chmod u+w /etc/sudoers 编辑sudoers文件 vi /etc/sudoers 找到这行 root ALL=(ALL:ALL) ALL 在他下面添加 xxx ALL=(ALL:ALL) ALL (这里的xxx是你的用户名) 撤销sudoers文件写权限 chmod u-w /etc/sudoers usermod 用户配置 usermod 对应英文：user modify（修改用户） 作用：设置用户的主组或附加组和登录Shell usermod [选项] 组 用户名 usermod -g 组 用户名 # 修改用户的主组（passwd 中的 GID） usermod -G 组 用户名 # 修改用户的附加组 usermod -s /bin/bash 用户名 # 修改用户登录 Shell usermod -G sudo 用户名 # 将用户添加到 sudo 附加组中 -g：(group) 修改用户的主组 -a：(append)##把用户追加到某些组中，仅与-G选项一起使用 -G：修改用户的附加组 -s：(shell) 修改用户登入后所使用的shell -c: (备注 )修改用户帐号的备注文字。 -d: (登入dir) 修改用户登入时的目录 -e: (有效期限) 修改帐号的有效期限 -f: (缓冲天数) 修改在密码过期后多少天即关闭该帐号 -L : Lock　锁定用户密码，使密码无效 -U: Unlock　解除密码锁定 -u：uid，用户的id（用户的标识符），系统默认会从500之后按顺序分配uid，如果不想使用系统分配的，可以通过该选项自定义【类似于腾讯QQ的自选靓号情况】 -l： 　修改用户名称 usermod 修改用户名 usermod -l 新的用户名 旧的用户名 # 修改用户名 usermod 修改家目录 usermod -md /home/newhome_name usermod 修改用户登录 Shell sudo usermod -s /bin/bash 用户名 # 修改用户登录 Shell 注意:出现这种开头是 ==$== 而不是chao@deepin 的原因是没有指定shell为好用的/bin/bash usermod 锁定用户 sudo usermod -L 用户名 # --- 锁定用户 sudo passwd -l 用户名 -L Lock 锁定 usermod 解锁用户 sudo usermod -U 用户名 # --- 解锁用户 sudo passwd -u 用户名 -U Unlock 解锁 usermod 查看状态 passwd -S 用户名 # --- 查看状态 sudo passwd -S 用户名 S Status 状态 把用户添加到组 usermod -aG user_name user_group #多个组之间用空格隔开 userdel 删除用户 userdel 对应英文：user delete（删除用户） 作用：删除用户 userdel [选项] 用户名 sudo userdel itcast # 保留用户home目录 sudo userdel -r itcast # 用户的主目录一起删除 -r：删除用户的同时，删除其家目录 su 切换用户 su 对应英文 switch user , 作用：切换当前的用户 sudo su 用户名 # 切换到指定用户 sudo su xxx # 切换到xxx用户 su不指定用户名则默认切换到root用户 exit退出切换用户的登录，在用户名前加个“-”可以自动切换到该用户家目录，不加任何用户名可以切换到root 切换root之前需要先用passwd命令给root用户设置密码，否则无法登录 切换用户时需要==sudo== exit 退出用户登录 退出当前用户登录 exit exit 示意图如下： 用户组管理 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 用户组信息保存在 /etc/group 文件中 文件结构 用户组名:密码:用户组ID:组内用户名 密码：X表示占位符，虽然用户组可以设置密码，但是绝大部分的情况下不设置密码； 组内用户名：表示附加组是该组的用户名称 groupadd 添加用户组 groupadd 对应英文：group add（添加组） 作用：给计算机添加一个组 groupadd 用户组名 sudo groupadd mysql # 添加用户组mysql -g：表示选择自己设置一个自定义的用户组ID数字，如果自己不指定，则默认从500之后递增； groupmod 编辑用户组 groupmod 选项 用户组名 -g：类似用户修改里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字 -n：类似于用户修改“-l”，表示设置新的用户组的名称 groupdel 删除用户组 groupdel 对应英文：group delet(删除组) 作用：把计算机的一个组删除 groupdel 组名 注意：当如果需要删除一个组，但是这个组是某个用户的主组时，则不允许删除；如果确实需要删除，则先从组内移出所有用户。 网络配置 ifconfig 网卡 ifconfig 对应英文：configure a network inrerface（配置一个网络界面） 作用：获取修改网络接口配置信息 查看网络配置信息 ifconfig # 查看网卡配置信息 enp3s0 (ethernet以太网)表示以太网卡，enpxsx是其名称。 lo（loop，本地回环网卡，其ip地址一般都是127.0.0.1），一般用来测试本机网卡是否正常 wlp2s0: 是无线网卡 inet: 是网卡的ip地址 ether: 物理地址(MAC地址),六个字段，由五个冒号隔开 启动关闭指定网卡 ifconfig eth0 up # 启动网卡 ifconfig eth0 down # 关闭网卡 为网卡配置和删除IPv6地址 ifconfig eth0 add 33ffe:3240:800:1005::2/ 64 # 为网卡诶之IPv6地址 ifconfig eth0 del 33ffe:3240:800:1005::2/ 64 # 为网卡删除IPv6地址 用ifconfig修改MAC地址 # ifconfig eth0 down # 关闭网卡 # ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE # 修改MAC地址 # ifconfig eth0 up # 启动网卡 # ifconfig eth1 hw ether 00:1D:1C:1D:1E # 直接关闭网卡并修改MAC地址 # ifconfig eth1 up # 启动网卡 配置IP地址 ifconfig eth0 192.168.1.56 # 给eth0网卡配置IP地址 ifconfig eth0 192.168.1.56 netmask 255.255.255.0 # 给eth0网卡配置IP地址,并加上子掩码 ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255 # 给eth0网卡配置IP地址,加上子掩码,加上个广播地址 启用和关闭ARP协议 ifconfig eth0 arp # 开启 ifconfig eth0 -arp # 关闭 设置最大传输单元 ifconfig eth0 mtu 1500 # 设置能通过的最大数据包大小为 1500 bytes netstat 网络状态 查看网络连接状态 netstat -tnlp # 查看网络连接状态 netstat -an # 查看全部网络 -t：只列出tcp协议的连接； -n：将地址从字母组合转化成ip地址，将协议转化成端口号来显示； -l：只列出状态为LISTEN（监听）的连接； -p：显示进程相关信息； -a：表示全部 ping ping 对应英文：ping（无实意，取自声纳的声音） 作用：检测当前计算机到目标计算机之间的网络 是否通畅，数值越大，速度越慢（Ctrl+c停止检测） ping 主机地址（ip地址、主机名、域名等） ping IP地址 # 检测到目标主机是否连接正常 ping 127.0.0.1 # 检测本地网卡工作正常 ping localhost -c 数目：在发送指定数目的包后停止。 -i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次 ping不通虚拟机的话,将虚拟机网络改成桥接网卡或者关掉防火墙 查看网关 netstat -r # Kernel IP routing table Destination Gateway Genmask Flags MSS Window irtt Iface default 192.168.1.1 0.0.0.0 UG 0 0 0 wlp2s0 default 10.42.0.1 0.0.0.0 UG 0 0 0 enp1s0 10.42.0.0 0.0.0.0 255.255.255.0 U 0 0 0 enp1s0 172.16.135.0 0.0.0.0 255.255.255.0 U 0 0 0 vmnet1 172.16.182.0 0.0.0.0 255.255.255.0 U 0 0 0 vmnet8 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 wlp2s0 traceroute 跟踪路由 作用：查找当前主机与目标主机之间所有的网关（路由器，会给沿途各个路由器发送icmp数据包，路由器可能会不给响应）。 该命令不是内置命令，需要安装，sudo apt-get install traceroute。 traceroute 主机地址 traceroute www.baidu.com 类似于查看快递的跟踪路由： nslookup查看域名的ip nslookup 查看服务器域名对应的IP地址，一般访问网站都是使用域名，如：www.baidu.com，使用该命令就可查看百度所有服务器的IP地址 nslookup www.baidu.com # 查看百度的ip地址 Server: 202.120.127.220 Address: 202.120.127.220#53 Non-authoritative answer: www.baidu.com canonical name = www.a.shifen.com. Name: www.a.shifen.com Address: 182.61.200.6 Name: www.a.shifen.com Address: 182.61.200.7 arp 地址解析协议 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取（MAC）物理地址的协议。 当一个主机发送数据时，首先查看本机MAC地址缓存中有没有目标主机的MAC地址， 如果有就使用缓存中的结果；如果没有，ARP协议就会发出一个广播包，该广播包要求查询目标主机IP地址对应的MAC地址，拥有该IP地址的主机会发出回应，回应中包括了目标主机的MAC地址，这样发送方就得到了目标主机的MAC地址。如果目标主机不在本地子网中，则ARP解析到的MAC地址是默认网关的MAC地址。 arp -a # 查看本地缓存mac表 # arp -d 主机地址 # 删除指定的缓存记录 tcpdump 抓包 作用：抓包，抓取数据表 # tcpdump 协议 port 端口 # tcpdump 协议 port 端口 host 地址 # tcpdump -i 网卡设备名 wireshark 抓包工具 网络配置文件 网卡配置文件位置：/etc/sysconfig/network-scripts/ 在目录中网卡的配置文件名称：ifcfg-网卡名称 ONBOOT：是否开机启动 BOOTPROTO：ip地址分配方式，DHCP表示动态主机分配协议 HWADDR：硬件地址，MAC地址 重启网卡 service network restart # 重启网卡 重启单个网卡 ifdown 网卡名 # 停止某个网卡 ifup 网卡名 # 开启某个网卡 mNetAssist 网络调试助手 tcp/udp 网络调试 wireshark 网络抓包工具 sudo apt-get install wireshark # 安装wireshark 权限问题修复(添加到用户组) sudo groupadd wireshark sudo chgrp wireshark /usr/bin/dumpcap sudo chmod 4755 /usr/bin/dumpcap sudo gpasswd -a 当前登录的用户名 wireshark 文件传输 FTP / SFTP服务 FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。 在FTP的使用当中，用户经常遇到两个概念：\"下载\"（Download）和\"上传\"（Upload）。 \"下载\"文件就是从远程主机拷贝文件至自己的计算机上； \"上传\"文件就是将文件从自己的计算机中拷贝至远程主机上。 用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。 搭建vsftpd服务 （VSFTPD 的全称是 “Very Secure FTP Deamon”） 1. 安装vsftpd服务器 sudo apt-get install vsftpd vsftpd -v # 查看是否安装 ftp服务器 服务安装完毕之后，ftp服务会随开机自动启动 2. 创建共享文件夹 用于ftp上传和下载的文件夹 sudo mkdir ~/ftp mkdir ~/ftp/share # 创建一个子目录 sudo chmod 777 ~/ftp 3. 配置vsftpd sudo vi /etc/vsftpd.conf 不允许匿名登录 修改vsftpd.conf如下： # 阻止 vsftpd 在独立模式下运行 listen=NO # vsftpd 将监听 ipv6 而不是 IPv4 listen_ipv6=YES # # 关闭匿名登录 anonymous_enable=NO # # 允许本地用户登录 local_enable=YES # # 允许上传文件到ftp服务器 write_enable=YES # 本地用户新增档案时的umask 值 local_umask=022 # 当用户第一次进入新目录时显示提示消息 dirmessage_enable=YES # 显示在您的本地时区的时间目录列表 use_localtime=YES # 一个存有详细的上传和下载信息的日志文件 xferlog_enable=YES # 在服务器上针对 PORT 类型的连接使用端口 20（FTP 数据） connect_from_port_20=YES # 不单独建立ftp用户，直接使用Ubuntu桌面用户就可以登陆 chroot_local_user=YES chroot_list_enable=NO # # 能够登录ftp的用户名单 chroot_list_file=/etc/vsftpd.chroot_list # 使用uft8文件系统 utf8_filesystem=YES 在文件最后添加下列内容： # 锁定一个共享目录?? # 指定ftp上传下载目录 local_root=/home/chao/ftp # 给共享目录添加写权限 allow_writeable_chroot=YES 创建 vsftpd.chroot_list 文件 添加能够登录ftp服务器的用户名 sudo vim /etc/vsftpd.chroot_list 添加能够登录ftp服务器的用户名chao，一行一个 允许匿名登录 创建目录，供匿名用户使用？？ mkdir anonDir 修改目录权限：chmod 777 anonDir 修改配置文件：sudo gedit /etc/vsftpd.conf write_enable=YES -> 是否拥有写权限 anon_root=/home/itcast/ftp -> 匿名用户ftp根目录，默认目录：/srv/ftp/ anonymous_enable=YES -> 是否允许使用匿名用户 anon_upload_enable=YES -> 是否允许匿名用户上传权限 anon_mkdir_write_enable=YES -> 是否允许匿名用户创建目录 启动ftp服务器 重启 ftp 服务器 sudo service vsftpd restart 配置完成之后，必须重启服务器新的配置才能够生效 启动ftp服务器 service vsftpd start 查看vsftpd的状态，可以输入命令 service vsftpd status 登陆ftp服务器 实名用户登录 ftp IP地址 Name： 服务器用户名 Password： 服务器密码 登录成功，便会出现一个 ftp>的命令行，我们可以输入命令 dir,查看该用户能访问的目录，ls显示目录情况 命令pwd和lcd分别可以查看远程linux下和本地windows下的当前目录： 匿名用户登录 ​ 修改配置文件，并重启服务 ​ 指定匿名用户根目录 ​ 自己指定：比如： /home/itcast/ftp/ ​ 默认目录：/srv/ftp/ ​ anon_root=/home/itcast/ftp -> 匿名用户ftp根目录 ​ 创建目录，供匿名用户使用 ​ mkdir anonDir ​ 修改目录所有者：sudo chown ftp anonDir ​ 修改目录权限：chmod 777 anonDir ​ 二选一 ​ 修改配置文件 ​ sudo gedit（vi）/dev/vsftpd.conf ​ 重启服务器 ​ sudo service vsftpd restart ​ 登录ftp服务器 ftp 服务器IP 匿名账号：anonymous 密码：没有密码 上传下载数据 ftp 不能上传下载目录，如有需求需要打包 查看FTP文件 dir：显示服务器目录和文件列表 ls：显示服务器简易的文件列表 cd：进入服务器指定的目录 dir命令可以使用通配符“”和“?”，比如，显示当前目录中所有扩展名为jpg的文件，可使用命令 dir .jpg。 cd命令中必须带目录名。比如 cd main 表示进入当前目录下的main子目录 （一般情况下用户都会被限制目录的访问权限，只可在当前目录下进行操作） 上传文件 上传文件到ftp服务器 put somefile # 上传本地文件到ftp put filename newname # 上传后重命名 put：上传指定文件put filename [newname] send：上传指定文件send filename [newname] （filename为上传的本地文件名，newname为上传至FTP服务器上时使用的名字，如果不指定newname，文件将以原名上传。） 上传文件前，应该根据文件的类型设置传输方式，本机的工作目录也应该设置为上传文件所在的目录。 可以改变上传的文件的目录位置：cd xxx 查看当前上传位置： pwd 下载文件 ftp服务器上的文件下载到本地 get somefile # 下载ftp文件到本地 get filename newname # 下载后重命名 mget filename [filename ....] # 下载多个文件 # 在哪个目录下登录ftp服务器，文件就下载到哪个位置 上传和下载文件时应该使用正确的传输类型，FTP的传输类型分为ASCII码方式和二进制方式两种，对.txt、.htm等文件应采用ASCII码方式传输，对.exe或图片、视频、音频等文件应采用二进制方式传输。在默认情况下，FTP为ASCII码传输方式。 type：查看当前的传输方式 ascii：设定传输方式为ASCII码方式 binary：设定传输方式为二进制方式 get：下载指定文件get filename [newname] (filename为下载的FTP服务器上的文件名，newname为保存在本都计算机上时使用的名字，如果不指定newname，文件将以原名保存。 get命令下载的文件将保存在本地计算机的工作目录下。该目录是启动FTP时在盘符C:后显示的目录。如果想修改本地计算机的工作目录，可以使用 lcd 命令。比如：lcd d:\\ 表示将工作目录设定为D盘的根目录。 mget：下载多个文件mget filename [filename ....] (mget命令支持通配符\"\"和\"?\"，比如：mget .mp3 表示下载FTP服务器当前目录下的所有扩展名为mp3的文件。) 结束并退出FTP 结束与服务器的FTP会话 close 结束与服务器的FTP会话并退出FTP环境 quit exit？？ 其它FTP命令 pwd：查看FTP服务器上的当前工作目录 rename filename newfilename：重命名FTP服务器上的文件 deletefilename：删除FTP服务器上的文件 help[cmd]：显示FTP命令的帮助信息，cmd是命令名，如果不带参数，则显示所有FTP命令 filezilla图形ftp 图形界面的ftp客户端–filezilla lftp下载工具 lftp是一个ftp客户端工具， 可以上传和下载目录 软件安装 sudo apt-get install lftp 登录服务器 ​匿名 lftp 服务器ip 回车 login 实名 lftp username@127.0.0.1 回车 输入服务器密码 操作 put 上传文件 mput 上传多个文件 get 下载文件 mget 下载多个文件 mirror 下载整个目录及其子目录 mirror –R 上传整个目录及其子目录 使用scp来传输文件 scp不是FTP服务，使用该命令的前提条件要求目标主机已经成功安装openssh-server,拷贝单个文件可以不加 -r参数，拷贝目录必须要加。 (当前操作的终端为本地，不是必须先远程登录到服务器，只是运用了ssh) scp 远程复制 scp 即 ssh copy 作用：基于ssh登陆进行安全的远程文件拷贝 scp [可选参数] file_source file_target -B： 使用批处理模式（传输过程中不询问传输口令或短语） -C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p：保留原文件的修改时间，访问时间和访问权限。 -q： 不显示传输进度条。 -r： 递归复制整个目录。 -v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit： 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式， -P port：注意是大写的P, port是指定数据传输用到的端口号 -S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 scp [选项] win本地文件 user@remote:远程文件 # 上传到远程linux scp [选项] user@remote:远程文件 win本地文件 # 下载到本地win scp [选项] -ls user@remote # 列出远程路径下结构?? -P 若远程 SSH 服务器的端口不是默认 22，需要使用大写字母 -P 选项指定端口 -r 递归复制该目录下的所有子目录和文件 注意：远程文件标记: 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径 ==user@remote:远程文件== 表示远程文件,看作一个整体 从本地复制到远程 scp local_file remote_username@remote_ip:remote_folder # 或者 scp local_file remote_username@remote_ip:remote_file # 或者 scp local_file remote_ip:remote_folder # 或者 scp local_file remote_ip:remote_file #　示例 scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3 scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3 第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； 第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名； scp -r local_folder remote_username@remote_ip:remote_folder # 或者 scp -r local_folder remote_ip:remote_folder # 示例 scp -r /home/space/music/ root@www.runoob.com:/home/root/others/ scp -r /home/space/music/ www.runoob.com:/home/root/others/ 第1个指定了用户名，命令执行后需要再输入密码； 第2个没有指定用户名，命令执行后需要输入用户名和密码； 从远程复制到本地 从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可 # 示例 scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 scp -r www.runoob.com:/home/root/others/ /home/space/music/ 把本地文件拷贝到远程文件夹中(上传) scp [-P port] 本地文件名 user@remote：远程文件夹名 将本地文件夹复制到远程服务器中(上传) scp -r 本地文件夹名 user@remote：远程文件夹 scp -r 本地文件夹名 user@remote：远程文件夹 scp -r “E:\\coursedocs” root@192.168.21.128:/home 把远程文件复制到本地计算机中(下载) scp [-P port] user@remote：远程文件 本地文件名 将远程文件夹复制到到本地(下载) scp -r user@remote:远程文件夹 本地地址 scp -r user@remote:远程文件夹 本地地址 SSH用lrzsz上传下载文件？？ rz与sz上传、下载 利用SSH上传、下载（sz与rz命令） 单单是SSH客户端软件支持以上文件传输协议（ASCII,Xmodem，Ymodem,Zmodem）还不行，我们的Linux服务器上也得安装相应的软件，以支持这些文件传输协议才行。在Linux上，lrzsz就是完成此任务的,lrzsz就是一个支持 Zmodem 传输协议的工具。我们通过sz/rz两个命令，分别发送/接收文件。如果我们的系统中没有安装lrzsz这个包，就会报错，安装即可解决。zssh的全名叫ZMODEM SSH.看名字就知道，使用的zmodem，我们习惯了SecureCRT,直接就可以用来发送文件，比使用scp方便很多。 安装lszrz sudo apt-get install lrzsz // Ubuntu ＃本地客户端另外安装zssh？？(如果本地安装了ssh可不安装zssh) #sudo apt-get install zssh rz接收回来(上传) 输入rz回车后，会出现文件选择对话框，选择需要上传文件，一次可以指定多个文件（不支持直接上传目录），上传到服务器的路径为当前执行rz命令的目录。 ==ssh登陆后直接拖动文件到终端即可上传文件== ### 下载一个文件 ＃ 远程服务器发送文件(准备被本地接收) sz filename # 在服务器上,sz发送要下载的文件filename # 看到一堆乱码, 然后组合键进入zssh(切换到了本地机器目录) Ctrl + @ / Ctrl + 2 ＃ 进入zssh,切换到本地机器目录 zssh > pwd # 查看本地当前所在目路 ＃ 本地接收远程服务器刚刚发送的文件 zssh > rz　　＃ 本地接收刚刚远程发送的文件 zssh > pwd # 查看本地当前所在目路(切换到了本地机器) zssh > ls　　＃查看本地文件 zssh > cd xxx　　＃切换下载文件要保存的路径 提示:可以使用rz -y实现覆盖上传，上传窗口的默认目录可以在SSH客户端里进行设置。 sz发送出去(下载) sz 从服务端发送文件到客户端，可以直接使用sz filename实现下载，其中filename就是你想要下载的文件的名字，如果是目录需要打包成单个文件在实现下载（sz只能传输文件不能传输文件夹）。 ### 上传一个文件： # 组合键进入zssh(切换到了本地机器目录) Ctrl + @ / Ctrl + 2 ＃ 进入zssh,切换到本地机器目录 zssh > pwd # 查看本地当前所在目路(切换到了本地机器) zssh > ls　　＃查看本地文件 zssh > sz filename # (本地发送)本地文件filename上传到远程登录的当前目录 ### 上传多个文件： Ctrl + @ / Ctrl + 2 ＃ 进入zssh,切换到本地机器 zssh > sz filename1 filename2 # (本地发送)本地文件filename1,filename2上传到远程登录的当前目录 ### 下载dir目录下的所有文件，不包含mydir下的文件夹： Ctrl + @ / Ctrl + 2 ＃ 进入zssh,切换到本地机器 zssh > sz mydir/* zssh > pwd # 查看本地当前所在目路(切换到了本地机器) zssh > ls　　＃查看本地文件 zssh > cd xxx　　＃切换本地路径 覆盖参数？？ deepin终端ssh登录传输文件 右键上传文件－－选择本地要上传的文件,上传到远程的当前目录 右键下载文件－－选择本地用来保存下载文件的路径，输入远程需下载文件的绝对路径 SSH服务 SSH（secure shell，安全外壳协议），对所有传输的数据进行压缩和加密,该协议有2个常用的作用：远程连接协议、远程文件传输协议。使用SSH服务，需要安装相应的服务器和客户端。 协议==端口号==：默认是==22== 端口号可以是被修改的(0-65535)，如果需要修改，则需要修改ssh服务的配置文件：/etc/ssh/ssh_config 域名: 是 IP 地址 的别名，方便用户记忆 IP 地址：通过 IP 地址 找到网络上的计算机 端口号：通过 端口号 可以找到 计算机上运行的应用程序 常见服务端口号列表： 序号 服务 端口号 01 SSH 服务器 22 02 Web 服务器 80 03 HTTPS 443 04 FTP 服务器 21 安装ssh服务器 服务器端安装ssh服务 sudo apt-get install openssh-server SSH服务启动/停止/重启 service sshd start/stop/restart /etc/init.d/sshd start/stop/restart # 或者 Ubuntu18.04 ssh 开机自动启动的设置方法 # 开机自动启动ssh命令 sudo systemctl enable ssh # 关闭ssh开机自动启动命令 sudo systemctl disable ssh # 单次开启ssh sudo systemctl start ssh # 单次关闭ssh sudo systemctl stop ssh # 设置好后重启系统 reboot #查看ssh是否启动，看到Active: active (running)即表示成功 sudo systemctl status ssh SSH远程登录 SSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序 Linux系统默认有SSH客户端，WINDOS需要下载,常见终端工具有：Xshell、secureCRT、Putty等 使用命令建立连接,然后输入目标计算机用户密码后就可以远程管理目标计算机了 ssh [-p port] user@remote # 登录远程SSH（用户@IP地址或域名） ssh -X -p 22 pi@192.168.137.177 user是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名 port 是 SSH Server 监听的端口，如果不指定，就为默认值 22 X 可以回传图形化界面 使用exit退出当前用户的登录 root 登录报错： Permission denied (publickey,password) 设置允许root直接登录 vim /etc/ssh/sshd_config # 修改ssh配置文件 PermitRootLogin yes sudo service ssh restart # 重启 SSH ssh-keygen 生成SSH密钥 ssh-keygen 作用：在.ssh文件夹生成两个加密文件（公钥和私钥）供以后使用 ssh-keygen ssh-keygen -t rsa -t: 密钥类型, 可以选择 dsa | ecdsa | ed25519 | rsa; -f: 密钥目录位置, 默认为当前用户home路径下的.ssh隐藏目录, 也就是~/.ssh/, 同时默认密钥文件名以id_rsa开头. 如果是root用户, 则在/root/.ssh/id_rsa, 若为其他用户, 则在/home/username/.ssh/id_rsa; -C: 指定此密钥的备注信息, 需要配置多个免密登录时, 建议携带; -N: 指定此密钥对的密码, 如果指定此参数, 则命令执行过程中就不会出现交互确认密码的信息了. 举例说明: 同时指定目录位置、密码、注释信息, 就不需要输入回车键即可完成创建: ssh-keygen -t rsa -f ~/.ssh/id_rsa -N shoufeng -C shoufeng 生成过程一路回车即可，会在用户的根目录生成一个 .ssh的文件夹，会生成两个文件：id_rsa和id_rsa.put，前者是私钥，后者是公钥 id_rsa : 生成的私钥文件 id_rsa.pub ： 生成的公钥文件 authorized_keys:存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥 know_hosts : 已知的主机公钥清单 如果希望ssh公钥生效需满足至少下面两个条件： 为了让私钥文件和公钥文件能够在认证中起作用, 需要确保权限的正确性: 　1) .ssh目录的权限必须是700 　2) .ssh/authorized_keys文件权限对普通用户, 建议设置成600权限,对root用户, 建议设置成644权限 ssh-copy-id 上传公钥到服务器 ssh-copy-id 作用：加密保存目标计算机密码到ssh-keygen生成的一个文件中,可以让远程服务器记住我们的公钥 ssh-copy-id user@remote # 让远程服务器记住我们的公钥 ssh-copy-id -p port user@remote # 让远程服务器记住我们的公钥 服务器端~/.ssh目录下有一个authorized_keys，这个文件即是当前主机所含有的公钥集合； 操作正常完成后以后登录等需要密码的操作遍不需要输入密码了 SSH免密码登录 步骤 配置公钥 执行ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥 非对称加密算法 使用 公钥 加密的数据，需要使用 私钥 解密 使用 私钥 加密的数据，需要使用 公钥 解密 SSH配置别名 每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆 而 配置别名 可以让我们进一步偷懒，譬如用：ssh mymac 来替代上面这么一长串，那么就在 ~/.ssh/config 里面追加以下内容： vim ~/.ssh/config # 编辑ssh配置文件 # mymac 替换 user@remote Host mymac HostName ip地址 User itheima Port 22 保存之后，即可用 ssh mymac 实现远程登录了，scp mymac同样可以使用 设置ip地址别名？？ /etc/hosts存放的是域名与ip的对应关系，域名与主机名没有任何关系，你可以为任何一个IP指定任意一个名字。 修改/etc/hosts配置文件 sudo vim /etc/hosts chao@deepin:~$ cat /etc/hosts 127.0.0.1 localhost 127.0.1.1 deepin ``#IP address alias 10.68.0.2 myserver 重启一下， ssh myserver 和ssh 10.68.0.2效果一样 vim编辑器 vim编辑器 shell编程 shell编程 Reference Linux 教程–@菜鸟教程 Linux 下各个目录的作用及内容–@SYT在路上 Linux从入门到精通（传智播客黑马程序员） "},"linux-tool/":{"url":"linux-tool/","title":"linux工具","keywords":"","body":"Linux工具Linux工具 gcc编译 gdb调试 make联合编译 cmake联合编译 Valgrind内存检测 json格式 "},"linux-tool/gcc.html":{"url":"linux-tool/gcc.html","title":"GCC","keywords":"","body":"GCCgcc简介gcc 编译流程使用外部库gcc生成静态链接库gcc链接静态库gcc生成动态链接库gcc链接动态链接库GCC [TOC] gcc简介 gcc 编译流程 使用外部库 gcc生成静态链接库 gcc链接静态库 gcc生成动态链接库 gcc链接动态链接库 gcc简介 GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU计划的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。 GCC编译器是 Linux 下默认的 C/C++ 编译器，大部分 Linux 发行版中都是默认安装的。 GNU(GNU's Not Unix)是一个自由的操作系统 GPL,General Public License 通用公共授权书 gcc的特点 gcc是一个可移植的编译器，支持多种硬件平台。例如ARM、X86等等。 gcc不仅是个本地编译器，它还能跨平台交叉编译。所谓的本地编译器，是指编译出来的程序只能够在本地环境进行运行。而gcc编译出来的程序能够在其他平台进行运行。例如嵌入式程序可在x86上编译，然后在arm上运行。 gcc有多种语言前端，用于解析不同的语言。 gcc是按模块化设计的，可以加入新语言和新CPU架构的支持。 gcc是自由软件。任何人都可以使用或更改这个软件。 查看gcc版本号 gcc -v gcc --version gcc 编译流程 gcc编译程序主要经过四个过程： 预处理（Pre-Processing） 编译 （Compiling） 汇编 （Assembling） 链接 （Linking） 预处理实际上是将头文件、宏进行展开。编译阶段，gcc调用不同语言的编译器，例如c语言调用编译器ccl。gcc实际上是个工具链，在编译程序的过程中调用不同的工具。汇编阶段，gcc调用汇编器进行汇编。链接过程会将程序所需要的目标文件进行链接成可执行文件。汇编器生成的是可重定位的目标文件，学过操作系统，我们知道，在源程序中地址是从0开始的，这是一个相对地址，而程序真正在内存中运行时的地址肯定不是从0开始的，而且在编写源代码的时候也不能知道程序的绝对地址，所以重定位能够将源代码的代码、变量等定位为内存具体地址。下面以一张图来表示这个过程，注意过程中文件的后缀变化，编译选项和这些后缀有关。 GCC 既可以一次性完成C语言源文件的编译，也可以分步骤完成。 .i预处理文件、编译.s汇编文件、.o目标文件可以认为是中间文件或临时文件，如果使用 GCC 一次性完成C语言程序的编译，那么只能看到最终的可执行文件，这些中间文件都是看不到的，因为 GCC 已经经它们删除了。 gcc -c main.c # 编译# 将.c源文件编译成目标文件.o gcc main.o # 链接# 将.o 链接成为可执行文件 gcc -E hello.c -o hello.i 对hello.c文件进行预处理，生成了hello.i 文件 gcc -S hello.i -o hello.s 对预处理文件进行编译，生成了汇编文件 gcc -c hello.s -o hello.o 对汇编文件进行编译，生成了目标文件 gcc hello.o -o hello 对目标文件进行链接，生成可执行文件 gcc hello.c -o hello 直接编译链接成可执行目标文件 gcc -c hello.c 或 gcc -c hello.c -o hello.o 编译生成可重定位目标文件 -E 预处理指定的源文件，不进行编译，生成预处理文件.i -S 将C语言源文件编译为汇编语言，但并不汇编该程序，生成汇编文件.s -c 只编译、汇编源文件，但不链接，生成obj目标文件.o -o 指定输出文件 -g 包含调试信息 -I +目录 指定头文件目录 -Wall 提示更多警告信息 -l 添加标准库中链接库 -L 添加搜索链接库的目录 -D 编译时定义宏 -On 编译优化 -O0 - 没有优化 -O1 - 缺省值 -O3 - 优化级别最高 -std=c99 -std=c11 使用外部库 在使用C语言和其他语言进行程序设计的时候，我们需要头文件来提供对常数的定义和对系统及库函数调用的声明。库文件是一些预先编译好的函数集合，那些函数都是按照可重用原则编写的。它们通常由一组互相关联的可重用原则编写的，它们通常由一组互相关联的用来完成某项常见工作的函数构成。使用库的优点在于： 模块化的开发 可重用性 可维护性 库又可以分为静态库与动态库： 静态库（.a）：程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库。静态库比较占用磁盘空间，而且程序不可以共享静态库。运行时也是比较占内存的，因为每个程序都包含了一份静态库。 动态库（.so或.sa）：程序在运行的时候才去链接共享库的代码，多个程序共享使用库的代码，这样就减少了程序的体积。 一般头文件或库文件的位置在： /usr/include及其子目录底下的include文件夹 /usr/local/include及其子目录底下的include文件夹 /usr/lib /usr/local/lib /lib 静态库链接时搜索路径顺序： ld会去找GCC命令中的参数-L 再找gcc的环境变量LIBRARY_PATH 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的 动态链接时、执行时搜索路径顺序: 编译目标代码时指定的动态库搜索路径 环境变量LD_LIBRARY_PATH指定的动态库搜索路径 配置文件/etc/ld.so.conf中指定的动态库搜索路径 默认的动态库搜索路径/lib 默认的动态库搜索路径/usr/lib 有关环境变量： LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径 LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径 gcc生成静态链接库 gcc -c hello.c -o hello.o # 生成目标文件.o ar -r libhello.a hello.o # hello.o打包成静态库libhello.a ( 静态库名称规则： libxxx.a, 否则在使用-l链接的时候会找不到） ar是gun归档工具，rcs表示replace and create，如果libhello之前存在，将创建新的libhello.a并将其替换。 gcc链接静态库 使用静态库libhello.a gcc main.c libhello.a -o main # 直接链接静态库全名 # 或者： gcc -L ./ main.c -lhello -o main # -l链接静态库 -L制定库的搜索路径，-l调用链接库 gcc生成动态链接库 如果想创建一个动态链接库，可以使用 GCC 的-shared选项。输入文件可以是源文件、汇编文件或者目标文件。 另外还得结合-fPIC选项。-fPIC 选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。 从源文件生成动态链接库： gcc -fPIC -shared func.c -o libhello.so 动态链接库，名称的规则是libxxx.so 从目标文件生成动态链接库： gcc -fPIC -c func.c -o func.o gcc -shared func.o -o libhello.so -fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。 gcc链接动态链接库 如果希望将一个动态链接库链接到可执行文件，那么需要在命令行中列出动态链接库的名称，具体方式和普通的源文件、目标文件一样。 gcc main.c libhello.so -o main # 直接链接动态库全名 # 或者 gcc main.c -o main -L ./ -lhello # -l链接静态库 -L制定库的搜索路径，-l调用链接库 将 main.c 和 libhello.so 一起编译成 main，当 main运行时，会动态地加载链接库 libfunc.so。 当然，必须要确保程序在运行时可以找到这个动态链接库。你可以将链接库放到标准目录下，例如 /usr/lib，或者设置一个合适的环境变量，例如 LIBRARY_PATH。不同系统，具有不同的加载链接库的方法。 共享库有时候并不不在当前的目录下，为了让gcc能够找得到共享库，有下面几种方法： 拷贝.so文件到系统共享库路径下，一般指/usr/lib 在~/.bash_profile文件中，配置LD_LIBRARY_PATH变量 配置/etc/ld.so.conf，配置完成后调用ldconfig更新ld.so.cache 其中，shared选项表示生成共享库格式。fPIC表示产生位置无关码（position independent code），位置无关码表示它的运行、加载与内存位置无关，可以在任何内存地址进行加载。 "},"linux-tool/gdb.html":{"url":"linux-tool/gdb.html","title":"GDB","keywords":"","body":"gdb调试1 简介2 生成调试信息3 启动GDB4 程序运行上下文5 设置断点6 条件断点7 维护断点8 调试代码9 查看运行时数据10 追踪变量11 查看修改变量的值12 显示源代码退出gdbgdb调试core文件gdb调试 [TOC] 1 简介 2 生成调试信息 3 启动GDB 4 程序运行上下文 5 设置断点 6 条件断点 7 维护断点 8 调试代码 9 查看运行时数据 10 追踪变量 11 查看修改变量的值 12 显示源代码 退出gdb gdb调试core文件 1 简介 GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：GDB主要帮忙你完成下面四个方面的功能：1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）3.当程序被停住时，可以检查此时你的程序中所发生的事。4.动态的改变你程序的执行环境。 使用文字终端（shell），实现一个单步调试的功能 2 生成调试信息 ​ 一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如： gcc -g hello.c -o hello g++ -g hello.cpp -o hello -g gdb调试 如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 3 启动GDB gdb + 可执行文件 （如：gdb hello） gdb hello # 启动gdb调试 quit # 退出gdb 4 程序运行上下文 4.1 运行程序 run r # 启动程序 start # 单步执行，运行程序，停在第一行执行语句 4.2 程序运行参数 set args aa bb # 指定运行时参数aa bb 指定运行时参数,int main(int argc,char *argv)。（如：set args 10 20 30 40 50 ） show args # 查看设置好的运行参数 4.3 工作目录 cd # 相当于shell的cd命令 pwd # 显示当前的所在目录 5 设置断点 5.1 简单断点 break 设置断点，可以简写为b # break b 行号12 # 在第12行设置断点 b func # 设置断点，在func函数入口处 5.2 多文件设置断点 在进入指定函数时停住: C++中可以使用class::function或function(type,type)格式来指定函数名。 如果有名称空间，可以使用namespace::class::function或者function(type,type)格式来指定函数名。 break filename:linenum # 在源文件filename的linenum行处停住 break filename:function # 在源文件filename的function函数的入口处停住 break class::function或function(type,type) # 在类class的function函数的入口处停住 break namespace::class::function # 在名称空间为namespace的类class的function函数的入口处停住 5.3 查询所有断点 info b # 查询所有断点 # info break # 查看断点信息 6 条件断点 ​ 一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件 b test.c:8 if intValue = 5 # 设置一个条件断点 # b 行号（2） 条件（if i=5） --> 在第2行设置断点，只有i等于5时生效 7 维护断点 删除断点 d（delete）+ 断点号 --> 删除指定断点号对应的断点 # delete d # 删除所有的断点 delete [range...] # 删除指定的断点 delete [range...] 删除指定的断点，如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d 比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可 enable/disable 断点 disable/enable + 断点号 --> 设置断点是否有效 # disable dis # disable所有的停止点 disable [range...] # disable所指定的停止点 disable所指定的停止点，如果什么都不指定，表示disable所有的停止点。简写命令是dis # enable ena # enable所有的停止点 enable [range...] # enable所指定的停止点 enable所指定的停止点，如果什么都不指定，表示enable所有的停止点。简写命令是ena 8 调试代码 可视化调试 wi # 可视化调试 run # 运行程序，可简写为r next # 单步跟踪，下一行（不会进入到函数体内部），可简写为n step # 单步跟踪，下一步（会进入到函数体内部），可简写为s skip fuction getVal # step单步时跳过getVal函数 finish # 结束当前函数，返回到函数调用点，简写fin return -1 # 在当前位置直接return -1返回 continue # 继续运行程序，直到下一个端点，可简写为c until 5 # 向下运行5行后暂停 until # 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u 9 查看运行时数据 p(print) + 变量名 --> 打印变量值 print 打印变量、字符串、表达式等的值，可简写为p print aaaa # 打印 aaaa 的值 10 追踪变量 display + 变量名 --> 追踪变量，之后每执行一步，该变量值都会被打印出来 undisplay + 变量名编号 --> 取消跟踪 你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。 display 变量名 # 设置自定显示变量 undisplay 变量名编号 # 取消自动显示 info display # 查看display设置的自动显示的信息 delete display dnums… # 删除自动显示 disable display dnums… enable display dnums… dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5） disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。 11 查看修改变量的值 ptype width # 查看变量width的类型 p width # 打印变量width 的值 你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如： set --> 设置变量的值 set var n=100 set var width=47 在你改变程序变量取值时，最好都使用set var格式的GDB命令。 12 显示源代码 ​ GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上 -g 的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后， ​ GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。默认打印10行，还是来看一看查看源代码的GDB命令吧。 list 简写l 列出文件的代码清单 l list # 显示当前行后面的源程序 list - # 显示当前行前面的源程序 list 行号32 # 代码从第32行开始显示 list function # 显示函数名为function的函数的源程序 一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。 set listsize count # 设置一次显示源代码的行数 show listsize # 查看当前listsize的设置 退出gdb quit q # 退出gdb gdb调试core文件 什么是coredump Coredump叫做核心转储，它是进程运行时在突然崩溃的那一刻的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存在一个文件里。 core文件 当程序运行过程中出现段错误（Segmentation Fault），程序将停止运行，由操作系统把程序当前的内存状况存储在一个 core 文件中，即核心转储文件（Coredump File），core 文件是程序运行状态的内存映象。 通常情况下，core文件会包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，我们可以理解为是程序工作当前状态存储生成第一个文件，许多的程序出错的时候都会产生一个core文件，通过工具分析这个文件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题所在并进行及时解决。 使用 gdb 调试 core 文件，可以帮助我们快速定位程序出现段错误的位置。当然，可执行程序编译时应加上 -g 编译选项，生成调试信息。 coredump文件的存储位置 core文件默认的存储位置与对应的可执行程序在同一目录下，文件名是core，大家可以通过下面的命令看到core文件的存在位置：cat /proc/sys/kernel/core_pattern 缺省值是core 通过下面的命令可以更改coredump文件的存储位置，若你希望把core文件生成到/data/coredump/core目录下： echo “/data/coredump/core”> /proc/sys/kernel/core_pattern 注意，这里当前用户必须具有对/proc/sys/kernel/core_pattern的写权限。 缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。很显然，如果有多个程序产生core文件，或者同一个程序多次崩溃，就会重复覆盖同一个core文件，因此我们有必要对不同程序生成的core文件进行分别命名。 我们通过修改kernel的参数，可以指定内核所生成的coredump文件的文件名。例如，使用下面的命令使kernel生成名字为core.filename.pid格式的core dump文件： echo “/data/coredump/core.%e.%p” >/proc/sys/kernel/core_pattern 这样配置后，产生的core文件中将带有崩溃的程序名、以及它的进程ID。上面的%e和%p会被替换成程序文件名以及进程ID。 如果在上述文件名中包含目录分隔符“/”，那么所生成的core文件将会被放到指定的目录中。 需要说明的是，在内核中还有一个与coredump相关的设置，就是/proc/sys/kernel/core_uses_pid。如果这个文件的内容被配置成1，那么即使core_pattern中没有设置%p，最后生成的core dump文件名仍会加上进程ID。 coredump产生的原因 造成程序coredump的原因有很多，这里总结一些比较常用的经验吧： 1，内存访问越界 a) 由于使用错误的下标，导致数组访问越界。 b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符。 c) 使用strcpy, strcat, sprintf, strcmp,strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。 2，多线程程序使用了线程不安全的函数。 应该使用下面这些可重入的函数，它们很容易被用错： asctime_r(3c) gethostbyname_r(3n) getservbyname_r(3n)ctermid_r(3s) gethostent_r(3n) getservbyport_r(3n) ctime_r(3c) getlogin_r(3c)getservent_r(3n) fgetgrent_r(3c) getnetbyaddr_r(3n) getspent_r(3c)fgetpwent_r(3c) getnetbyname_r(3n) getspnam_r(3c) fgetspent_r(3c)getnetent_r(3n) gmtime_r(3c) gamma_r(3m) getnetgrent_r(3n) lgamma_r(3m) getauclassent_r(3)getprotobyname_r(3n) localtime_r(3c) getauclassnam_r(3) etprotobynumber_r(3n)nis_sperror_r(3n) getauevent_r(3) getprotoent_r(3n) rand_r(3c) getauevnam_r(3)getpwent_r(3c) readdir_r(3c) getauevnum_r(3) getpwnam_r(3c) strtok_r(3c) getgrent_r(3c)getpwuid_r(3c) tmpnam_r(3s) getgrgid_r(3c) getrpcbyname_r(3n) ttyname_r(3c)getgrnam_r(3c) getrpcbynumber_r(3n) gethostbyaddr_r(3n) getrpcent_r(3n) 3，多线程读写的数据未加锁保护。 对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成coredump 4，非法指针 a) 使用空指针 b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump。 5，堆栈溢出 不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。 1 配置产生core文件 查看ulimit设置 ulimit -c ulimit -a # 查看core file大小的配置情况 如果core file size为0，则表示系统关闭了dump core。可以通过ulimit -c unlimited来打开。若发生了段错误，但没有core dump，是由于系统禁止core文件的生成。 设置ulimit ulimit -c unlimited # 配置产生core文件，临时修改，重启后无效 修改当前用户的~/.bashrc文件，添加 ulimit -c unlimited （一劳永逸） 或者 （1）在/etc/rc.local 中增加一行 ulimit -c unlimited （2）在/etc/profile 中增加一行 ulimit -c unlimited 2 用gdb调试core文件 发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行 gdb 可执行文件 core文件 # gdb查看core文件 gdb test core 启动调试可以使用where或者bt（breaktrace）来查看错误发生的位置和堆栈。 在进入gdb后，查找段错误位置：where或者bt(backtrace) 查找段错误位置 where # 查看调用栈信息 bt # 查看调用栈信息 "},"linux-tool/make.html":{"url":"linux-tool/make.html","title":"make","keywords":"","body":"makeCMake编译设置最低版本的cmake要求设置项目信息，一般和项目的文件夹名称对应设置编译器版本添加头文件添加源文件注意${SRC_DIR}变量定义一定要在使用前，否则会报错No SOURCES given to target:添加链接库文件搜索目录设置编译类型,主函数生成可执行文件添加可执行文件 target 需要链接的库文件,等效与g++ -l库文件名字叫demo_main这个target需要链接util这个库，会优先搜索libutil.a， 如果没有就搜索libutil.so查找指定的库文件？？设置可执行文件的输出路径(EXCUTABLE_OUTPUT_PATH是全局变量)设置库文件的输出路径(LIBRARY_OUTPUT_PATH是全局变量)设置编译模式set( CMAKE_BUILD_TYPE \"Release\" )设置C++编译参数(CMAKE_CXX_FLAGS是全局变量)9. 设置变量9.1 set 直接设置变量的值9.2 set 追加设置变量的值9.3 list 追加或者删除变量的值makefileCLionVS Codemake [TOC] CMake编译 makefile CLion VS Code CMake编译 cmake官方教程 cmake官方帮助手册 cmake使用教程 CMake是一种跨平台编译工具，是一个集软件构建、测试、打包于一身的软件，比make更为高级。它可以根据不同平台、不同的编译器，生成相应的Makefile。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）。 cmake 指向CMakeLists.txt所在的目录，例如cmake .. 表示CMakeLists.txt在当前目录的上一级目录。cmake后会生成很多编译的中间文件以及makefile文件，所以一般建议新建一个新的目录，专门用来编译。 CMake自动生成的Makefile不仅可以通过make命令构建项目生成目标文件，还支持安装（make install）、测试安装的程序是否能正确执行（make test，或者ctest）、生成当前平台的安装包（make package）、生成源码包（make package_source）、产生Dashboard显示数据并上传等高级功能，只要在CMakeLists.txt中简单配置，就可以完成很多复杂的功能，包括写测试用例。 make根据生成makefile文件，编译程序。 在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下： 编写 cmake 配置文件 CMakeLists.txt 执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile ,其中，PATH 是 CMakeLists.txt 所在的目录。 使用 make 命令进行编译。 ccmake 和 cmake 的区别在于ccmake提供了一个交互式的界面。 mkdir build cd build cmake .. # 指向CMakeLists.txt所在的目录,生成的makefile文件 # 编译 make # 编译,指向makefile文件,生成执行程序 # 安装 make install # 测试安装的程序是否能正确执行 make test # 将程序和相关的档案包装成一个压缩文件以供发布 make dist # 生成当前平台的安装包 make package # 生成源码包 make package_source # 清除编译产生的可执行文件及目标文件(object file，*.o) make clean CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 # 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。 CMakeLists.txt文件格式 设置最低版本的cmake要求 cmake_minimum_required(VERSION 2.8) 设置项目信息，一般和项目的文件夹名称对应 project(demo_main_project) 设置编译器版本 set(CMAKE_CXX_STANDARD 14) 添加头文件 include_directories(./include) # 把当前目录(CMakeLists.txt所在目录)下的include文件夹加入到包含路径 include_directories( ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_LIST_DIR}/include) 添加源文件 5.2 搜索指定目录下的所有的 cpp 文件,并将结果存储在指定变量名中 aux_source_directory( ) # 查找dir路径下的所有源文件(不会递归包含子目录)，保存到variable变量中 ​ aux_source_directory(./src SRC_DIR) # 搜索./src目录下的所有的.cpp源文件,并将结果存在变量 SRC_DIR中 ​ add_executable(demo_main ${SRC_DIR}) # 给demo添加包含的源文件 也可以这样 add_library(demo_main ${SRC_DIR}) # 给demo添加包含的源文件 注意${SRC_DIR}变量定义一定要在使用前，否则会报错No SOURCES given to target: 5.1 添加包含的所有源文件(数量少) add_library(demo demo.cpp test.cpp util.cpp) # 给demo添加包含的源文件 添加链接库文件搜索目录 link_directories(directory1 directory2 ...) # 添加了库包含路径directory1 directory2 ... link_directories( ${CMAKE_CURRENT_LIST_DIR}/lib ) # 添加./lib下的链接库 设置编译类型,主函数生成可执行文件 add_executable(demo_main demo_main.cpp) # 生成可执行文件 添加可执行文件 target 需要链接的库文件,等效与g++ -l库文件名 target_link_libraries( lib1 lib2 lib3) # 将lib1, lib2, lib3链接到上 target_link_libraries(demo_main util) 字叫demo_main这个target需要链接util这个库，会优先搜索libutil.a， 如果没有就搜索libutil.so 8.1 #指定链接动态库或静态库 target_link_libraries(demo libface.a) # 链接libface.a target_link_libraries(demo libface.so) # 链接libface.so 8.2 #指定全路径 target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/lib/) 8.3 #指定链接多个库 target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a boost_system.a boost_thread pthread) 查找指定的库文件？？ find_package(OpenCV 2.4.3 REQUIRED) find_library() 类似的命令还有 find_file()、find_path()、find_program()、find_package()。 3.add_library 添加库？？ 3.1 添加一个库 add_library( [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) 添加一个名为的库文件 指定STATIC, SHARED, MODULE参数来指定要创建的库的类型, STATIC对应的静态库 .a SHARED对应共享动态库.so [EXCLUDE_FROM_ALL], 如果指定了这一属性，对应的一些属性会在目标被创建时被设置(指明此目录和子目录中所有的目标，是否应当从默认构建中排除, 子目录的IDE工程文件/Makefile将从顶级IDE工程文件/Makefile中排除) source1 source2 ... sourceN用来指定源文件 3.2 导入已有的库 add_library( [STATIC | SHARED | MODULE | UNKNOWN] IMPORTED) 导入了一个已存在的库文件，导入库一般配合set_target_properties使用，这个命令用来指定导入库的路径,比如： add_library(test SHARED IMPORTED) set_target_properties( test #指定目标库名称 PROPERTIES IMPORTED_LOCATION #指明要设置的参数 libs/src/${ANDROID_ABI}/libtest.so #设定导入库的路径) add_library(common STATIC util.cpp) # 生成静态库 .a add_library(common SHARED util.cpp) # 生成动态共享库 .so add_subdirectory 如果当前目录下还有子目录时可以使用add_subdirectory，子目录中也需要包含有CMakeLists.txt file文件操作命令 三、常用变量 预定义变量 PROJECT_NAME：项目名称 PROJECT_SOURCE_DIR：工程的根目录 CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径 CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径 PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build CMAKE_CURRENT_BINARY_DIR：target 编译目录 CMAKE_CURRENT_LIST_LINE：当前所在的行 CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块 EXECUTABLE_OUTPUT_PATH：重新定义可执行文件的输出路径 LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的输出路径 环境变量 env 系统信息 CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3 CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4 CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1 CMAKE_SYSTEM：系统名称，比如 Linux-­2.6.22 CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 Linux CMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22 CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686 UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin WIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin 主要开关选项 BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库 CMAKE_CXX_FLAGS：设置 C++ 编译选项 设置可执行文件的输出路径(EXCUTABLE_OUTPUT_PATH是全局变量) set(EXECUTABLE_OUTPUT_PATH [output_path]) 如set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin) 设置库文件的输出路径(LIBRARY_OUTPUT_PATH是全局变量) set(LIBRARY_OUTPUT_PATH [output_path]) 设置编译模式 set( CMAKE_BUILD_TYPE \"Debug\" ) set( CMAKE_BUILD_TYPE \"Release\" ) 设置C++编译参数(CMAKE_CXX_FLAGS是全局变量) set(CMAKE_CXX_FLAGS \"-std=c++11\") # c++11 set(CMAKE_CXX_FLAGS \"-g\") # 调试信息 set(CMAKE_CXX_FLAGS \"-Wall\") # 开启所有警告 9. 设置变量 9.1 set 直接设置变量的值 set(SRC_LIST main.cpp test.cpp) add_executable(demo ${SRC_LIST}) 9.2 set 追加设置变量的值 set(SRC_LIST main.cpp) set(SRC_LIST ${SRC_LIST} test.cpp) add_executable(demo ${SRC_LIST}) 9.3 list 追加或者删除变量的值 set(SRC_LIST main.cpp) list(APPEND SRC_LIST test.cpp) list(REMOVE_ITEM SRC_LIST main.cpp) add_executable(demo ${SRC_LIST}) install 安装规则 install 指定在安装时要运行的规则 报错： undefined reference to ...... C++程序报错undefined reference to 在C++代码中调用C的库文件，需加上extern \"C\"，用来告知编译器：这是一个用C写成的库文件，请用C的方式连接他们。 Undefined reference to 错误:这类错误是在连接过程中出现的，可能有两种原因∶ 一是使用者自己定义的函数或者全局变量所在源代码文件，没有被编译、连接，或者干脆还没有定义，这 需要使用者根据实际情况修改源程序，给出全局变量或者函数的定义体； 二是未定义的符号是一个标准的库函数，在源程序中使用了该库函数，而连接过程中还没有 给定相应的函数库的名称，或者是该档案库的目录名称有问题. makefile Make 命令教程 Makefile文件的格式 Makefile文件由一系列规则（rules）构成。每条规则的形式如下。 : [tab] 上面第一行冒号前面的部分，叫做\"目标\"（target），冒号后面的部分叫做\"前置条件\"（prerequisites）；第二行必须由一个tab键起首，后面跟着\"命令\"（commands）。 \"目标\"是必需的，不可省略；\"前置条件\"和\"命令\"都是可选的，但是两者之中必须至少存在一个。 每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。 CLion Ctrl + / 添加或删除注释 Ctrl + Alt + L 格式化代码 Alt + Enter 智能提示 Ctrl + R 替换 Ctrl + Shift + R 全局替换 Ctrl + F 搜索 Ctrl + Shift + F 全局搜索 Ctrl + B 在定义和申明之间跳转 Ctrl + Shift + Backspace 回到最后编辑的地方 Alt + 鼠标选择 多行编辑 Shift + Enter 在下面新开一行 Ctrl + Alt + -/+ 展开折叠当前函数、类 Ctrl + Shift + -/+ 展开折叠所有函数、类Ctrl + N 查找类 Ctrl + Q 快速查看文档 Ctrl + P 提示参数信息 Ctrl + H 查看继承树 Ctrl + Shift + N 找文件 Shift + Shift 全局搜索 在keymap快捷键找到 related symbol : .h 和.CPPcpp切换 VS Code ctrl+shift+n 打开新窗口 "},"linux-tool/json.html":{"url":"linux-tool/json.html","title":"json","keywords":"","body":"jsonJSON 文件JSON 语法规则JSON 名称/值对JSON 值JSON 数字JSON 字符串JSON 布尔值JSON nullJSON 对象JSON 数组json [TOC] JSON 文件 JSON 语法规则 JSON 名称/值对 JSON 值 JSON 数字 JSON 字符串 JSON 布尔值 JSON null JSON 对象 JSON 数组 RapidJSON JSON: JavaScript Object Notation(JavaScript 对象表示法) JSON 是存储和交换文本信息的语法。类似 XML。 JSON 比 XML 更小、更快，更易解析。 JSON 文件 JSON 文件的文件类型是 \".json\" JSON 文本的 MIME 类型是 \"application/json\" JSON 语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 名称/值对 JSON 数据的书写格式是：名称/值对。 名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：\"firstName\" : \"John\" JSON 值 JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号“ ”中） 逻辑值（true 或 false） 数组（在方括号[ ]中） 对象（在花括号{ }中）无序 null JSON 数字 JSON 数字可以是整型或者浮点型： { \"age\":30 } JSON 字符串 JSON 字符串在双引号中： { \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" } JSON 布尔值 JSON 布尔值可以是 true 或者 false： { \"flag\":true } JSON null JSON 可以设置 null 值： { \"runoob\":null } JSON 对象 JSON 对象在花括号{ }中书写。 对象可以包含多个key/value（键/值）。 对key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。 key 和 value 中使用冒号(:)分割。 每个 key/value 对使用逗号(,)分割。 { \"name\":\"runoob\", \"alexa\":10000, \"site\":null } JSON 数组 JSON 数组在方括号中书写。 JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。 数组可包含多个对象。 { \"name\":\"网站\", \"num\":3, \"sites\":[ \"Google\", \"Runoob\", \"Taobao\" ], \"age\":[30, 10.5, 40], \"employees\": [ { \"firstName\":\"John\" , \"lastName\":\"Doe\" }, { \"firstName\":\"Anna\" , \"lastName\":\"Smith\" }, { \"firstName\":\"Peter\" , \"lastName\":\"Jones\" } ] } "},"linux-tool/valgrind内存检测.html":{"url":"linux-tool/valgrind内存检测.html","title":"valgrind内存检测","keywords":"","body":"Valgrindvalgrind简介valgrind的使用valgrind常见内存问题案例参数选项referenceValgrind valgrind简介 Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软件开发工具。 Valgrind是用于调试和分析Linux程序的GPL系统。使用Valgrind的 工具套件，您可以自动检测许多内存管理和线程错误。您还可以执行详细的性能分析，以帮助加快程序速度。 Valgrind可使用任何语言编写的程序。因为Valgrind直接与程序二进制文件一起使用，所以它可以与以任何编程语言编写的程序一起使用，无论它们是编译的，即时编译的还是解释的。Valgrind工具主要针对用C和C ++编写的程序，因为用这些语言编写的程序往往有最多的错误！但是，例如，它可以用于调试和分析以多种语言编写的系统。Valgrind已用于部分或全部用C，C ++，Java，Perl，Python，汇编代码，Fortran，Ada等编写的程序上。 Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。Valgrind的体系结构如下图所示： valgrind工具 Memcheck： 内存错误检测器，能够发现开发中绝大多数内存错误使用情况。它可以帮助您使程序，尤其是C和C ++的程序更加正确。 Memcheck 工具主要检查下面的程序错误： 使用未初始化的内存 (Use of uninitialised memory) 读/写已经被释放的内存 (Reading/writing memory after it has been free’d) 读/写内存越界 (Reading/writing off the end of malloc’d blocks) 读/写不恰当的内存栈空间 (Reading/writing inappropriate areas on the stack) 内存泄漏 (Memory leaks – where pointers to malloc’d blocks are lost forever) malloc/new/new[]和free/delete/delete[]不匹配 (Mismatched use of malloc/new/new [] vs free/delete/delete []) src和dst的重叠 (Overlapping src and dst pointers in memcpy() and related functions) Callgrind： 生成调用图的缓存分析器，它主要用来检查程序中函数调用过程中出现的问题。 Callgrind收集程序运行时的一些数据，函数调用关系等信息，还可以有选择地进行cache 模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。 Cachegrind： 缓存和分支预测探查器，它主要用来检查程序中缓存使用出现的问题。它可以帮助您使程序运行更快。 它模拟 CPU中的一级缓存I1,D1和L2二级缓存，能够精确地指出程序中 cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。 Helgrind： 线程错误检测器，它主要用来检查多线程程序中出现的竞争问题。 Helgrind 寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为” Eraser” 的竞争检测算法，并做了进一步改进，减少了报告错误的次数。 DRD：还是线程错误检测器。它类似于Helgrind，但是使用不同的分析技术，因此可能会发现不同的问题。 Massif： 堆分析器，它主要用来检查程序中堆栈使用中出现的问题。 堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。 DHAT：是另一种堆分析器。它可以帮助您了解模块寿命，模块利用率和布局效率低下的问题。 BBV：是一个实验性的SimPoint基本块矢量生成器。这对从事计算机体系结构研究和开发的人员很有用。 内存检查原理 Memcheck检测内存问题的原理如下图所示： Memcheck 能够检测出内存问题，关键在于其建立了两个全局表。 Valid-Value 表： 对于进程的整个地址空间中的每一个字节(byte)，都有与之对应的 8 个 bits；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。 Valid-Address 表 对于进程整个地址空间中的每一个字节(byte)，还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。 检测原理： 当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该A bit显示该位置是无效位置，memcheck 则报告读写错误。 内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误。 C++内存分配方式 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆：malloc在堆上分配的内存块，使用free释放内存。 自由存储区：new所申请的内存则是在自由存储区上，使用delete来释放，编译器不管，由程序自己释放，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。 堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。 自由存储是C++中通过new与delete动态分配和释放对象的抽象概念，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。 new所申请的内存区域在C++中称为自由存储区。即由堆实现的自由存储，可以说new所申请的内存区域在堆上。 堆与自由存储区还是有区别的，它们并非等价。 堆和栈区别 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。 空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，默认的栈空间大小是几M。当然，我们可以修改。 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 valgrind的使用 编译准备 建议在编译时加上-g参数启用了调试信息，可以使valgrind发现的错误更精确，如能够定位到源代码行。 编译优化选项请选择-O0，虽然这会降低程序的执行效率。因为在极少数情况下，-O2 会-O1观察到编译器的优化，从而生成使Memcheck误报未初始化值错误或丢失未初始化值错误的代码。除了Memcheck所有其他工具不受优化级别的影响，对于Cachegrind之类的性能分析工具，最好以其常规优化级别编译程序。 建议使用-Wall开启所有警告，因为它可以识别Valgrind在较高的优化级别上可能会遗漏的部分或全部问题。 #include int main(void) { int *x = new int[10]; // problem 1: heap block overrun x[20] = 2; //写越界没有挂掉 // problem 2: memory leak -- x 未释放 return 0; } 编译程序时，需要加上-g,O0,Wall选项，-std=c++11可选： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main valgrind调试 Valgrind被设计为尽可能非侵入性的。利用valgrind调试内存问题，不需要重新编译源，重新链接或以其他方式修改要检查的程序，它的输入就是二进制的可执行程序。 调用Valgrind的通用格式是： valgrind [valgrind-options] your-prog-name [your-prog-options] valgrind --tool=memcheck --leak-check=full ./main --tool=memcheck选择valgrind工具，默认是memcheck。--leak-check=full 选项打开详细的内存泄漏检测器。 您的程序将比正常运行慢得多（例如20到30倍），并且使用更多的内存。memcheck将发出有关内存错误和它检测到的泄漏的消息。 如果您使用的是C ++，则可能要考虑的另一种选择是-fno-inline。这样可以更轻松地查看函数调用链，这有助于减少在大型C ++应用程序中导航时的混乱。或者，Valgrind选项 --read-inline-info=yes指示Valgrind读取描述内联信息的调试信息。这样，即使使用内联编译应用程序时，函数调用链也会正确显示。 选项参数 Valgrind 的参数分为两类，一类是 Valgrind核心的参数选项，它对所有的工具都适用；另外一类就是具体某个工具如 memcheck 的参数选项。 Valgrind 默认的工具就是 memcheck，也可以通过“--tool=tool name”指定其他的工具。Valgrind 提供了大量的参数满足你特定的调试需求，具体可参考其用户手册，Valgrind核心命令行参数选项。 常用选项，适用于所有Valgrind工具： --tool= 运行 valgrind中名为toolname的工具。例如memcheck（默认），cachegrind，callgrind，helgrind，drd，massif，dhat，bouchey，none，exp-bbv等。 -h --help 显示帮助信息。 --version 显示valgrind内核的版本，每个工具都有各自的版本。 -q --quiet 安静地运行，只打印错误信息。 -v --verbose 更详细的信息, 增加错误数统计。 --trace-children=no|yes 跟踪子线程? [no] --track-fds=no|yes 跟踪打开的文件描述？[no] --time-stamp=no|yes 增加时间戳到LOG信息? [no] --log-fd= 输出LOG到描述符文件 [2=stderr] --log-file= 将输出LOG信息写入到指定文件里 --log-file-exactly= 输出LOG信息到 file --log-file-qualifier= 取得环境变量的值来做为输出信息的文件名。 [none] --log-socket= 输出LOG信息到指定IP地址的指定端口 LOG信息输出 -xml=yes 将信息以xml格式输出，只有memcheck可用 -num-callers= show callers in stack traces [12] -error-limit=no|yes 如果太多错误，则停止显示新错误? [yes] -error-exitcode= 如果发现错误则返回错误代码 [0=disable] -db-attach=no|yes 当出现错误，valgrind会自动启动调试器gdb。[no] -db-command= 启动调试器的命令行选项[gdb -nw %f %p] 适用于Memcheck工具的相关选项： -leak-check=no|summary|full 要求对leak给出详细信息 -leak-resolution=low|med|high how much bt merging in leak check -show-reachable=no|yes show reachable blocks in leak check 输出信息 $ valgrind --tool=memcheck --leak-check=full ./a.out ==8040== Memcheck, a memory error detector ==8040== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==8040== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==8040== Command: ./main ==8040== ==8040== Invalid write of size 4 ==8040== at 0x401170: main (使用未初始化的内存.cpp:5) ==8040== Address 0x4d8dcd0 is 32 bytes before an unallocated block of size 4,121,328 in arena \"client\" ==8040== ==8040== ==8040== HEAP SUMMARY: ==8040== in use at exit: 40 bytes in 1 blocks ==8040== total heap usage: 2 allocs, 1 frees, 72,744 bytes allocated ==8040== ==8040== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==8040== at 0x483650F: operator new[](unsigned long) (vg_replace_malloc.c:423) ==8040== by 0x401163: main (使用未初始化的内存.cpp:3) ==8040== ==8040== LEAK SUMMARY: ==8040== definitely lost: 40 bytes in 1 blocks ==8040== indirectly lost: 0 bytes in 0 blocks ==8040== possibly lost: 0 bytes in 0 blocks ==8040== still reachable: 0 bytes in 0 blocks ==8040== suppressed: 0 bytes in 0 blocks ==8040== ==8040== For counts of detected and suppressed errors, rerun with: -v ==8040== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0) ==8040==进程ID8040 ，通常不重要。 HEAP SUMMARY，它表示程序在堆上分配内存的情况。程序报错的具体位置。 LEAK SUMMARY，它表示程序内存泄露的情况，其中对内存泄露进行了分类，总共有五类： definitely lost 意味着你的程序一定存在内存泄露； indirectly lost 意味着你的程序一定存在内存泄露，并且泄露情况和指针结构相关。 possibly lost 意味着你的程序一定存在内存泄露，除非你是故意进行着不符合常规的操作，例如将指针指向某个已分配内存块的中间位置。 still reachable 意味着你的程序可能是没问题的，但确实没有释放掉一些本可以释放的内存。这种情况是很常见的，并且通常基于合理的理由。 suppressed 意味着有些泄露信息被压制了。在默认的 suppression 文件中可以看到一些 suppression 相关设置。 Valgrind的局限 1.无法发现静态数组越界 Valgrind不对静态数组(分配在栈上)进行边界检查。无法发现静态数组越界的问题。 如果在程序中声明了一个静态数组，存在访问越界问题： int main() { char x[10]; x[11] = 'a'; // 静态数组越界 } valgrind没有发现静态数组越界的问题： $ valgrind --tool=memcheck --leak-check=full ./main ==12599== Memcheck, a memory error detector ==12599== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==12599== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==12599== Command: ./main ==12599== ==12599== ==12599== HEAP SUMMARY: ==12599== in use at exit: 0 bytes in 0 blocks ==12599== total heap usage: 1 allocs, 1 frees, 72,704 bytes allocated ==12599== ==12599== All heap blocks were freed -- no leaks are possible ==12599== ==12599== For counts of detected and suppressed errors, rerun with: -v ==12599== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) Valgrind则不会警告你静态数组(分配在栈上)越界。你可以把数组改为动态在堆上分配的数组，这样就可能进行边界检查了。这个方法好像有点得不偿失的感觉。 2.占用更多内存 Valgrind占用了更多的内存，可达两倍于你程序的正常使用量。 如果你用Valgrind来检测使用大量内存的程序就会遇到问题，它可能会用很长的时间来运行测试。大多数情况下，这都不是问题，即使速度慢也仅是检测时速度慢，如果你用Valgrind来检测一个正常运行时速度就很慢的程序，这下问题就大了。 Valgrind不可能检测出你在程序中犯下的所有错误--如果你不检查缓冲区溢出，Valgrind也不会告诉你代码写了它不应该写的内存。 C++ 程序reachable原因 此问题可能与gcc和valgrind版本有关系，有出现此问题的版本为gcc-5.4，valgrind 3.13，经验证案例gcc-8.3，valgrind-3.14没有出现此问题。 C++ 程序reachable valgrind 3-13案例 （C++ 程序出现reachable问题，用的gcc-5.4 valgrind 3-13 ； 编译器版本和内存检查工具不同 生成的valgrind的报告存在差异，差异在于是否输出内存池的的log信息，关于内存池的相关知识，请参考相关文档） 下面是一个正常的 C++ 程序，没有发生内存泄漏： #include int main() { auto ptr = new std::string(\"Hello, World!\"); delete ptr; //正常释放 return 0; } $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 分析这段程序，--show-leak-kinds=all选项，显示内存泄漏检测详细信息： $ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main_cpp valgrind-3.14实际输出：（没有检测到问题） $ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main ==10553== Memcheck, a memory error detector ==10553== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==10553== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==10553== Command: ./main ==10553== ==10553== ==10553== HEAP SUMMARY: ==10553== in use at exit: 0 bytes in 0 blocks ==10553== total heap usage: 2 allocs, 2 frees, 72,736 bytes allocated ==10553== ==10553== All heap blocks were freed -- no leaks are possible ==10553== ==10553== For counts of detected and suppressed errors, rerun with: -v ==10553== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) valgrind-3.13参考的输出：(C++ 程序出现reachable问题) ==31438== Memcheck, a memory error detector ==31438== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==31438== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==31438== Command: ./main_cpp ==31438== ==31438== ==31438== HEAP SUMMARY: ==31438== in use at exit: 72,704 bytes in 1 blocks ==31438== total heap usage: 2 allocs, 1 frees, 72,736 bytes allocated ==31438== ==31438== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1 ==31438== at 0x4C2DBF6: malloc (vg_replace_malloc.c:299) ==31438== by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21) ==31438== by 0x40104E9: call_init.part.0 (dl-init.c:72) ==31438== by 0x40105FA: call_init (dl-init.c:30) ==31438== by 0x40105FA: _dl_init (dl-init.c:120) ==31438== by 0x4000CF9: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so) ==31438== ==31438== LEAK SUMMARY: ==31438== definitely lost: 0 bytes in 0 blocks ==31438== indirectly lost: 0 bytes in 0 blocks ==31438== possibly lost: 0 bytes in 0 blocks ==31438== still reachable: 72,704 bytes in 1 blocks ==31438== suppressed: 0 bytes in 0 blocks ==31438== ==31438== For counts of detected and suppressed errors, rerun with: -v ==31438== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 使用 Valgrind 分析 C++ 程序时，有一些问题需要留意。 例如，这个程序并没有发生内存泄漏，但是从HEAP SUMMARY可以看到，程序分配了 2 次内存，但却只释放了 1 次内存，为什么会这样呢？ 实际上这是由于C++ 在分配内存时，为了提高效率，使用了它自己的内存池。当程序终止时，内存池的内存才会被操作系统回收，所以 Valgrind 会将这部分内存报告为 reachable 的，需要注意，reachable 的内存不代表内存泄漏。例如，从上面的输出中可以看到，有 72704 个字节是 reachable 的，但没有报告内存泄漏。 valgrind常见内存问题案例 使用未初始化的内存变量 全局变量和静态变量的初始值均为0，而局部变量和动态申请的变量，其初始值为随机值。如果程序使用了随机值的变量，那么程序的行为就变得不可预期。 #include int main() { int x; // 未初始化 if (x == 0) { std::cout 编译： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 检测内存使用情况： $ valgrind --tool=memcheck --leak-check=full ./main 输出信息： ==8360== Memcheck, a memory error detector ==8360== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==8360== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==8360== Command: ./main ==8360== ==8360== Conditional jump or move depends on uninitialised value(s) ==8360== at 0x40117E: main (main.cpp:4) ==8360== X is zero ==8360== ==8360== HEAP SUMMARY: ==8360== in use at exit: 0 bytes in 0 blocks ==8360== total heap usage: 2 allocs, 2 frees, 73,728 bytes allocated ==8360== ==8360== All heap blocks were freed -- no leaks are possible ==8360== ==8360== For counts of detected and suppressed errors, rerun with: -v ==8360== Use --track-origins=yes to see where uninitialised values come from ==8360== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 使用--track-origins=yes选项查看具体未初始化变量的位置 $ valgrind --tool=memcheck --leak-check=full --track-origins=yes ./main ==8498== Conditional jump or move depends on uninitialised value(s) ==8498== at 0x40117E: main (main.cpp:4) ==8498== Uninitialised value was created by a stack allocation ==8498== at 0x401172: main (main.cpp:2) 输出结果会显示：Conditional jump or move depends on uninitialized value(s) 即程序的跳转依赖于一个未初始化的变量。 内存读写越界（非法读写） 当访问了不该访问或者没有权限访问的内存地址空间，对动态内存访问时超出了申请的内存大小范围。 输出结果会显示： Invalid write of size 4; Invalid read of size 4 注意：valgrind无法发现静态数组越界的问题。 动态数组访问越界 #include int main() { // int a[10]; 静态数组越界valgrind无法检查出来 int *iptr = new int[10]; //动态内存 std::cout 编译程序时，需要加上加上-g,O0,Wall选项： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 分析这段程序，Valgrind 会提示越界访问： $ valgrind --tool=memcheck --leak-check=full ./main $ valgrind --tool=memcheck --leak-check=full ./main ==7233== Memcheck, a memory error detector ==7233== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==7233== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==7233== Command: ./main ==7233== ==7233== Invalid read of size 4 ==7233== at 0x4011B0: main (main.cpp:5) ==7233== Address 0x4d8dca8 is 0 bytes after a block of size 40 alloc'd ==7233== at 0x483650F: operator new[](unsigned long) (vg_replace_malloc.c:423) ==7233== by 0x4011A3: main (main.cpp:4) ==7233== 0 ==7233== ==7233== HEAP SUMMARY: ==7233== in use at exit: 0 bytes in 0 blocks ==7233== total heap usage: 3 allocs, 3 frees, 73,768 bytes allocated ==7233== ==7233== All heap blocks were freed -- no leaks are possible ==7233== ==7233== For counts of detected and suppressed errors, rerun with: -v ==7233== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) vector访问越界 #include #include int main() { std::vector v(10, 0); //动态内存 std::cout 编译程序时，需要加上加上-g,O0,Wall选项： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 分析这段程序，Valgrind 会提示越界访问： $ valgrind --tool=memcheck --leak-check=full ./main $ valgrind --tool=memcheck --leak-check=full ./main ==5797== Memcheck, a memory error detector ==5797== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==5797== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==5797== Command: ./main ==5797== ==5797== Invalid read of size 4 ==5797== at 0x401214: main (main.cpp:5) ==5797== Address 0x4d8dca8 is 0 bytes after a block of size 40 alloc'd ==5797== at 0x4835DEF: operator new(unsigned long) (vg_replace_malloc.c:334) ==5797== by 0x4017F9: __gnu_cxx::new_allocator::allocate(unsigned long, void const*) (new_allocator.h:111) ==5797== by 0x401766: std::allocator_traits >::allocate(std::allocator&, unsigned long) (alloc_traits.h:436) ==5797== by 0x4016B7: std::_Vector_base >::_M_allocate(unsigned long) (stl_vector.h:296) ==5797== by 0x4015A4: std::_Vector_base >::_M_create_storage(unsigned long) (stl_vector.h:311) ==5797== by 0x401446: std::_Vector_base >::_Vector_base(unsigned long, std::allocator const&) (stl_vector.h:260) ==5797== by 0x401339: std::vector >::vector(unsigned long, int const&, std::allocator const&) (stl_vector.h:429) ==5797== by 0x4011F6: main (main.cpp:4) ==5797== 0 ==5797== ==5797== HEAP SUMMARY: ==5797== in use at exit: 0 bytes in 0 blocks ==5797== total heap usage: 3 allocs, 3 frees, 73,768 bytes allocated ==5797== ==5797== All heap blocks were freed -- no leaks are possible ==5797== ==5797== For counts of detected and suppressed errors, rerun with: -v ==5797== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) Invalid read of size 4表示越界读取 4 个字节，这个操作出现在main.cpp文件的第 5 行。另外可以看到，vector分配了一块 40 字节的内存，程序越界访问紧接着这块内存之后的 4 个字节。 valgrind无法发现静态数组越界 Valgrind不对静态数组(分配在栈上)进行边界检查。无法发现静态数组越界的问题。 如果在程序中声明了一个静态数组，存在访问越界问题，程序不会挂掉，valgrind无法检查出来： #include int main() { int a[10]; a[22] = 22; // 静态数组越界，程序不会挂掉，valgrind无法检查出来 std::cout valgrind没有发现静态数组越界的问题： $ valgrind --tool=memcheck --leak-check=full ./main==22741== Memcheck, a memory error detector ==22741== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==22741== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==22741== Command: ./main ==22741== 22 ==22741== ==22741== HEAP SUMMARY: ==22741== in use at exit: 0 bytes in 0 blocks ==22741== total heap usage: 2 allocs, 2 frees, 73,728 bytes allocated ==22741== ==22741== All heap blocks were freed -- no leaks are possible ==22741== ==22741== For counts of detected and suppressed errors, rerun with: -v ==22741== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) Valgrind则不会警告你静态数组(分配在栈上)越界。你可以把数组改为动态在堆上分配的数组，这样就可能进行边界检查了。这个方法好像有点得不偿失的感觉。 内存泄漏（未释放内存） 常见的内存分配方式分三种：静态存储，栈上分配，堆上分配。全局变量属于静态存储，它们是在编译时就被分配了存储空间，函数内的局部变量属于栈上分配，而最灵活的内存使用方式当属堆上分配，也叫做内存动态分配了。常用的内存动态分配函数包括：malloc, alloc, realloc, new等，动态释放函数包括free, delete。 在程序中动态申请的内存在使用完后既没有释放也也法被程序的其他部分访问。 显示输出结果如下：12 bytes in 1 blocks are definitely lost in loss record 1 of 1 动态数组内存泄漏 Valgrind 可以用来检测程序在哪个位置发生内存泄漏 #include int main() { int *iptr = new int[3]; //未释放 // auto vptr = new std::vector(3); //未释放 return 0; } 编译程序时，需要加上加上-g,O0,Wall选项： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 检测内存使用情况： $ valgrind --tool=memcheck --leak-check=full ./main $ valgrind --tool=memcheck --leak-check=full ./main ==11483== Memcheck, a memory error detector ==11483== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==11483== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==11483== Command: ./main ==11483== ==11483== ==11483== HEAP SUMMARY: ==11483== in use at exit: 12 bytes in 1 blocks ==11483== total heap usage: 2 allocs, 1 frees, 72,716 bytes allocated ==11483== ==11483== 12 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==11483== at 0x483650F: operator new[](unsigned long) (vg_replace_malloc.c:423) ==11483== by 0x401133: main (main.cpp:3) ==11483== ==11483== LEAK SUMMARY: ==11483== definitely lost: 12 bytes in 1 blocks ==11483== indirectly lost: 0 bytes in 0 blocks ==11483== possibly lost: 0 bytes in 0 blocks ==11483== still reachable: 0 bytes in 0 blocks ==11483== suppressed: 0 bytes in 0 blocks ==11483== ==11483== For counts of detected and suppressed errors, rerun with: -v ==11483== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) HEAP SUMMARY，它表示程序在堆上内存分配的情况，其中的2 allocs表示程序分配了 2 次内存，1 frees表示程序释放了 1 次内存，12 bytes allocated表示分配了 12 个字节的内存。 另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。by 0x401133: main (main.c:3)从上面的信息可以看到，程序发生了一次内存泄漏，位置是main.c文件的第 3 行。 LEAK SUMMARY，它表示程序内存泄露的情况。definitely lost: 12 bytes in 1 blocks程序一定存在内存泄露。 vector会分配额外空间 new vector(3)相比数组new int[3]占用的空间更大，来处理理vector。 #include int main() { // int *iptr = new int[3]; //未释放 auto vptr = new std::vector(3); //未释放 return 0; } $ valgrind --tool=memcheck --leak-check=full ./main ==11754== Memcheck, a memory error detector ==11754== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==11754== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==11754== Command: ./main ==11754== ==11754== ==11754== HEAP SUMMARY: ==11754== in use at exit: 36 bytes in 2 blocks ==11754== total heap usage: 3 allocs, 1 frees, 72,740 bytes allocated ==11754== ==11754== 36 (24 direct, 12 indirect) bytes in 1 blocks are definitely lost in loss record 2 of 2 ==11754== at 0x4835DEF: operator new(unsigned long) (vg_replace_malloc.c:334) ==11754== by 0x401186: main (main.cpp:4) ==11754== ==11754== LEAK SUMMARY: ==11754== definitely lost: 24 bytes in 1 blocks ==11754== indirectly lost: 12 bytes in 1 blocks ==11754== possibly lost: 0 bytes in 0 blocks ==11754== still reachable: 0 bytes in 0 blocks ==11754== suppressed: 0 bytes in 0 blocks ==11754== ==11754== For counts of detected and suppressed errors, rerun with: -v ==11754== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) new vector(3)占36字节 ==11754== HEAP SUMMARY: ==11754== in use at exit: 36 bytes in 2 blocks ==11754== total heap usage: 3 allocs, 1 frees, 72,740 bytes allocated ==11754== ==11754== 36 (24 direct, 12 indirect) bytes in 1 blocks are definitely lost in loss record 2 of 2 ==11754== at 0x4835DEF: operator new(unsigned long) (vg_replace_malloc.c:334) new int[3]占12字节 ==11483== HEAP SUMMARY: ==11483== in use at exit: 12 bytes in 1 blocks ==11483== total heap usage: 2 allocs, 1 frees, 72,716 bytes allocated ==11483== ==11483== 12 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==11483== at 0x483650F: operator new[](unsigned long) (vg_replace_malloc.c:423) 重复释放内存 申请了多少内存，在使用完成后就要释放多少。如果没有释放，或者少释放了就是内存泄露；多释放了也会产生问题。当申请与释放大小不一致时，即申请了多少内存却没有释放完或者多释放了， 显示输出结果如下：Invalid free() /delete/delete[] 上述程序中，指针sm_ptr和ptr指向的是同一块内存，却被先后释放两次。 #include int main() { int *ptr = new int; //动态内存 delete ptr; int *sm_ptr = ptr; delete sm_ptr; //sm_ptr和ptr指向的是同一块内存,重复释放 return 0; } 编译程序时，需要加上加上-g,O0,Wall选项： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 分析这段程序： $ valgrind --tool=memcheck --leak-check=full ./main $ valgrind --tool=memcheck --leak-check=full ./main==8895== Memcheck, a memory error detector==8895== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==8895== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==8895== Command: ./main ==8895== ==8895== Invalid free() / delete / delete[] / realloc() ==8895== at 0x4836EAB: operator delete(void*) (vg_replace_malloc.c:576) ==8895== by 0x401197: main (main.cpp:6) ==8895== Address 0x4d8dc80 is 0 bytes inside a block of size 4 free'd ==8895== at 0x4836EAB: operator delete(void*) (vg_replace_malloc.c:576) ==8895== by 0x401183: main (main.cpp:4) ==8895== Block was alloc'd at ==8895== at 0x4835DEF: operator new(unsigned long) (vg_replace_malloc.c:334) ==8895== by 0x401173: main (main.cpp:3) ==8895== ==8895== ==8895== HEAP SUMMARY: ==8895== in use at exit: 0 bytes in 0 blocks ==8895== total heap usage: 2 allocs, 3 frees, 72,708 bytes allocated ==8895== ==8895== All heap blocks were freed -- no leaks are possible ==8895== ==8895== For counts of detected and suppressed errors, rerun with: -v ==8895== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 对释放的内存读/写 本质上说，系统会在堆上维护一个动态内存链表，如果被释放，就意味着该块内存可以继续被分配给其他部分，如果内存被释放后再访问，就可能覆盖其他部分的信息，这是一种严重的错误。 错误显示输出结果如下：Invalid write of size 4 #include int main() { int *iptr = new int; //动态内存 delete iptr; *iptr = 9; // 释放后仍然读写 return 0; } 编译程序时，需要加上加上-g,O0,Wall选项： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 分析这段程序： $ valgrind --tool=memcheck --leak-check=full ./main $ valgrind --tool=memcheck --leak-check=full ./main ==8246== Memcheck, a memory error detector ==8246== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==8246== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==8246== Command: ./main ==8246== ==8246== Invalid write of size 4 ==8246== at 0x401188: main (main.cpp:5) ==8246== Address 0x4d8dc80 is 0 bytes inside a block of size 4 free'd ==8246== at 0x4836EAB: operator delete(void*) (vg_replace_malloc.c:576) ==8246== by 0x401183: main (main.cpp:4) ==8246== Block was alloc'd at ==8246== at 0x4835DEF: operator new(unsigned long) (vg_replace_malloc.c:334) ==8246== by 0x401173: main (main.cpp:3) ==8246== ==8246== ==8246== HEAP SUMMARY: ==8246== in use at exit: 0 bytes in 0 blocks ==8246== total heap usage: 2 allocs, 2 frees, 72,708 bytes allocated ==8246== ==8246== All heap blocks were freed -- no leaks are possible ==8246== ==8246== For counts of detected and suppressed errors, rerun with: -v ==8246== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) new和delete不匹配 由于 C++ 兼容 C，而 C 与 C++ 的内存申请和释放函数是不同的，因此在 C++ 程序中，就有两套动态内存管理函数。一条不变的规则就是采用 C 方式申请的内存就用 C 方式释放；用 C++ 方式申请的内存，用 C++ 方式释放。也就是用 malloc/alloc/realloc 方式申请的内存，用 free 释放；用 new 方式申请的内存用 delete 释放。 在上述程序中，用 malloc 方式申请了内存却用 delete 来释放，new申请动态数组，delete无法释放数组，虚delete[]释放动态数组。申请与释放不匹配时，显示输出结果如下：Mismatched free() /delete/delete[] #include int main() { int *ptr = (int *)malloc(1 * sizeof(int)); //动态内存 *ptr = -1; delete ptr; // malloc与delete不匹配 int *arr_ptr = new int[10]; delete arr_ptr; // delete无法释放数组，不匹配 return 0; } 编译程序时，需要加上加上-g,O0,Wall选项： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 分析这段程序： $ valgrind --tool=memcheck --leak-check=full ./main $ valgrind --tool=memcheck --leak-check=full ./main ==11344== Memcheck, a memory error detector ==11344== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==11344== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==11344== Command: ./main ==11344== ==11344== Mismatched free() / delete / delete [] ==11344== at 0x4836EAB: operator delete(void*) (vg_replace_malloc.c:576) ==11344== by 0x40119D: main (main.cpp:5) ==11344== Address 0x4d8dc80 is 0 bytes inside a block of size 4 alloc'd ==11344== at 0x483577F: malloc (vg_replace_malloc.c:299) ==11344== by 0x401183: main (main.cpp:3) ==11344== ==11344== Mismatched free() / delete / delete [] ==11344== at 0x4836EAB: operator delete(void*) (vg_replace_malloc.c:576) ==11344== by 0x4011B7: main (main.cpp:8) ==11344== Address 0x4d8dcd0 is 0 bytes inside a block of size 40 alloc'd ==11344== at 0x483650F: operator new[](unsigned long) (vg_replace_malloc.c:423) ==11344== by 0x4011A7: main (main.cpp:7) ==11344== ==11344== ==11344== HEAP SUMMARY: ==11344== in use at exit: 0 bytes in 0 blocks ==11344== total heap usage: 3 allocs, 3 frees, 72,748 bytes allocated ==11344== ==11344== All heap blocks were freed -- no leaks are possible ==11344== ==11344== For counts of detected and suppressed errors, rerun with: -v ==11344== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0) src和dst内存覆盖 C语言的强大和可怕之处在于其可以直接操作内存，C标准库中提供了大量这样的函数，比如使用C标准库中的strcpy，strncpy，memcpy，strcat时，需要设置源地址（src）和目标地址(dst)，src和dst所指向的地址不能发生重叠，否则结果将不可预期。 输出结果会显示：Source and destination overlap in strncpy(dst地址，src地址，地址相差长度) #include #include #include int main(int argc, char *argv[]) { char str[128]; memset(str, '-1', sizeof(str)); // 字符'\\0'在内存中assic码就是数值0 strncpy(str + 20, str, 20); // Good strncpy(str + 20, str, 21); // Overlap，发生覆盖 memset(str, '-1', sizeof(str)); strncpy(str, str + 20, 20); // Good strncpy(str, str + 20, 21); // Overlap，发生覆盖 memset(str, '-1', sizeof(str)); str[39] = '\\0'; // 29-39(长度20) 复制到-> 0-19(长度20) strcpy(str, str + 20); // Good memset(str, '-1', sizeof(str)); str[40] = '\\0'; // 29-40(长度21) 复制到-> 0-19(长度20)，发生覆盖 strcpy(str, str + 20); // Overlap return 0; } 编译程序时，需要加上加上-g,O0,Wall选项： $ g++ -std=c++11 -g -O0 -Wall main.cpp -o main 使用 Valgrind 分析这段程序： $ valgrind --tool=memcheck --leak-check=full ./main $ valgrind --tool=memcheck --leak-check=full ./main ==21189== Memcheck, a memory error detector ==21189== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==21189== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==21189== Command: ./main ==21189== ==21189== Source and destination overlap in strncpy(0x1ffeffe829, 0x1ffeffe815, 21) ==21189== at 0x48393E0: __strncpy_sse2_unaligned (vg_replace_strmem.c:554) ==21189== by 0x4011A7: main (main.cpp:8) ==21189== ==21189== Source and destination overlap in strncpy(0x1ffeffe815, 0x1ffeffe829, 21) ==21189== at 0x48393E0: __strncpy_sse2_unaligned (vg_replace_strmem.c:554) ==21189== by 0x4011F5: main (main.cpp:12) ==21189== ==21189== Source and destination overlap in strcpy(0x1ffeffe800, 0x1ffeffe814) ==21189== at 0x4838E68: strcpy (vg_replace_strmem.c:512) ==21189== by 0x401257: main (main.cpp:20) ==21189== ==21189== ==21189== HEAP SUMMARY: ==21189== in use at exit: 0 bytes in 0 blocks ==21189== total heap usage: 1 allocs, 1 frees, 72,704 bytes allocated ==21189== ==21189== All heap blocks were freed -- no leaks are possible ==21189== ==21189== For counts of detected and suppressed errors, rerun with: -v ==21189== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0) 输出说明程序的8，12，20行，源地址和目标地址设置出现了重叠，Valgrind均准确地发现了问题。 参数选项 注：参数选项为摘抄，没有验证 基本选项： 这些选项对所有工具都有效。 -h --help 显示所有选项的帮助，包括内核和选定的工具两者。 --help-debug 和--help相同，并且还能显示通常只有Valgrind的开发人员使用的调试选项。 --version 显示Valgrind内核的版本号。工具可以有他们自已的版本号。这是一种保证工具只在它们可以运行的内核上工作的一种设置。这样可以减少在工具和内核之间版本兼容性导致奇怪问题的概率。 -q --quiet 安静的运行，只打印错误信息。在进行回归测试或者有其它的自动化测试机制时会非常有用。 -v --verbose 显示详细信息。在各个方面显示你的程序的额外信息，例如：共享对象加载，使用的重置，执行引擎和工具的进程，异常行为的警告信息。重复这个标记可以增加详细的级别。 -d 调试Valgrind自身发出的信息。通常只有Valgrind开发人员对此感兴趣。重复这个标记可以产生更详细的输出。如果你希望发送一个bug报告，通过-v -v -d -d生成的输出会使你的报告更加有效。 --tool= [default: memcheck] 运行toolname指定的Valgrind，例如，Memcheck, Addrcheck, Cachegrind,等等。 --trace-children= [default: no] 当这个选项打开时，Valgrind会跟踪到子进程中。这经常会导致困惑，而且通常不是你所期望的，所以默认这个选项是关闭的。 --track-fds= [default: no] 当这个选项打开时，Valgrind会在退出时打印一个打开文件描述符的列表。每个文件描述符都会打印出一个文件是在哪里打开的栈回溯，和任何与此文件描述符相关的详细信息比如文件名或socket信息。 --time-stamp= [default: no] 当这个选项打开时，每条信息之前都有一个从程序开始消逝的时间，用天，小时，分钟，秒和毫秒表示。 --log-fd= [default: 2, stderr] 指定Valgrind把它所有的消息都输出到一个指定的文件描述符中去。默认值2, 是标准错误输出(stderr)。注意这可能会干扰到客户端自身对stderr的使用, Valgrind的输出与客户程序的输出将穿插在一起输出到stderr。 --log-file= 指定Valgrind把它所有的信息输出到指定的文件中。实际上，被创建文件的文件名是由filename、'.'和进程号连接起来的（即.），从而每个进程创建不同的文件。 --log-file-exactly= 类似于--log-file，但是后缀\".pid\"不会被添加。如果设置了这个选项，使用Valgrind跟踪多个进程，可能会得到一个乱七八糟的文件。 --log-file-qualifier= 当和--log-file一起使用时，日志文件名将通过环境变量$VAR来筛选。这对于MPI程序是有益的。更多的细节，查看手册2.3节 \"注解\"。 --log-socket= 指定Valgrind输出所有的消息到指定的IP，指定的端口。当使用1500端口时，端口有可能被忽略。如果不能建立一个到指定端口的连接，Valgrind将输出写到标准错误(stderr)。这个选项经常和一个Valgrind监听程序一起使用。更多的细节，查看手册2.3节 \"注解\"。 错误相关选项： 这些选项适用于所有产生错误的工具，比如Memcheck, 但是Cachegrind不行。 --xml= [default: no] 当这个选项打开时，输出将是XML格式。这是为了使用Valgrind的输出做为输入的工具，例如GUI前端更加容易些。目前这个选项只在Memcheck时生效。 --xml-user-comment= 在XML开头 附加用户注释，仅在指定了--xml=yes时生效，否则忽略。 --demangle= [default: yes] 打开/关闭C++的名字自动解码。默认打开。当打开时，Valgrind将尝试着把编码过的C++名字自动转回初始状态。这个解码器可以处理g++版本为2.X,3.X或4.X生成的符号。一个关于名字编码解码重要的事实是，禁止文件中的解码函数名仍然使用他们未解码的形式。Valgrind在搜寻可用的禁止条目时不对函数名解码，因为这将使禁止文件内容依赖于Valgrind的名字解码机制状态，会使速度变慢，且无意义。 --num-callers= [default: 12] 默认情况下，Valgrind显示12层函数调用的函数名有助于确定程序的位置。可以通过这个选项来改变这个数字。这样有助在嵌套调用的层次很深时确定程序的位置。注意错误信息通常只回溯到最顶上的4个函数。(当前函数，和它的3个调用者的位置)。所以这并不影响报告的错误总数。这个值的最大值是50。注意高的设置会使Valgrind运行得慢，并且使用更多的内存,但是在嵌套调用层次比较高的程序中非常实用。 --error-limit= [default: yes] 当这个选项打开时，在总量达到10,000,000，或者1,000个不同的错误，Valgrind停止报告错误。这是为了避免错误跟踪机制在错误很多的程序下变成一个巨大的性能负担。 --error-exitcode= [default: 0] 指定如果Valgrind在运行过程中报告任何错误时的退出返回值，有两种情况；当设置为默认值(零)时，Valgrind返回的值将是它模拟运行的程序的返回值。当设置为非零值时，如果Valgrind发现任何错误时则返回这个值。在Valgrind做为一个测试工具套件的部分使用时这将非常有用，因为使测试工具套件只检查Valgrind返回值就可以知道哪些测试用例Valgrind报告了错误。 --show-below-main= [default: no] 默认地，错误时的栈回溯不显示main()之下的任何函数(或者类似的函数像glibc的__libc_start_main()，如果main()没有出现在栈回溯中)；这些大部分都是令人厌倦的C库函数。如果打开这个选项，在main()之下的函数也将会显示。 --suppressions= [default: $PREFIX/lib/valgrind/default.supp] 指定一个额外的文件读取不需要理会的错误；你可以根据需要使用任意多的额外文件。 --gen-suppressions= [default: no] 当设置为yes时，Valgrind将会在每个错误显示之后自动暂停并且打印下面这一行：---- Print suppression ? --- [Return/N/n/Y/y/C/c] ----这个提示的行为和--db-attach选项(见下面)相同。如果选择是，Valgrind会打印出一个错误的禁止条目，你可以把它剪切然后粘帖到一个文件，如果不希望在将来再看到这个错误信息。当设置为all时，Valgrind会对每一个错误打印一条禁止条目，而不向用户询问。这个选项对C++程序非常有用，它打印出编译器调整过的名字。注意打印出来的禁止条目是尽可能的特定的。如果需要把类似的条目归纳起来，比如在函数名中添加通配符。并且，有些时候两个不同的错误也会产生同样的禁止条目，这时Valgrind就会输出禁止条目不止一次，但是在禁止条目的文件中只需要一份拷贝(但是如果多于一份也不会引起什么问题)。并且，禁止条目的名字像;名字并不是很重要，它只是和-v选项一起使用打印出所有使用的禁止条目记录。 --db-attach= [default: no] 当这个选项打开时，Valgrind将会在每次打印错误时暂停并打出如下一行：---- Attach to debugger ? --- [Return/N/n/Y/y/C/c] ---- 按下回车,或者N、回车，n、回车，Valgrind不会对这个错误启动调试器。按下Y、回车，或者y、回车，Valgrind会启动调试器并设定在程序运行的这个点。当调试结束时，退出，程序会继续运行。在调试器内部尝试继续运行程序，将不会生效。按下C、回车，或者c、回车，Valgrind不会启动一个调试器，并且不会再次询问。注意：--db-attach=yes与--trace-children=yes有冲突。你不能同时使用它们。Valgrind在这种情况下不能启动。 --db-command= [default: gdb -nw %f %p] 通过--db-attach指定如何使用调试器。默认的调试器是gdb.默认的选项是一个运行时扩展Valgrind的模板。 %f会用可执行文件的文件名替换，%p会被可执行文件的进程ID替换。 这指定了Valgrind将怎样调用调试器。默认选项不会因为在构造时是否检测到了GDB而改变,通常是/usr/bin/gdb.使用这个命令，你可以指定一些调用其它的调试器来替换。 给出的这个命令字串可以包括一个或多个%p %f扩展。每一个%p实例都被解释成将调试的进程的PID，每一个%f实例都被解释成要调试的进程的可执行文件路径。 --input-fd= [default: 0, stdin] 使用--db-attach=yes和--gen-suppressions=yes选项，在发现错误时，Valgrind会停下来去读取键盘输入。默认地，从标准输入读取，所以关闭了标准输入的程序会有问题。这个选项允许你指定一个文件描述符来替代标准输入读取。 --max-stackframe= [default: 2000000] 栈的最大值。如果栈指针的偏移超过这个数量，Valgrind则会认为程序是切换到了另外一个栈执行。如果在程序中有大量的栈分配的数组，你可能需要使用这个选项。valgrind保持对程序栈指针的追踪。如果栈指针的偏移超过了这个数量，Valgrind假定你的程序切换到了另外一个栈，并且Memcheck行为与栈指 针的偏移没有超出这个数量将会不同。通常这种机制运转得很好。然而，如果你的程序在栈上申请了大的结构，这种机制将会表现得愚蠢，并且Memcheck将会报告大量的非法栈内存访问。这个选项允许把这个阀值设置为其它值。应该只在Valgrind的调试输出中显示需要这么做时才使用这个选项。在这种情况下，它会告诉你应该指定的新的阀值。普遍地，在栈中分配大块的内存是一个坏的主意。因为这很容易用光你的栈空间，尤其是在内存受限的系统或者支持大量小堆栈的线程的系统上，因为Memcheck执行的错误检查，对于堆上的数据比对栈上的数据要高效很多。如果你使用这个选项，你可能希望考虑重写代码在堆上分配内存而不是在栈上分配。 MALLOC()相关的选项: 对于使用自有版本的malloc() (例如Memcheck和massif)，下面的选项可以使用。 --alignment= [default: 8] 默认Valgrind的malloc(),realloc(), 等等，是8字节对齐地址的。这是大部分处理器的标准。然而，一些程序可能假定malloc()等总是返回16字节或更多对齐的内存。提供的数值必须在8和4096区间之内，并且必须是2的幂数。 非通用选项： 这些选项可以用于所有的工具，它们影响Valgrind core的几个特性。大部分人不会用到这些选项。 --run-libc-freeres= [default: yes] GNU C库(libc.so)，所有程序共用的，可能会分配一部分内存自已用。通常在程序退出时释放内存并不麻烦 -- 这里没什么问题，因为Linux内核在一个进程退出时会回收进程全部的资源，所以这只是会造成速度慢。glibc的作者认识到这样会导致内存检查器，像Valgrind，在退出时检查内存错误的报告glibc的内存泄漏问题，为了避免这个问题，他们提供了一个libc_freeres()例程特别用来让glibc释放分配的所有内存。因此Memcheck在退出时尝试着去运行libc_freeres()。不幸的是，在glibc的一些版本中，libc_freeres是有bug会导致段错误的。这在Red Hat 7.1上有特别声明。所以，提供这个选项来决定是否运行libc_freeres。如果你的程序看起来在Valgrind上运行得很好，但是在退出时发生段错误，你可能需要指定--run-libc-freeres=no来修正，这将可能错误的报告libc.so的内存泄漏。 --sim-hints=hint1,hint2,... 传递杂凑的提示给Valgrind，轻微的修改模拟行为的非标准或危险方式，可能有助于模拟奇怪的特性。默认没有提示打开。小心使用！目前已知的提示有： l lax-ioctls: 对ioctl的处理非常不严格，唯一的假定是大小是正确的。不需要在写时缓冲区完全的初始化。没有这个，用大量的奇怪的ioctl命令来使用一些设备驱动将会非常烦人。 l enable-inner:打开某些特殊的效果，当运行的程序是Valgrind自身时。 --kernel-variant=variant1,variant2,... 处理系统调用和ioctls在这个平台的默认核心上产生不同的变量。这有助于运行在改进过的内核或者支持非标准的ioctls上。小心使用。如果你不理解这个选项做的是什么那你几乎不需要它。已经知道的变量有： l bproc: 支持X86平台上的sys_broc系统调用。这是为了运行在BProc，它是标准Linux的一个变种，有时用来构建集群。 --show-emwarns= [default: no] 当这个选项打开时，Valgrind在一些特定的情况下将对CPU仿真产生警告。通常这些都是不引人注意的。 --smc-check= [default: stack] 这个选项控制Valgrind对自我修改的代码的检测。Valgrind可以不做检测，可以检测栈中自我修改的代码，或者任意地方检测自我修改的代码。注意默认选项是捕捉绝大多数情况，到目前我们了解的情况为止。使用all选项时会极大的降低速度。(但是用none选项运行极少影响速度，因为对大多数程序，非常少的代码被添加到栈中) 调试VALGRIND选项： 还有一些选项是用来调试Valgrind自身的。在运行一般的东西时不应该需要的。如果你希望看到选项列表，使用--help-debug选项。 内存检查选项： --leak-check= [default: summary] 当这个选项打开时，当客户程序结束时查找内存泄漏。内存泄漏意味着有用malloc分配内存块，但是没有用free释放，而且没有指针指向这块内存。这样的内存块永远不能被程序释放，因为没有指针指向它们。如果设置为summary，Valgrind会报告有多少内存泄漏发生了。如果设置为full或yes，Valgrind给出每一个独立的泄漏的详细信息。 --show-reachable= [default: no] 当这个选项关闭时，内存泄漏检测器只显示没有指针指向的内存块，或者只能找到指向块中间的指针。当这个选项打开时，内存泄漏检测器还报告有指针指向的内存块。这些块是最有可能出现内存泄漏的地方。你的程序可能，至少在原则上，应该在退出前释放这些内存块。这些有指针指向的内存块和没有指针指向的内存块，或者只有内部指针指向的块，都可能产生内存泄漏，因为实际上没有一个指向块起始的指针可以拿来释放，即使你想去释放它。 --leak-resolution= [default: low] 在做内存泄漏检查时，确定memcheck将怎么样考虑不同的栈是相同的情况。当设置为low时，只需要前两层栈匹配就认为是相同的情况；当设置为med，必须要四层栈匹配，当设置为high时，所有层次的栈都必须匹配。对于hardcore内存泄漏检查，你很可能需要使用--leak-resolution=high和--num-callers=40或者更大的数字。注意这将产生巨量的信息，这就是为什么默认选项是四个调用者匹配和低分辨率的匹配。注意--leak-resolution= 设置并不影响memcheck查找内存泄漏的能力。它只是改变了结果如何输出。 --freelist-vol= [default: 5000000] 当客户程序使用free(C中)或者delete(C++)释放内存时，这些内存并不是马上就可以用来再分配的。这些内存将被标记为不可访问的，并被放到一个已释放内存的队列中。这样做的目的是，使释放的内存再次被利用的点尽可能的晚。这有利于memcheck在内存块释放后这段重要的时间检查对块不合法的访问。这个选项指定了队列所能容纳的内存总容量，以字节为单位。默认的值是5000000字节。增大这个数目会增加memcheck使用的内存，但同时也增加了对已释放内存的非法使用的检测概率。 --workaround-gcc296-bugs= [default: no] 当这个选项打开时，假定读写栈指针以下的一小段距离是gcc 2.96的bug，并且不报告为错误。距离默认为256字节。注意gcc 2.96是一些比较老的Linux发行版(RedHat 7.X)的默认编译器，所以你可能需要使用这个选项。如果不是必要请不要使用这个选项，它可能会使一些真正的错误溜掉。一个更好的解决办法是使用较新的，修正了这个bug的gcc/g++版本。 --partial-loads-ok= [default: no] 控制memcheck如何处理从地址读取时字长度，字对齐，因此哪些字节是可以寻址的，哪些是不可以寻址的。当设置为yes是，这样的读取并不抛出一个寻址错误。而是从非法地址读取的V字节显示为未定义，访问合法地址仍然是像平常一样映射到内存。设置为no时，从部分错误的地址读取与从完全错误的地址读取同样处理：抛出一个非法地址错误，结果的V字节显示为合法数据。注意这种代码行为是违背ISO C/C++标准，应该被认为是有问题的。如果可能，这种代码应该修正。这个选项应该只是做为一个最后考虑的方法。 --undef-value-errors= [default: yes] 控制memcheck是否检查未定义值的危险使用。当设为yes时，Memcheck的行为像Addrcheck, 一个轻量级的内存检查工具，是Valgrind的一个部分，它并不检查未定义值的错误。使用这个选项，如果你不希望看到未定义值错误。 CACHEGRIND选项： 手动指定I1/D1/L2缓冲配置，大小是用字节表示的。这三个必须用逗号隔开，中间没有空格，例如： valgrind --tool=cachegrind --I1=65535,2,64你可以指定一个，两个或三个I1/D1/L2缓冲。如果没有手动指定，每个级别使用普通方式(通过CPUID指令得到缓冲配置，如果失败，使用默认值)得到的配置。 --I1=,, 指定第一级指令缓冲的大小，关联度和行大小。 --D1=,, 指定第一级数据缓冲的大小，关联度和行大小。 --L2=,, 指定第二级缓冲的大小，关联度和行大小。 CALLGRIND选项： --heap= [default: yes] 当这个选项打开时，详细的追踪堆的使用情况。关闭这个选项时，massif.pid.txt或massif.pid.html将会非常的简短。 --heap-admin= [default: 8] 每个块使用的管理字节数。这只能使用一个平均的估计值，因为它可能变化。glibc使用的分配器每块需要4~15字节，依赖于各方面的因素。管理已经释放的块也需要空间，尽管massif不计算这些。 --stacks= [default: yes] 当打开时，在剖析信息中包含栈信息。多线程的程序可能有多个栈。 --depth= [default: 3] 详细的堆信息中调用过程的深度。增加这个值可以给出更多的信息，但是massif会更使这个程序运行得慢，使用更多的内存，并且产生一个大的massif.pid.txt或者massif.pid.hp文件。 --alloc-fn= 指定一个分配内存的函数。这对于使用malloc()的包装函数是有用的，可以用它来填充原来无效的上下文信息。(这些函数会给出无用的上下文信息，并在图中给出无意义的区域)。指定的函数在上下文中被忽略，例如，像对malloc()一样处理。这个选项可以在命令行中重复多次，指定多个函数。 --format= [default: text] 产生text或者HTML格式的详细堆信息，文件的后缀名使用.txt或者.html。 HELGRIND选项： --private-stacks= [default: no] 假定线程栈是私有的。 --show-last-access= [default: no] 显示最后一次字访问出错的位置。 LACKEY选项： --fnname= [default: _dl_runtime_resolve()] 对函数计数。 --detailed-counts= [default: no] 对读取，存储和alu操作计数。 reference Valgrind Documentation valgrind 详细说明 使用 Valgrind 检测 C++ 内存泄漏 内存泄漏检查工具valgrind使用方法 valgrind详解-参数说明 C++之控制内存分配 "},"linux-system/":{"url":"linux-system/","title":"linux系统编程","keywords":"","body":"linux系统编程linux系统编程 进程 进程相关概念 环境变量 进程控制 exec函数族 wait回收子进程 进程间通信IPC方法 pipe管道 FIFO命名管道 mmap共享存储映射 文件进程间通信 信号 信号的概念 信号的产生 信号集操作函数 信号捕捉 SIGCHLD信号 信号传参 中断系统调用 守护进程 终端 进程组 会话 守护进程 线程同步 同步概念 互斥量mutex 死锁 读写锁 条件变量 信号量 进程间同步 "},"linux-system/01-process.html":{"url":"linux-system/01-process.html","title":"进程","keywords":"","body":"进程进程相关概念程序和进程并发单道程序设计多道程序设计CPU和MMU进程控制块PCB进程状态环境变量常见环境变量getenv函数setenv函数unsetenv函数进程控制fork函数getpid函数getppid函数getuid函数getgid函数进程共享gdb调试exec函数族execl函数execlp函数execvp函数exec函数族一般规律wait回收子进程孤儿进程僵尸进程wait函数waitpid函数进程 [TOC] 进程相关概念 程序和进程 并发 单道程序设计 多道程序设计 CPU和MMU 进程控制块PCB 进程状态 环境变量 常见环境变量 getenv函数 setenv函数 unsetenv函数 进程控制 fork函数 getpid函数 getppid函数 getuid函数 getgid函数 进程共享 gdb调试 exec函数族 execl函数 execlp函数 execvp函数 exec函数族一般规律 wait回收子进程 孤儿进程 僵尸进程 wait函数 waitpid函数 进程相关概念 程序和进程 程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁....) 进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程) 程序 → 剧本(纸) 进程 → 戏(舞台、演员、灯光、道具...) 同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响) 如：同时开两个终端。各自都有一个bash但彼此ID不同。 并发 并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。 例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。 单道程序设计 所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。 多道程序设计 在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。 时钟中断即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。 在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 1s = 1000ms, 1ms = 1000us, 1us = 1000ns 1000000000 实质上，并发是宏观并行，微观串行！ -----推动了计算机蓬勃发展，将人类引入了多媒体时代。 CPU和MMU {width=\"7.263888888888889in\" height=\"3.904166666666667in\"} 进程控制块PCB 我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。 /usr/src/linux-headers-3.16.0-30/include/linux/sched.h文件中可以查看struct task_struct 结构体定义。其内部成员有很多，我们重点掌握以下部分即可： * 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。 * 进程的状态，有就绪、运行、挂起、停止等状态。 * 进程切换时需要保存和恢复的一些CPU寄存器。 * 描述虚拟地址空间的信息。 * 描述控制终端的信息。 * 当前工作目录（Current Working Directory）。 * umask掩码。 * 文件描述符表，包含很多指向file结构体的指针。 * 和信号相关的信息。 * 用户id和组id。 * 会话（Session）和进程组。 * 进程可以使用的资源上限（Resource Limit）。 进程状态 进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。 {width=\"4.55in\" height=\"3.6319444444444446in\"} Linux进程状态：R (TASK_RUNNING)，可执行状态。 只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。 Linux进程状态：S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。 处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。 Linux进程状态：D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。 与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。 Linux进程状态：T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。 向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。） 向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。 Linux进程状态：Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。 进程在退出的过程中，处于TASK_DEAD状态。 Linux进程状态：X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁。 而进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程（进程？线程？参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。） 此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。 环境变量 环境变量，是指在操作系统中用来指定操作系统运行环境的一些参数。通常具备以下特征： ① 字符串(本质) ② 有统一的格式：名=值[:值] ③ 值用来描述进程环境信息。 存储形式：与命令行参数类似。char *[]数组，数组名environ，内部存储字符串，NULL作为哨兵结尾。 使用形式：与命令行参数类似。 加载位置：与命令行参数类似。位于用户区，高于stack的起始位置。 引入环境变量表：须声明环境变量 extern char ** environ; 练习：打印当前进程的所有环境变量。 【environ.c】 常见环境变量 按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母加下划线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境变量定义了进程的运行环境，一些比较重要的环境变量的含义如下： env # 查看所有环境变量 PATH 可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值： echo $PATH SHELL 当前Shell，它的值通常是/bin/bash。 echo $SHELL /bin/bash TERM 当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。 echo $TERM xterm-256color LANG 语言和locale，决定了字符编码以及时间、货币等信息的显示格式。 HOME 当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。 getenv函数 获取环境变量值 char *getenv(const char *name); 成功：返回环境变量的值；失败：NULL (name不存在) 练习：编程实现getenv函数获取环境变量值。 【getenv.c】 setenv函数 设置环境变量的值 int setenv(const char *name, const char *value, int overwrite); 成功：0；失败：-1 参数overwrite取值： 1：覆盖原环境变量 0：不覆盖。(该参数常用于设置新环境变量，如：ABC = haha-day-night) unsetenv函数 删除环境变量name的定义 int unsetenv(const char *name); 成功：0；失败：-1 注意事项：name不存在仍返回0(成功)，当name命名为\"ABC=\"时则会出错。 进程控制 fork函数 创建一个子进程。 pid_t fork(void); 失败返回-1； 成功返回：① 父进程返回子进程的ID(非负) ②子进程返回 0 pid_t 类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1) 注意fork返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。 循环创建n个子进程 一次fork函数调用可以创建一个子进程。那么创建N个子进程应该怎样实现呢？ 简单想，for(i = 0; i {width=\"5.631944444444445in\" height=\"3.267361111111111in\"} 从上图我们可以很清晰的看到，当n为3时候，循环创建了(2^n)-1个子进程，而不是N的子进程。需要在循环的过程，保证子进程不再执行fork ，因此当(fork() == 0)时，子进程应该立即break才正确。所有子进程都是主父进程fork出来的,直接子进程. 练习：通过命令行参数指定创建进程的个数，每个进程休眠1S打印自己是第几个被创建的进程。如：第1个子进程休眠0秒打印：“我是第1个子进程”；第2个进程休眠1秒打印：“我是第2个子进程”；第3个进程休眠2秒打印：“我是第3个子进程”。 【fork1.c】 通过该练习掌握框架：循环创建n个子进程，使用循环因子i对创建的子进程加以区分。 getpid函数 获取当前进程ID pid_t getpid(void); getppid函数 获取当前进程的父进程ID pid_t getppid(void); 区分一个函数是“系统函数”还是“库函数”依据： 是否访问内核数据结构 是否访问外部硬件资源 二者有任一 → 系统函数； 二者均无 → 库函数 getuid函数 获取当前进程使用用户ID uid_t getuid(void); 获取当前进程有效用户ID uid_t geteuid(void); getgid函数 获取当前进程使用用户组ID gid_t getgid(void); 获取当前进程有效用户组ID gid_t getegid(void); 进程共享 父子进程之间在fork后。有哪些相同，那些相异之处呢？ 刚fork之后： 父子进程相同处: ==全局变量==、 .data、 .text、 栈、 堆、 环境变量、 用户ID、 宿主目录、 进程工作目录、 信号处理方式 ... 父子进程不同处: 进程ID 父进程ID fork返回值 进程运行时间 闹钟(定时器) 未决信号集 似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？ 当然不是!父子进程间遵循==读时共享写时复制==的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。 重点注意！父子进程不共享全局变量！(刚fork之后相同,读时共享写时复制) 【重点】：父子进程共享： 文件描述符(打开文件的结构体) mmap建立的映射区 (进程间通信详解) 特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。 练习：编写程序测试，父子进程是否共享全局变量。 【fork_shared.c】 gdb调试 使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。 # 设置gdb在fork之后跟踪子进程 set follow-fork-mode child # 设置跟踪父进程 set follow-fork-mode parent 注意，一定要在fork函数调用之前设置才有效。 练习：gdb调试跟踪父子进程【follow_fork.c】 exec函数族 fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间 代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。 将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。 其实有六种以exec开头的函数，统称exec函数： int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char *const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); execl函数 加载一个进程， 通过 路径+程序名 来加载。 int execl(const char *path, const char *arg, ...); 成功：无返回；失败：-1 对比execlp，如加载\"ls\"命令带有-l，-F参数 execlp(\"ls\", \"ls\", \"-l\", \"-F\", NULL); 使用程序名在PATH中搜索。 execl(\"/bin/ls\", \"ls\", \"-l\", \"-F\", NULL); 使用参数1给出的绝对路径搜索。 execlp函数 加载一个进程，借助PATH环境变量 int execlp(const char *file, const char *arg, ...); 成功：无返回；失败：-1 参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。 该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。 execvp函数 加载一个进程，使用自定义环境变量env int execvp(const char *file, const char *argv[]); 变参形式： ①... ② argv[] (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, ...)) 变参终止条件：① NULL结尾 ② 固参指定 execvp与execlp参数形式不同，原理一致。 练习：将当前系统中的进程信息，打印到文件中。 【exec_ps.c】 exec函数族一般规律 exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。 l (list) 命令行参数列表 p (path) 搜素file时使用path变量 v (vector) 使用命令行参数数组 e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量 事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。 {width=\"4.8125in\" height=\"2.25in\"} wait回收子进程 孤儿进程 孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。 【orphan.c】 僵尸进程 僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。 【zoom .c】 特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。思考！用什么办法可清除掉僵尸进程呢？ wait函数 一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 父进程调用wait函数可以回收子进程终止信息。该函数有三个功能： 阻塞等待子进程退出 回收子进程残留资源 获取子进程结束状态(退出原因)。 pid_t wait(int *status); 成功：清理掉的子进程ID； 失败：-1 (没有子进程) 当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号) 可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组： WIFEXITED(status) 为非0 → 进程正常结束 WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数) WIFSIGNALED(status) 为非0 → 进程异常终止 WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。 WIFSTOPPED(status) 为非0 → 进程处于暂停状态 WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。 WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行 【wait1.c、wait2.c】 waitpid函数 作用同wait，但可指定pid进程清理，可以不阻塞。 pid_t waitpid(pid_t pid, int *status, in options); 成功：返回清理掉的子进程ID； 失败：-1(无子进程) 特殊参数和返回情况： 参数pid： > 0 回收指定ID的子进程 -1 回收任意子进程（相当于wait） 0 回收和当前调用waitpid一个组的所有子进程 指定进程组内的任意子进程 返回0：参3为WNOHANG非阻塞等待，且子进程正在运行。 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 【waitpid.c】 作业：父进程fork 3 个子进程，三个子进程一个调用ps命令， 一个调用自定义程序1(正常)，一个调用自定义程序2(会出段错误)。父进程使用waitpid对其子进程进行回收。 "},"linux-system/02-Inter-Process-Communication.html":{"url":"linux-system/02-Inter-Process-Communication.html","title":"进程间通信","keywords":"","body":"进程间通信IPC方法pipe管道管道的概念：pipe函数管道的读写行为管道缓冲区大小管道的优劣FIFO命名管道mmap共享存储映射存储映射I/Ommap父子进程通信匿名映射mmap无血缘关系进程间通信文件进程间通信进程间通信IPC方法 [TOC] pipe管道 管道的概念： pipe函数 管道的读写行为 管道缓冲区大小 管道的优劣 FIFO命名管道 mmap共享存储映射 存储映射I/O mmap父子进程通信 匿名映射 mmap无血缘关系进程间通信 文件进程间通信 Linux环境下，进程用户地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。 {width=\"2.8854166666666665in\" height=\"1.8645833333333333in\"} 在进程间完成数据传递需要借助操作系统提供特殊的方法，如： 文件、 pipe管道、 FIFO命名管道等。 mmap共享内存、 信号、 套接字、 消息队列、 随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有： pipe管道 (使用最简单) mmap共享映射区 (无血缘关系) 信号 (开销最小) 本地套接字 (最稳定) pipe管道 管道的概念： 管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质： 其本质是一个伪文件(实为内核缓冲区) 由两个文件描述符引用，一个表示读端，一个表示写端。 规定数据从管道的写端流入管道，从读端流出。 管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。 管道的局限性： ① 数据自己读不能自己写。 ② 数据一旦被读走，便不在管道中存在，不可反复读取。 ③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上单向流动。 ④ 只能在有公共祖先(有血缘关系)的进程间使用管道。 常见的通信方式有，单工通信、半双工通信、全双工通信。 pipe函数 创建管道 int pipe(int pipefd[2]); 成功：0； 失败：-1，设置errno 函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。 管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤： {width=\"3.463888888888889in\" height=\"4.1618055555555555in\"} 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。 父进程关闭管道读端fd[0]，子进程关闭管道写端fd[1]。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。 练习：父子进程使用管道通信，父写入字符串，子进程读出并，打印到屏幕。 【pipe.c】 思考：为甚么，程序中没有使用sleep函数，但依然能保证子进程运行时一定会读到数据呢？ 管道的读写行为 使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）： 1. 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。 2. 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。 3. 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。 4. 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。 管道的读写行为总结： 读管道： 管道中有数据，read返回实际读到的字节数。 管道中无数据： (1) 管道写端被全部关闭，read返回0 (好像读到文件结尾) (2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu) 写管道： 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止) 管道读端没有全部关闭： (1) 管道已满，write阻塞，直到管道中有空位置了才写入数据并返回。 (2) 管道未满，write将数据写入，并返回实际写入的字节数。 练习：使用管道实现父子进程间通信，完成：ls | wc –l。假定父进程实现ls，子进程实现wc。 ls命令正常会将结果集写出到stdout，但现在会写入管道的写端；wc –l 正常应该从stdin读取数据，但此时会从管道的读端读。 【pipe1.c】 程序执行，发现程序执行结束，shell还在阻塞等待用户输入。这是因为，shell → fork → ./pipe1， 程序pipe1的子进程将stdin重定向给管道，父进程执行的ls会将结果集通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符。 练习：使用管道实现兄弟进程间通信。 兄：ls 弟： wc -l 父：等待回收子进程。 要求，使用“循环创建N个子进程”模型创建兄弟进程，使用循环因子i标示。注意管道读写行为。 【pipe2.c】 测试：是否允许，一个pipe有一个写端，多个读端呢？是否允许有一个读端多个写端呢？ 【pipe3.c】 课后作业: 统计当前系统中进程ID大于10000的进程个数。 管道缓冲区大小 可以使用ulimit -a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为( 8 * 512 bytes = 4k )：pipe size (512 bytes, -p) 8 ulimit -a pipe size (512 bytes, -p) 8 也可以使用fpathconf函数，借助参数 选项来查看。使用该宏应引入头文件 long fpathconf(int fd, int name); 成功：返回管道的大小 失败：-1，设置errno 管道的优劣 优点： 简单，相比信号，套接字实现进程间通信，简单很多。 缺点： 只能单向通信，双向通信需建立两个管道。 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。 FIFO命名管道 FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。 FIFO是Linux基础文件类型中的一种(伪文件)。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。 创建方式： 命令： mkfifo 管道名 库函数： 头文件：sys/types.h、sys/stat.h int mkfifo(const char *filename, mode_t mode); 成功：返回0， 失败：返回-1，并设置errno 一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。 【fifo_w.c/fifo_r.c】 mmap共享存储映射 存储映射I/O 存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。 使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。 {width=\"3.3756944444444446in\" height=\"2.7180555555555554in\"} mmap函数 void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); 成功：返回创建的映射区首地址； 失败：MAP_FAILED宏 参数： addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL length： 欲创建映射区的大小 prot： 映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE flags： 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区) MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。 MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。 fd： 用来建立映射区的文件描述符 offset： 映射文件的偏移(4k的整数倍) munmap函数 同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。 int munmap(void *addr, size_t length); 成功：0； 失败：-1 借鉴malloc和free函数原型，尝试装自定义函数smalloc，sfree来完成映射区的建立和释放。思考函数接口该如何设计？ 【mmap_smalloc.c】 mmap注意事项 【mmap.c】 思考： 1. 可以open的时候O_CREAT一个新文件来创建映射区吗? 2. 如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？ 3. 文件描述符先关闭，对mmap映射有没有影响？ 4. 如果文件偏移量为1000会怎样？ 5. 对mem越界操作会怎样？ 6. 如果mem++，munmap可否成功？ 保证munmap是mmap的首地址即可 7. mmap什么情况下会调用失败？ 8. 如果不检测mmap的返回值，会怎样？ 总结：使用mmap时务必注意以下事项： 创建映射区的过程中，隐含着一次对映射文件的读操作。 当MAP_SHARED时，要求：映射区的权限应 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。 特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！ mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。 munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。 如果文件偏移量必须为4K的整数倍 mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。 mmap父子进程通信 父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags： ==MAP_PRIVATE==: (私有映射) 父子进程各自独占映射区； ==MAP_SHARED==: (共享映射) 父子进程共享映射区； 练习：父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享。 【mmap_fork.c】 结论：父子进程共享：1. 打开的文件 2. mmap建立的映射区(但必须要使用MAP_SHARED) 匿名映射 通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。 使用==MAP_ANONYMOUS== (或MAP_ANON)， 如: int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); \"4\"随意举例，该位置表大小，可依实际需要填写。 【map_anon_linux.c】 需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。 fd = open(\"/dev/zero\", O_RDWR); p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0); 【map_anon_unix.c】 mmap无血缘关系进程间通信 实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。 【mmp_shared_w.c / mmp_shared_r.c】 文件进程间通信 使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。 练习：编程测试，父子进程共享打开的文件。借助文件进行进程间通信。 【file_IPC.c】 思考，无血缘关系的进程可以打开同一个文件进行通信吗？为什么？ "},"linux-system/04-signal.html":{"url":"linux-system/04-signal.html","title":"信号","keywords":"","body":"信号信号的概念信号的机制与信号相关的事件和状态信号的编号信号4要素Linux常规信号一览表信号的产生终端按键产生信号硬件异常产生信号kill命令产生信号kill/raise/abort系统调用软件条件产生信号信号集操作函数设定信号集sigprocmask函数sigpending函数信号捕捉signal函数sigaction函数内核实现信号捕捉过程：竞态条件(时序竞态)：pause函数前导例时序问题分析解决时序竞态问题sigsuspend函数总结全局变量异步I/O可/不可重入函数SIGCHLD信号SIGCHLD的产生条件借助SIGCHLD信号回收子进程子进程结束status处理方式SIGCHLD信号注意问题信号传参发送信号传参捕捉函数传参中断系统调用信号 [TOC] 信号的概念 信号的机制 与信号相关的事件和状态 信号的编号 信号4要素 Linux常规信号一览表 信号的产生 终端按键产生信号 硬件异常产生信号 kill命令产生信号 kill/raise/abort系统调用 软件条件产生信号 信号集操作函数 设定信号集 sigprocmask函数 sigpending函数 信号捕捉 signal函数 sigaction函数 内核实现信号捕捉过程： 竞态条件(时序竞态)： pause函数 前导例 时序问题分析 解决时序竞态问题 sigsuspend函数 总结 全局变量异步I/O 可/不可重入函数 SIGCHLD信号 SIGCHLD的产生条件 借助SIGCHLD信号回收子进程 子进程结束status处理方式 SIGCHLD信号注意问题 信号传参 发送信号传参 捕捉函数传参 中断系统调用 信号的概念 信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪......他们都有共性：1. 简单 2. 不能携带大量信息 3. 满足某个特设条件才发送。 信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。 Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。 信号的机制 A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。 信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。 每个进程收到的所有信号，都是由内核负责发送的，内核处理。 与信号相关的事件和状态 产生信号: 按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\\ 系统调用产生，如：kill、raise、abort 软件条件产生，如：定时器alarm 硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误) 命令产生，如：kill命令 递达：递送并且到达进程。 未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 信号的处理方式: 执行默认动作 忽略(丢弃)(处理方式为忽略) 捕捉(调用户处理函数) Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。 阻塞信号集(信号屏蔽字)： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后) 未决信号集: 信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 信号产生后由于某些原因(主要是阻塞)不能递达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。 信号的编号 可以使用kill –l命令查看当前系统可使用的信号有哪些。 kill –l # 查看系统可使用的信号 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX 不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。 信号4要素 与变量三要素类似的，每个信号也有其必备4要素，分别是： 编号 名称 事件 默认处理动作 可通过man 7 signal查看帮助文档获取。 man 7 signal # 查看帮助文档 Signal Value Action Comment ──────────────────────────────────────────── SIGHUP 1 Term Hangup detected on controlling terminal or death of controlling process SIGINT 2 Term Interrupt from keyboard SIGQUIT 3 Core Quit from keyboard SIGILL 4 Core Illegal Instruction SIGFPE 8 Core Floating point exception SIGKILL 9 Term Kill signal SIGSEGV 11 Core Invalid memory reference SIGPIPE 13 Term Broken pipe: write to pipe with no readers SIGALRM 14 Term Timer signal from alarm(2) SIGTERM 15 Term Termination signal SIGUSR1 30,10,16 Term User-defined signal 1 SIGUSR2 31,12,17 Term User-defined signal 2 SIGCHLD 20,17,18 Ign Child stopped or terminated SIGCONT 19,18,25 Cont Continue if stopped SIGSTOP 17,19,23 Stop Stop process SIGTSTP 18,20,24 Stop Stop typed at terminal SIGTTIN 21,21,26 Stop Terminal input for background process SIGTTOU 22,22,27 Stop Terminal output for background process The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. 在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。 不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。 默认动作： Term：终止进程 Ign： 忽略信号 (默认即时对该种信号忽略操作) Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试) Stop：停止（暂停）进程 Cont：继续运行进程 注意从man 7 signal帮助文档中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. 这里特别强调了9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。 另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号!! Linux常规信号一览表 1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程 2) SIGINT：当用户按下了Ctrl+C组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。 3) SIGQUIT：当用户按下ctrl+\\组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。 4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件 5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。 6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。 7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。 8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。 9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。 10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。 11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。 12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。 13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。 14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。 15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。 16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。 17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。 18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。 19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。 20) SIGTSTP：停止终端交互进程的运行。按下ctrl+z组合键时发出这个信号。默认动作为暂停进程。 21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。 22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。 23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。 24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。 25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。 26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。 27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。 28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。 29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。 30) SIGPWR：关机。默认动作为终止进程。 31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。 34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。 信号的产生 终端按键产生信号 Ctrl + C → 2) SIGINT（终止/中断） \"INT\" ----Interrupt Ctrl + Z → 20) SIGTSTP（暂停/停止） \"T\" ----Terminal 终端。 Ctrl + \\ → 3) SIGQUIT（退出） 硬件异常产生信号 除0操作 → 8) SIGFPE (浮点数例外) \"F\" -----float 浮点数。 非法访问内存 → 11) SIGSEGV (段错误) 总线错误 → 7) SIGBUS kill命令产生信号 kill命令产生信号： kill -SIGKILL pid # 给pid进程发送信号 kill/raise/abort系统调用 kill函数 kill函数：给指定进程发送指定信号(不一定杀死) int kill(pid_t pid, int sig); 成功：0； 失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno pid > 0: 发送信号给指定的进程。 pid = 0: 发送信号给 与调用kill函数进程属于同一进程组的所有进程。 pid sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。 进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。 权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root用户的pid) 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID 练习：循环创建5个子进程，任一子进程用kill函数终止其父进程。 【kill.c】 raise 函数 raise 函数：给当前进程自己发送指定信号(自己给自己发)。 raise(signo) 等价于 kill(getpid(), signo); int raise(int sig); 成功：0， 失败：非0值 abort 函数 abort 函数：给当前进程自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件 void abort(void); 无返回 软件条件产生信号 alarm函数 设置定时器(闹钟)。在指定seconds秒后，内核会给当前进程发送 14）SIGALRM信号。进程收到该信号，默认动作终止。缺点:精度秒级,一次只能定时一次。 每个(子)进程都有且只有唯一个定时器。 unsigned int alarm(unsigned int seconds); 返回0或剩余的秒数，无失败。 常用：取消定时器alarm(0)，返回旧闹钟余下秒数。 例：alarm(5) → 3sec → alarm(4) → 5sec → alarm(5) → alarm(0) 返回0 返回2 SIG 返回0 返回5 alarm定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸...无论进程处于何种状态，alarm都计时。 练习：编写程序，测试你使用的计算机1秒钟能数多少个数。 【alarm .c】 使用time命令查看程序执行的时间。 程序运行的瓶颈在于IO，优化程序，首选优化IO。 实际执行时间 = 系统时间 + 用户时间 + 等待时间 time xxx # 查看程序xxx执行的时间 setitimer函数 设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。 int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); 成功：0； 失败：-1，设置errno 参数：which：指定定时方式 ① 自然定时：ITIMER_REAL → 14）SIGLARM 计算自然时间 ② 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM 只计算进程占用cpu的时间 ③ 运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF 计算占用cpu及执行系统调用的时间 练习: 使用setitimer函数实现alarm函数，重复计算机1秒数数程序。 【setitimer.c】 拓展练习，结合man page编写程序，测试it_interval、it_value这两个参数的作用。 【setitimer1.c】 提示： it_value：定时的时长(第一次定时的时长) it_interval：用来设定两次定时任务之间间隔的时间(第二次后时长间隔周期) 两个参数都设置为0，即清0操作。 信号集操作函数 内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。 设定信号集 sigset_t set; // typedef unsigned long sigset_t; int sigemptyset(sigset_t *set); 将某个信号集清0 成功：0；失败：-1 int sigfillset(sigset_t *set); 将某个信号集置1 成功：0；失败：-1 int sigaddset(sigset_t *set, int signum); 将某个信号加入信号集 成功：0；失败：-1 int sigdelset(sigset_t *set, int signum); 将某个信号清出信号集 成功：0；失败：-1 int sigismember(const sigset_t *set, int signum);判断某个信号是否在信号集中 返回值：在集合：1；不在：0；出错：-1 sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。 对比认知select 函数。 sigprocmask函数 用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中) 严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。 int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); 成功：0； 失败：-1，设置errno 参数： how参数取值： 假设当前的信号屏蔽字为mask SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask & ~set SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。 set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。 oldset：传出参数，保存旧的信号屏蔽集。 sigpending函数 sigpending读取当前进程的未决信号集 int sigpending(sigset_t *set); set传出参数。 成功：0； 失败：-1，设置errno 练习：编写程序。把所有常规信号的未决状态打印至屏幕。 【sigpending.c】 信号捕捉 signal函数 注册一个信号捕捉函数： typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。 void (*signal(int signum, void (*sighandler_t)(int))) (int); 能看出这个函数代表什么意思吗？ 注意多在复杂结构中使用typedef。 sigaction函数 sigaction修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数） int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); 成功：0； 失败：-1，设置errno 参数： act：传入参数，新的处理方式。 oldact：传出参数，旧的处理方式。 【signal.c】 struct sigaction结构体 struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); }; 重点掌握： ① sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作 ② sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。 ③ sa_flags：通常设置为0，表使用默认属性。 sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用) sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用) 信号捕捉特性 进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。 XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。 阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队） 练习1：为某个信号设置捕捉函数 【sigaction1.c】 练习2： 验证在信号处理函数执行期间，该信号多次递送，那么只在处理函数之行结束后，处理一次。 【sigaction2.c】 练习3：验证sa_mask在捕捉函数执行期间的屏蔽作用。 【sigaction3.c】 内核实现信号捕捉过程： {width=\"4.291666666666667in\" height=\"3.3541666666666665in\"} 竞态条件(时序竞态)： pause函数 调用该函数可以造成进程主动挂起，等待信号唤醒。调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。 int pause(void); 返回值：-1 并设置errno为EINTR 返回值： ① 如果信号的默认处理动作是终止进程，则进程终止，pause函数么有机会返回。 ② 如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。 ③ 如果信号的处理动作是捕捉，则【调用完信号处理函数之后，pause返回-1】 errno设置为EINTR，表示“被信号中断”。 ④ pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。 练习：使用pause和alarm来实现sleep函数。 【pause_mysleep.c】 注意，unslept = alarm(0)的用法。 例如：睡觉，alarm(10)闹铃。 正常： 10后闹铃将我唤醒，这时额外设置alarm(0)取消闹铃，不会出错。 异常： 5分钟，被其他事物吵醒，alarm(0)取消闹铃防止打扰。 前导例 设想如下场景： 欲睡觉，定闹钟10分钟，希望10分钟后闹铃将自己唤醒。 正常：定时，睡觉，10分钟后被闹钟唤醒。 异常：闹钟定好后，被唤走，外出劳动，20分钟后劳动结束。回来继续睡觉计划，但劳动期间闹钟已经响过，不会再将我唤醒。 时序问题分析 回顾，借助pause和alarm实现的mysleep函数。设想如下时序： 1. 注册SIGALRM信号处理函数 （sigaction...) 2. 调用alarm(1) 函数设定闹钟1秒。 3. 函数调用刚结束，开始倒计时1秒。当前进程失去cpu，内核调度优先级高的进程(有多个)取代当前进程。当前进程无法获得cpu，进入就绪态等待cpu。 4. 1秒后，闹钟超时，内核向当前进程发送SIGALRM信号(自然定时法，与进程状态无关)，高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决) 5. 优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。SIGALRM信号递达，信号设置捕捉，执行处理函数sig_alarm。 6. 信号处理函数执行结束，返回当前进程主控流程，pause()被调用挂起等待。（欲等待alarm函数发送的SIGALRM信号将自己唤醒） 7. SIGALRM信号已经处理完毕，pause不会等到。 解决时序竞态问题 sigsuspend函数 可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。除非将这两步骤合并成一个“原子操作”。sigsuspend函数具备这个功能。在对时序要求严格的场合下都应该使用sigsuspend替换pause。 int sigsuspend(const sigset_t *mask); 挂起等待信号。 sigsuspend函数调用期间，进程信号屏蔽字由其参数mask指定。 可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。 改进版mysleep 【sigsuspend.c】 总结 竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。 不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。 这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。 全局变量异步I/O 分析如下父子进程交替数数程序。当捕捉函数里面的sleep取消，程序即会出现问题。请分析原因。 #include #include #include #include int n = 0, flag = 0; void sys_err(char *str) { perror(str); exit(1); } void do_sig_child(int num) { printf(\"I am child %d\\t%d\\n\", getpid(), n); n += 2; flag = 1; sleep(1); } void do_sig_parent(int num) { printf(\"I am parent %d\\t%d\\n\", getpid(), n); n += 2; flag = 1; sleep(1); } int main(void) { pid_t pid; struct sigaction act; if ((pid = fork()) 0) { n = 1; sleep(1); act.sa_handler = do_sig_parent; sigemptyset(&act.sa_mask); act.sa_flags = 0; sigaction(SIGUSR2, &act, NULL); //注册自己的信号捕捉函数 父使用SIGUSR2信号 do_sig_parent(0); while (1) { /* wait for signal */; if (flag == 1) { //父进程数数完成 kill(pid, SIGUSR1); flag = 0; //标志已经给子进程发送完信号 } } } else if (pid == 0) { n = 2; act.sa_handler = do_sig_child; sigemptyset(&act.sa_mask); act.sa_flags = 0; sigaction(SIGUSR1, &act, NULL); while (1) { /* waiting for a signal */; if (flag == 1) { kill(getppid(), SIGUSR2); flag = 0; } } } return 0; } 【sync_process.c】 示例中，通过flag变量标记程序实行调度。flag置1表示数数完成。flag置0表示给对方发送信号完成。 问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag,导致无法再继续交替数数下去。 如何解决该问题呢？可以使用后续课程讲到的“锁”机制。当操作全局变量的时候，通过加锁、解锁来解决该问题。 现阶段，我们在编程期间如若使用全局变量，应在主观上注意全局变量的异步IO可能造成的问题。 可/不可重入函数 一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称之为“重入”。根据函数实现的方法可分为“可重入函数”和“不可重入函数”两种。看如下时序。 {width=\"5.949305555555555in\" height=\"3.767361111111111in\"} 显然，insert函数是不可重入函数，重入调用，会导致意外结果呈现。究其原因，是该函数内部实现使用了全局变量。 注意事项 定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free 信号捕捉函数应设计为可重入函数 信号处理程序可以调用的可重入函数可参阅man 7 signal 没有包含在上述列表中的函数大多是不可重入的，其原因为： a. 使用静态数据结构 b. 调用了malloc或free c. 是标准I/O函数 SIGCHLD信号 SIGCHLD的产生条件 子进程终止时 子进程接收到SIGSTOP信号停止时 子进程处在停止态，接受到SIGCONT后唤醒时 借助SIGCHLD信号回收子进程 子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。 结合 17)SIGCHLD 信号默认动作，掌握父使用捕捉函数回收子进程的方式。 【sigchild.c】 如果每创建一个子进程后不使用sleep可以吗？可不可以将程序中，捕捉函数内部的while替换为if？为什么？ if ((pid = waitpid(0, &status, WNOHANG)) > 0) { ... } 思考：信号不支持排队，当正在执行SIGCHLD捕捉函数时，再过来一个或多个SIGCHLD信号怎么办？ 子进程结束status处理方式 pid_t waitpid(pid_t pid, int *status, int options) 参数: options选项 WNOHANG没有子进程结束，立即返回 WUNTRACED如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回 WCONTINUED如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回 获取status WIFEXITED(status)子进程正常exit终止，返回真 ​ WEXITSTATUS(status)返回子进程正常退出值 WIFSIGNALED(status)子进程被信号终止，返回真 ​ WTERMSIG(status)返回终止子进程的信号值 WIFSTOPPED(status)子进程被停止，返回真 ​ WSTOPSIG(status)返回停止子进程的信号值 WIFCONTINUED(status) SIGCHLD信号注意问题 子进程继承了父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集spending。 注意注册信号捕捉函数的位置。 应该在fork之前，阻塞SIGCHLD信号。注册完捕捉函数后解除阻塞。 信号传参 发送信号传参 sigqueue函数 sigqueue函数对应kill函数，但可在向指定进程发送信号的同时携带参数 int sigqueue(pid_t pid, int sig, const union sigval value); 成功：0； 失败：-1，设置errno union sigval { int sival_int; void *sival_ptr; }; 向指定进程发送指定信号的同时，携带数据。但，如传地址，需注意，不同进程之间虚拟地址空间各自独立，将当前进程地址传递给另一进程没有实际意义。 捕捉函数传参 int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); }; 当注册信号捕捉函数，希望获取更多信号相关信息，不应使用sa_handler而应该使用sa_sigaction。但此时的sa_flags必须指定为SA_SIGINFO。siginfo_t是一个成员十分丰富的结构体类型，可以携带各种与信号相关的数据。 中断系统调用 系统调用可分为两类：慢速系统调用和其他系统调用。 慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，read、write、pause、wait... 其他系统调用：getpid、getppid、fork... 结合pause，回顾慢速系统调用： 慢速系统调用被中断的相关行为，实际上就是pause的行为： 如，read ① 想中断pause，信号不能被屏蔽。 ② 信号的处理方式必须是捕捉 (默认、忽略都不可以) ③ 中断后返回-1， 设置errno为EINTR(表“被信号中断”) 可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启。 SA_RESTART重启。 扩展了解： sa_flags还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。 "},"linux-system/05-daemon.html":{"url":"linux-system/05-daemon.html","title":"守护进程","keywords":"","body":"守护进程终端终端的启动流程：ttyname函数网络终端：进程组概念和特性进程组操作函数会话创建会话getsid函数setsid函数守护进程创建守护进程模型守护进程 [TOC] 终端 终端的启动流程： ttyname函数 网络终端： 进程组 概念和特性 进程组操作函数 会话 创建会话 getsid函数 setsid函数 守护进程 创建守护进程模型 终端 在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。信号中还讲过，在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl-C表示SIGINT，Ctrl-\\表示SIGQUIT。 Ctrl + Alt + F1、F2、F3、F4、F5、F6 字符终端 pts (pseudo terminal slave) 指伪终端。 Alt + F7 图形终端 SSH、Telnet... 网络终端 终端的启动流程： 文件与I/O中讲过，每个进程都可以通过一个特殊的设备文件/dev/tty访问它的控制终端。事实上每个终端设备都对应一个不同的设备文件，/dev/tty提供了一个通用的接口，一个进程要访问它的控制终端既可以通过/dev/tty也可以通过该终端设备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。 简单来说，一个Linux系统启动，大致经历如下的步骤： init --> fork --> exec --> getty --> 用户输入帐号 --> login --> 输入密码 --> exec --> bash 硬件驱动程序负责读写实际的硬件设备，比如从键盘读入字符和把字符输出到显示器，线路规程像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理，比如在键盘上按下Ctrl-z，对应的字符并不会被用户程序的read读到，而是被线路规程截获，解释成SIGTSTP信号发给前台进程，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些特殊处理是可以配置的。 {width=\"2.53125in\" height=\"2.7916666666666665in\"} line disciline: 线路规程，用来过滤键盘输入的内容。 ttyname函数 由文件描述符查出对应的设备文件名 char *ttyname(int fd); 成功：终端名； 失败：NULL，设置errno 下面我们借助ttyname函数，通过实验看一下各种不同的终端所对应的设备文件名。【ttyname.c】 #include #include int main(void){ printf(\"fd 0: %s\\n\", ttyname(0)); printf(\"fd 1: %s\\n\", ttyname(1)); printf(\"fd 2: %s\\n\", ttyname(2)); return 0;} 网络终端： 虚拟终端或串口终端的数目是有限的，虚拟终端(字符控制终端)一般就是/dev/tty1∼/dev/tty6六个，串口终端的数目也不超过串口的数目。然而网络终端或图形终端窗口的数目却是不受限制的，这是通过伪终端（Pseudo TTY）实现的。一套伪终端由一个主设备（PTY Master）和一个从设备（PTY Slave）组成。主设备在概念上相当于键盘和显示器，只不过它不是真正的硬件而是一个内核模块，操作它的也不是用户而是另外一个进程。从设备和上面介绍的/dev/tty1这样的终端设备模块类似，只不过它的底层驱动程序不是访问硬件而是访问主设备。网络终端或图形终端窗口的Shell进程以及它启动的其它进程都会认为自己的控制终端是伪终端从设备，例如/dev/pts/0、/dev/pts/1等。下面以telnet为例说明网络登录和使用伪终端的过程。 {width=\"6.166666666666667in\" height=\"3.3541666666666665in\"} 网络终端 TCP/IP协议栈：在数据包上添加报头。 如果telnet客户端和服务器之间的网络延迟较大，我们会观察到按下一个键之后要过几秒钟才能回显到屏幕上。这说明我们每按一个键telnet客户端都会立刻把该字符发送给服务器，然后这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备，回显的字符再经过伪终端主设备、telnetd服务器和网络发回给telnet客户端，显示给用户看。也许你会觉得吃惊，但真的是这样：每按一个键都要在网络上走个来回！ 进程组 概念和特性 进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。 当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID==第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID==其进程ID 可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。 【kill_groupprocess.c】 组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。 进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。 一个进程可以为自己或子进程设置进程组ID 进程组操作函数 getpgrp函数 获取当前进程的进程组ID pid_t getpgrp(void); 总是返回调用者的进程组ID getpgid函数 获取指定进程的进程组ID pid_t getpgid(pid_t pid); 成功：0； 失败：-1，设置errno 如果pid = 0，那么该函数作用和getpgrp一样。 练习：查看进程对应的进程组ID 【getpgid.c】 setpgid函数 改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。 int setpgid(pid_t pid, pid_t pgid); 成功：0； 失败：-1，设置errno 将参1对应的进程，加入参2对应的进程组中。 注意： 1. 如改变子进程为新的组，应fork后，exec前。 2. 权级问题。非root进程只能改变自己创建的子进程，或有权限操作的进程 练习：修改子进程的进程组ID 【setpgid.c】 会话 一组进程组 创建会话 创建一个会话需要注意以下6点注意事项： 调用创建会话的进程不能是进程组组长，该进程变成新会话首进程(session header) 调用创建会话的进程，成为一个新进程组的组长进程，既是新的会长，也是新的组长。 需有root权限(ubuntu不需要) 新会话丢弃原有的控制终端，该会话没有控制终端 如果该调用进程是组长进程，则出错返回(第一条) 建立新会话时，先调用fork, 父进程终止，子进程调用setsid getsid函数 获取进程所属的会话ID pid_t getsid(pid_t pid); 成功：返回调用进程的会话ID； 失败：-1，设置errno pid为0表示察看当前进程session ID ps ajx命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。 组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。 setsid函数 创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。 pid_t setsid(void); 成功：返回调用进程的会话ID； 失败：-1，设置errno 调用了setsid函数的进程，既是新的会长，也是新的组长。 练习：fork一个子进程，并使其创建一个新会话。查看进程组ID、会话ID前后变化 【session.c】 守护进程 Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。 Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。 创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。 创建守护进程模型 创建子进程，父进程退出 所有工作在子进程中进行形式上脱离了控制终端 在子进程中创建新会话 　　 setsid()函数 　　 使子进程完全独立出来，脱离控制 改变当前目录为根目录 　　 chdir()函数 　　 防止占用可卸载的文件系统 　　 也可以换成其它路径 重设文件权限掩码 　　 umask()函数 　　 防止继承的文件创建屏蔽字拒绝某些权限 　　 增加守护进程灵活性 关闭文件描述符 　　 继承的打开文件不会用到，浪费系统资源，无法卸载 开始执行守护进程核心工作 守护进程退出处理程序模型 【daemond-session.c】 安装线程man page，命令：sudo apt-get install manpages-posix-dev 安装完成，使用man -k pthread如能看到线程函数列表则表明安装成功。 "},"linux-system/06-thread.html":{"url":"linux-system/06-thread.html","title":"线程","keywords":"","body":"线程线程概念什么是线程Linux内核线程实现原理线程状态线程共享的资源线程非共享的资源线程优、缺点进程和线程的区别线程控制原语pthread_self函数pthread_create函数pthread_exit函数pthread_join函数pthread_detach函数pthread_cancel函数pthread_equal函数控制原语对比线程属性线程属性初始化线程的分离状态线程的栈地址线程的栈大小线程属性控制示例线程使用注意事项线程 [TOC] 线程概念 什么是线程 Linux内核线程实现原理 线程状态 线程共享的资源 线程非共享的资源 线程优、缺点 进程和线程的区别 线程控制原语 pthread_self函数 pthread_create函数 pthread_exit函数 pthread_join函数 pthread_detach函数 pthread_cancel函数 pthread_equal函数 控制原语对比 线程属性 线程属性初始化 线程的分离状态 线程的栈地址 线程的栈大小 线程属性控制示例 线程使用注意事项 线程概念 什么是线程 LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下) 进程：独立地址空间，拥有PCB 线程：也有PCB，但没有独立的地址空间(共享) 区别：在于是否共享地址空间。 独居(进程)；合租(线程)。 Linux下： 线程：最小的执行单位 进程：最小分配资源单位，可看成是只有一个线程的进程。 Linux内核线程实现原理 类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。 1. 轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone 2. 从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的 3. 进程可以蜕变成线程 4. 线程可看做寄存器和栈的集合 5. 在linux下，线程最是小的执行单位；进程是最小的分配资源单位 察看LWP号：ps -Lf pid 查看指定线程的lwp号。 ps -Lf pid # 查看指定线程的lwp号 {width=\"4.770833333333333in\" height=\"3.25in\"} 三级映射：进程PCB --> 页目录(可看成数组，首地址位于PCB中) --> 页表 --> 物理页面 --> 内存单元 参考：《Linux内核源代码情景分析》 ----毛德操 对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。 但！线程不同！两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。 实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。 如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。 因此：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。 线程状态 准备：等待可用的CPU资源，其他条件一切准备好。当线程被pthread_create创建时或者阻塞状态结束后就处于准备状态。 运行 ：线程已经获得CPU的使用权，并且正在运行，在多核心的机器中同时存在多个线程正在运行。如果这种情况不加以控制，会造成整个程序没响应。 阻塞：指一个线程在执行过程中暂停，以等待某个条件的触发。 例如线程可能在处理有关I/O的任务，可能I/O设备繁忙尚未响应或没有可用的I/O缓存。 也可能当前线程等待一个可用的条件便来变量。 错误地对一个已被锁住的互斥量加锁 调用sigwait等待尚未发生的信号。 终止：线程已经从回调函数中返回，或者调用pthread_exit返回，或者被强制终止。 线程共享的资源 文件描述符表 当前工作目录 用户ID和组ID 内存地址空间 (.text/.data/.bss/heap/共享库) 每种信号的处理方式 线程非共享的资源 线程id 处理器现场和栈指针(内核栈) 独立的栈空间(用户空间栈) errno变量 信号屏蔽字 调度优先级 线程优、缺点 优点： 提高程序并发性 开销小 数据通信、共享数据方便 缺点： 库函数，不稳定 调试、编写困难、gdb不支持 对信号支持不好 优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。 进程和线程的区别 线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 内存分配：系统在运行的时候会为每个进程分配不同的内存空间，进程之间的地址空间和资源是相互独立的；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），同一进程的线程组之间共享本进程的地址空间和资源。 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）？？而Linux内核下，线程跟进程其实是一个级别的，同样的机会参与CPU轮循调度。 多核下一个进程(不管包含几个线程)始终在一个核下运行，即不会出现线程(同时)出现在多个核上。 线程控制原语 pthread_self函数 获取当前线程ID。其作用对应进程中 getpid() 函数。 pthread_t pthread_self(void); 返回值：成功：0； 失败：无！ 线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现 线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同) 注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。 pthread_create函数 创建一个新线程。 其作用，对应进程中fork() 函数。 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 成功：0； 失败：错误号 Linux环境下，所有线程特点，失败均直接返回错误号。 参数： pthread_t：当前Linux中可理解为：typedef unsigned long int pthread_t; 参数1：传出参数，保存系统为我们分配好的线程ID 参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。 参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。 参数4：线程主函数执行期间所使用的函数参数。 在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。 pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。 attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。 【练习】：创建一个新线程，打印线程ID。注意：链接线程库 -lpthread 【pthread_create.c】 由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。 【练习】：循环创建多个线程，每个线程打印自己是第几个被创建的线程。(类似于进程循环创建子进程) 【for-pthread_create.c】 拓展思考：将pthread_create函数参4修改为(void *)&i, 将线程主函数内改为 i=*((int *)arg) 是否可以？ 线程与共享 线程间共享全局变量 【牢记】：线程默认共享数据段、代码段等地址空间，常用的是全局变量。而进程不共享全局变量，只能借助mmap。 【练习】：设计程序，验证线程之间共享全局数据。 【glb_var_pthrd.c】 pthread_exit函数 将单个线程退出 void pthread_exit(void *retval); 参数：retval表示线程退出状态，通常传NULL 思考：使用exit将指定线程退出，可以吗？ 【pthrd_exit.c】 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。 在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。 所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。 另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。 【练习】：编写多线程程序，总结exit、return、pthread_exit各自退出效果。 return：返回到调用者那里去。 pthread_exit()：将调用该函数的线程 exit: 将进程退出。 pthread_join函数 阻塞等待线程退出，获取线程退出状态 其作用，对应进程中 waitpid() 函数。 int pthread_join(pthread_t thread, void **retval); 成功：0； 失败：错误号 参数： thread：线程ID （【注意】：不是指针）； retval：存储线程结束状态。 对比记忆： 进程中：main返回值、exit参数-->int；等待子进程结束 wait 函数参数-->int * 线程中：线程主函数返回值、pthread_exit-->void *；等待线程结束 pthread_join 函数参数-->void ** 【练习】：参数 retval 非空用法。 【pthread_join.c】 调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下： 如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。 如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。 如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。 如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。 【练习】：使用pthread_join函数将循环创建的多个子线程回收。 【pthread_join-for.c】 pthread_detach函数 实现线程分离 int pthread_detach(pthread_t thread); 成功：0； 失败：错误号 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。 进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。 也可使用 pthread_create函数参2(线程属性)来设置线程分离。 【练习】：使用pthread_detach函数实现线程分离 【pthrd_detach.c】 一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻自动回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。 pthread_cancel函数 杀死(取消)线程 其作用，对应进程中 kill() 函数。 int pthread_cancel(pthread_t thread); 成功：0； 失败：错误号 【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。 类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。 取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write..... 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。 可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthread_testcancel()函数自行设置一个取消点。 被取消的线程， 退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。 【练习】：终止线程的三种方法。注意“取消点”的概念。 【pthrd_endof3.c】 终止线程方式 总结：终止某个线程而不终止整个进程，有三种方法： 从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。 一个线程可以调用pthread_cancel终止同一进程中的另一个线程。 线程可以调用pthread_exit终止自己。 pthread_equal函数 比较两个线程ID是否相等。 int pthread_equal(pthread_t t1, pthread_t t2); 有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。 控制原语对比 进程 线程 fork pthread_create exit pthread_exit wait pthread_join kill pthread_cancel getpid pthread_self 线程属性 本节作为指引性介绍，linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。 typedef struct{ int etachstate; //线程的分离状态 int schedpolicy; //线程调度策略 struct sched_param schedparam; //线程的调度参数 int inheritsched; //线程的继承性 int scope; //线程的作用域 size_t guardsize; //线程栈末尾的警戒缓冲区大小 int stackaddr_set; //线程的栈设置 void* stackaddr; //线程栈的位置 size_t stacksize; //线程栈的大小 } pthread_attr_t; 主要结构体成员： 1. 线程分离状态 2. 线程栈大小（默认平均分配） 3. 线程栈警戒缓冲区大小（位于栈末尾） 参 APUE.12.3 线程属性 属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。 线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。 线程属性初始化 注意：应先初始化线程属性，再pthread_create创建线程 pthread_attr_init初始化线程属性 int pthread_attr_init(pthread_attr_t *attr); 成功：0； 失败：错误号 pthread_attr_destroy销毁线程属性所占用的资源 int pthread_attr_destroy(pthread_attr_t *attr); 成功：0； 失败：错误号 线程的分离状态 线程的分离状态决定一个线程以什么样的方式来终止自己。 非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。 分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。 线程分离状态的函数： pthread_attr_setdetachstate设置线程属性，分离or非分离 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); pthread_attr_getdetachstate获取线程属性，分离or非分离 int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate); 参数： attr：已初始化的线程属性 detachstate： PTHREAD_CREATE_DETACHED（分离线程） PTHREAD _CREATE_JOINABLE（非分离线程） 这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。 线程的栈地址 POSIX.1定义了两个常量_POSIX_THREAD_ATTR_STACKADDR 和_POSIX_THREAD_ATTR_STACKSIZE检测系统是否支持栈属性。也可以给sysconf函数传递_SC_THREAD_ATTR_STACKADDR或 _SC_THREAD_ATTR_STACKSIZE来进行检测。 当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。 设置线程的栈地址 int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize); 成功：0； 失败：错误号 获取线程的栈地址 int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize); 成功：0； 失败：错误号 参数： attr：指向一个线程属性的指针 stackaddr：返回获取的栈地址 stacksize：返回获取的栈大小 线程的栈大小 当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。 函数pthread_attr_getstacksize和 pthread_attr_setstacksize提供设置。 int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); 成功：0； 失败：错误号 int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize); 成功：0； 失败：错误号 参数： attr：指向一个线程属性的指针 stacksize：返回线程的堆栈大小 线程属性控制示例 【pthrd_attr_change.c】 NPTL?? 线程库版本 1.察看当前pthread库版本getconf GNU_LIBPTHREAD_VERSION 2.NPTL实现机制(POSIX)，Native POSIX Thread Library 3.使用线程库时gcc指定 –lpthread 线程使用注意事项 主线程退出其他线程不退出，主线程应调用pthread_exit 避免僵尸线程方法,回收线程 pthread_join pthread_detach pthread_create指定分离属性 被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值; malloc和mmap申请的内存可以被其他线程释放 应避免在多线程模型中调用fork除非，马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit 信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制 "},"linux-system/07-thread-synchronization.html":{"url":"linux-system/07-thread-synchronization.html","title":"线程同步","keywords":"","body":"线程同步同步概念线程同步数据混乱原因：互斥量mutex互斥锁状态：主要应用函数：加锁与解锁加锁步骤测试：死锁自锁互锁避免死锁的方法：读写锁读写锁状态：读写锁特性：主要应用函数：读写锁示例条件变量主要应用函数：生产者消费者条件变量模型条件变量的优点信号量主要应用函数：生产者消费者信号量模型进程间同步互斥量mutex信号量文件锁生产者消费者模型哲学家用餐模型多线程版多进程版线程同步 [TOC] 同步概念 线程同步 数据混乱原因： 互斥量mutex 互斥锁状态： 主要应用函数： 加锁与解锁 加锁步骤测试： 死锁 自锁 互锁 避免死锁的方法： 读写锁 读写锁状态： 读写锁特性： 主要应用函数： 读写锁示例 条件变量 主要应用函数： 生产者消费者条件变量模型 条件变量的优点 信号量 主要应用函数： 生产者消费者信号量模型 进程间同步 互斥量mutex 信号量 文件锁 生产者消费者模型 哲学家用餐模型 多线程版 多进程版 同步概念 所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等 然而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。 线程同步 同步即协同步调，按预定的先后次序运行。 线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。 举例1： 银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000 举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续 从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。 产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。 “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。 因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。 数据混乱原因： 1. 资源共享（独享资源则不会） 2. 调度随机（意味着数据访问会出现竞争） 3. 线程间缺乏必要的同步机制。 以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。 所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。 互斥量mutex Linux中提供一把互斥锁mutex（也称之为互斥量）。 每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的， 但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。 {width=\"2.9819444444444443in\" height=\"2.1363003062117234in\"} 但，应注意：同一时刻，只能有一个线程持有该锁。 当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。 所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。 因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。 互斥锁状态： 一把读写锁具备两种状态： 加锁状态(加锁) 解锁状态(解锁) 主要应用函数： pthread_mutex_init 初始化函数 pthread_mutex_destroy函数 pthread_mutex_lock函数 pthread_mutex_trylock函数 pthread_mutex_unlock函数 以上5个函数的返回值都是：成功返回0， 失败返回错误号。 pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。 pthread_mutex_t mutex; 变量mutex只有两种取值1、0。 pthread_mutex_init函数 初始化一个互斥锁(互斥量) ---> 初值可看作1 int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); 参1：传出参数，调用时应传 &mutex restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改。 参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性 初始化方式: 静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。 pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER; 动态初始化：局部变量应采用动态初始化。 pthread_mutex_init(&mutex, NULL) pthread_mutex_destroy函数 销毁一个互斥锁 int pthread_mutex_destroy(pthread_mutex_t *mutex); pthread_mutex_lock函数 加锁。可理解为将mutex--（或mutex-1） int pthread_mutex_lock(pthread_mutex_t *mutex); pthread_mutex_unlock函数 解锁。可理解为将mutex ++（或mutex+1） int pthread_mutex_unlock(pthread_mutex_t *mutex); pthread_mutex_trylock函数 尝试加锁 int pthread_mutex_trylock(pthread_mutex_t *mutex); 加锁与解锁 lock与unlock： lock加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。 unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。 例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。 可假想mutex锁 init成功初值为1。 lock 功能是将mutex--。 unlock将mutex++ lock与trylock： lock加锁，如果加锁不成功，线程阻塞，等待锁释放。 trylock尝试加锁,如果加锁不成功,失败了直接返回错误号（如：EBUSY），不阻塞。 加锁步骤测试： 【mutex.c】该程序是非常典型的，由于共享、竞争而没有加任何同步机制，导致产生于时间有关的错误，造成数据混乱： 【练习】：修改该程序，使用mutex互斥锁进行同步。 定义全局互斥量，初始化init(&m, NULL)互斥量，添加对应的destry 两个线程while中，两次printf前后，分别加lock和unlock 将unlock挪至第二个sleep后，发现交替现象很难出现。 线程在操作完共享资源后本应该立即解锁，但修改后，线程抱着锁睡眠。睡醒解锁后又立即加锁，这两个库函数本身不会阻塞。所以在这两行代码之间失去cpu的概率很小。因此，另外一个线程很难得到加锁的机会。 main 中加flag = 5 将flg在while中-- 这时，主线程输出5次后试图销毁锁，但子线程未将锁释放，无法完成。 main 中加pthread_cancel()将子线程取消。 【pthread_mutex.c】 结论： 在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。 死锁 自锁 线程试图对同一个互斥量A加锁两次。 互锁 线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁 避免死锁的方法： 当得不到所有所需资源时，放弃已经获得的资源，等待。 保证资源的获取顺序一致，要求每个线程获取资源的顺序一致。如：A获取顺序1、2、3；B顺序应也是1、2、3。若B为3、2、1则易出现死锁现象。 【deadlock.c】：编写程序，实现上述两种死锁现象。 读写锁 与互斥量类似，但读写锁允许更高的并行性。其特性为：读共享，写独占，写锁优先级高。 读写锁状态： 一把读写锁具备三种状态： 1. 读模式下加锁状态 (读锁) 2. 写模式下加锁状态 (写锁) 3. 不加锁状态(解锁) 读写锁特性： 读写锁是“写模式加锁”(写锁)状态时， 解锁前，所有对该锁加锁的线程都会被阻塞。 读写锁是“读模式加锁”(读锁)状态时， 如果线程以读模式对其加锁(加读锁)会成功；如果线程以写模式加锁(加写锁)会阻塞。 读写锁是“读模式加锁”(读锁)状态时， 既有试图以写模式加锁的线程，又有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。 读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。 读写锁非常适合于对数据结构读的次数远大于写的情况。 主要应用函数： pthread_rwlock_init函数 pthread_rwlock_destroy函数 pthread_rwlock_rdlock函数 pthread_rwlock_wrlock函数 pthread_rwlock_tryrdlock函数 pthread_rwlock_trywrlock函数 pthread_rwlock_unlock函数 以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。 pthread_rwlock_t类型 用于定义一个读写锁变量。 pthread_rwlock_t rwlock; pthread_rwlock_init函数 初始化一把读写锁 int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); 参2：attr表读写锁属性，通常使用默认属性，传NULL即可。 pthread_rwlock_destroy函数 销毁一把读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); pthread_rwlock_rdlock函数 以读方式请求读写锁。（常简称为：请求读锁） int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); pthread_rwlock_wrlock函数 以写方式请求读写锁。（常简称为：请求写锁） int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); pthread_rwlock_unlock函数 解锁读写锁 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); pthread_rwlock_tryrdlock函数 非阻塞以读方式请求读写锁（非阻塞请求读锁） int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); pthread_rwlock_trywrlock函数 非阻塞以写方式请求读写锁（非阻塞请求写锁） int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 读写锁示例 看如下示例，同时有多个线程对同一全局数据读、写操作。【rwlock.c】 条件变量 条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。 主要应用函数： pthread_cond_init函数 pthread_cond_destroy函数 pthread_cond_wait函数 pthread_cond_timedwait函数 pthread_cond_signal函数 pthread_cond_broadcast函数 以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。 pthread_cond_t类型 用于定义条件变量 pthread_cond_t cond; pthread_cond_init函数 初始化一个条件变量 int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); 参2：attr表条件变量属性，通常为默认值，传NULL即可 也可以使用静态初始化的方法，初始化条件变量： pthread_cond_t cond = PTHREAD_COND_INITIALIZER; pthread_cond_destroy函数 销毁一个条件变量 int pthread_cond_destroy(pthread_cond_t *cond); pthread_cond_wait函数 阻塞等待一个条件变量 int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); 函数作用： 阻塞等待 条件变量信号cond（参1）满足 并且暂时释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&mutex); 1.2.两步为一个原子操作。 当被条件变量信号唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取 互斥锁pthread_mutex_lock(&mutex); pthread_cond_timedwait函数 限时等待一个条件变量 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); 参3： 参看man sem_timedwait函数，查看struct timespec结构体。 struct timespec { time_t tv_sec; /* seconds */ 秒 long tv_nsec; /* nanosecondes*/ 纳秒 } 形参abstime：绝对时间。 如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。 struct timespec t = {1, 0}; pthread_cond_timedwait (&cond, &mutex, &t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去) 正确用法： time_t cur = time(NULL); // 获取当前绝对时间。 struct timespec t; // 定义timespec 结构体变量t t.tv_sec = cur+1; // 定时1秒 pthread_cond_timedwait (&cond, &mutex, &t); // 传参 参APUE.11.6线程同步条件变量小节 在讲解setitimer函数时我们还提到另外一种时间类型： struct timeval { time_t tv_sec; /* seconds */ 秒 suseconds_t tv_usec; /* microseconds */ 微秒 }; pthread_cond_signal函数 唤醒至少一个阻塞在条件变量上的线程 int pthread_cond_signal(pthread_cond_t *cond); pthread_cond_broadcast函数 唤醒全部阻塞在条件变量上的线程 int pthread_cond_broadcast(pthread_cond_t *cond); 生产者消费者条件变量模型 线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。 看如下示例，使用条件变量模拟生产者、消费者问题：【conditionVar_product_consumer.c】 条件变量的优点 相较于mutex而言，条件变量可以减少竞争。 如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。 信号量 进化版的互斥锁（1 --> N） 由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。 信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。 主要应用函数： sem_init函数 sem_destroy函数 sem_wait函数 sem_trywait函数 sem_timedwait函数 sem_post函数 以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀) sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。 sem_t sem; 规定信号量sem不能 信号量基本操作： sem_wait: 将信号量-- 信号量大于0，则信号量-- （类比pthread_mutex_lock） 信号量等于0，造成线程阻塞 sem_post： 将信号量++，同时唤醒阻塞在信号量上的线程 （类比pthread_mutex_unlock）。 但，由于sem_t的实现对用户隐藏，所以所谓的++、--操作只能通过函数来实现，而不能直接++、--符号。 信号量的初值，决定了占用信号量的线程的个数。 sem_init函数 初始化一个信号量 int sem_init(sem_t *sem, int pshared, unsigned int value); 参1：sem信号量 参2：pshared取0用于线程间；取非0（一般为1）用于进程间 参3：value指定信号量初值,当信号量初值为1，信号量相当于互斥锁 信号量的初值，决定了占用信号量的线程的个数。 sem_destroy函数 销毁一个信号量 int sem_destroy(sem_t *sem); sem_wait函数 给信号量加锁 -- int sem_wait(sem_t *sem); sem_post函数 给信号量解锁 ++ int sem_post(sem_t *sem); sem_trywait函数 尝试对信号量加锁 -- (与sem_wait的区别类比lock和trylock) int sem_trywait(sem_t *sem); sem_timedwait函数 限时尝试对信号量加锁 -- int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); 参2：abs_timeout采用的是绝对时间。 定时1秒： time_t cur = time(NULL); 获取当前时间。 struct timespec t; 定义timespec 结构体变量t t.tv_sec = cur+1; 定时1秒 t.tv_nsec = t.tv_sec +100; sem_timedwait(&sem, &t); 传参 生产者消费者信号量模型 五个同步问题的经典模型之一：生产者/消费者问题 【练习】：使用信号量完成线程间同步，模拟生产者，消费者问题。 【sem_product_consumer.c】 分析： 规定： 如果□中有数据，生产者不能生产，只能阻塞。 如果□中没有数据，消费者不能消费，只能等待数据。 定义两个信号量：S满 = 0， S空 = 1 （S满代表满格的信号量，S空表示空格的信号量，程序起始，格子一定为空） 所以有： T生产者主函数{ T消费者主函数 { sem_wait(S空); sem_wait(S满); 生产.... 消费.... sem_post(S满); sem_post(S空); } } 假设： 线程到达的顺序是:T生、T生、T消。 那么： T生1 到达，将S空-1，生产，将S满+1 T生2 到达，S空已经为0， 阻塞 T消 到达，将S满-1，消费，将S空+1 三个线程到达的顺序是：T生1、T生2、T消。而执行的顺序是T生1、T消、T生2 这里，S空 表示空格子的总数，代表可占用信号量的线程总数-->1。其实这样的话，信号量就等同于互斥锁。 但，如果S空=2、3、4……就不一样了，该信号量同时可以由多个线程占用，不再是互斥的形式。因此我们说信号量是互斥锁的加强版。 【推演练习】： 理解上述模型，推演，如果是两个消费者，一个生产者，是怎么样的情况。 【作业】：结合生产者消费者信号量模型，揣摩sem_timedwait函数作用。编程实现，一个线程读用户输入， 另一个线程打印“hello world”。如果用户无输入，则每隔5秒向屏幕打印一个“hello world”；如果用户有输入，立刻打印“hello world”到屏幕。 进程间同步 互斥量mutex 进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其属性为进程间共享。mutex的属性修改函数主要有以下几个。 修改属性主要应用函数： mutex锁的属性类型 pthread_mutexattr_t mattr 类型： 用于定义mutex锁的属性 初始化一个mutex属性对象 int pthread_mutexattr_init(pthread_mutexattr_t *attr); 销毁mutex属性对象 (而非销毁锁) int pthread_mutexattr_destroy(pthread_mutexattr_t *attr); 修改mutex属性 int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared); 参2：pshared取值： 线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有) 进程锁：PTHREAD_PROCESS_SHARED (进程间公有) 进程间mutex示例 进程间使用mutex来实现同步：【process_mutex.c】 信号量 sem_init函数 初始化一个信号量 int sem_init(sem_t *sem, int pshared, unsigned int value); 参1：sem信号量 参2：pshared取0用于线程间；取非0（一般为1）用于进程间 参3：value指定信号量初值 文件锁 借助fcntl函数设置文件访问控制属性来实现进程锁机制。 操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。 fcntl函数： 获取、设置文件访问控制属性。 int fcntl(int fd, int cmd, ... /* arg */ ); 参2： F_SETLK (struct flock *) 设置文件锁（等效trylock） F_SETLKW (struct flock *) 设置文件锁（等效lock）W --> wait F_GETLK (struct flock *) 获取文件锁 参3： struct flock { ... short l_type; 锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK short l_whence; 偏移位置：SEEK_SET、SEEK_CUR、SEEK_END off_t l_start; 起始偏移：1000 off_t l_len; 长度：0表示整个文件加锁 pid_t l_pid; 持有该锁的进程ID：(F_GETLK only) ... }; 进程间文件锁示例 多个进程对加锁文件进行访问：【file_lock.c】 依然遵循“读共享、写独占”特性。但！同样，如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。 【思考】：多线程中，可以使用文件锁吗？ 多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。 多线程中无法使用文件锁，因为各线程之间共享文件描述符（通过文件描述符结构体值加锁） 生产者消费者模型 单生产者和单消费者 多生产者多消费者 哲学家用餐模型 多线程版 选用互斥锁mutex，如创建5个， pthread_mutex_t m[5]; 模型抽象： 5个哲学家 --> 5个线程； 5支筷子 --> 5把互斥锁 int left(左手)， right(右手) 5个哲学家使用相同的逻辑，可通用一个线程主函数，void *tfn(void *arg)，使用参数来表示线程编号：int i = (int)arg; 哲学家线程根据编号知道自己是第几个哲学家，而后选定锁，锁住，吃饭。否则哲学家thinking。 A B C D E 5支筷子，在逻辑上形成环： 0 1 2 3 4 分别对应5个哲学家： {width=\"6.2956528871391075in\" height=\"1.5463123359580053in\"} 所以有： if(i == 4) left = i, right = 0; else left = i, right = i+1; 振荡：如果每个人都攥着自己左手的锁，尝试去拿右手锁，拿不到则将锁释放。过会儿五个人又同时再攥着左手锁尝试拿右手锁，依然拿不到。如此往复形成另外一种极端死锁的现象——振荡。 避免振荡现象：只需5个人中，任意一个人，拿锁的方向与其他人相逆即可(如：E，原来：左：4，右：0 现在：左：0， 右：4)。 所以以上if else语句应改为： if(i == 4) left = 0, right = i; else left = i, right = i+1; 而后， 首先应让哲学家尝试加左手锁： while { pthread_mutex_lock(&m[left]); 如果加锁成功，函数返回再加右手锁， 如果失败，应立即释放左手锁，等待。 若，左右手都加锁成功 --> 吃 --> 吃完 --> 释放锁（应先释放右手、再释放左手，是加锁顺序的逆序） } 主线程(main)中，初始化5把锁，销毁5把锁，创建5个线程（并将i传递给线程主函数），回收5个线程。 多进程版 相较于多线程需注意问题： 需注意如何共享信号量 (注意：坚决不能使用全局变量 sem_t s[5]) 实现： main函数中： 循环 sem_init(&s[i], 0, 1); 将信号量初值设为1，信号量变为互斥锁。 循环 sem_destroy(&s[i]); 循环 创建 5 个子进程。 if(i 吃； 若不成功 --> 将左手锁释放。 吃完后， 先释放右手锁，再释放左手锁。 } 【重点注意】： 直接将sem_t s[5]放在全局位置，试图用于子进程间共享是错误的！应将其定义放置与mmap共享映射区中。main中： sem_t *s = mmap(NULL, sizeof(sem_t) * 5, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON， -1， 0); 使用方式：将s当成数组首地址看待，与使用数组s[5]没有差异。 "},"linux-internet/":{"url":"linux-internet/","title":"linux网络编程","keywords":"","body":"linux网络编程linux网络编程 网络基础 协议的概念 分层模型 通信过程 协议格式 Socket编程 TCP/UDP 预备知识 TCP UDP socket IPC 多进程并发服务器 多线程并发服务器 多路I/O转接服务器 select poll epoll 线程池并发处理服务器 "},"linux-internet/wang-luo-ji-chu.html":{"url":"linux-internet/wang-luo-ji-chu.html","title":"网络基础","keywords":"","body":"网络基础协议的概念什么是协议典型协议网络应用程序设计模式C/S模式B/S模式优缺点分层模型网络体系结构分层OSI七层模型TCP/IP四层模型通信过程协议格式数据包封装以太网帧格式ARP数据报格式??IP段格式UDP数据报格式TCP数据报格式TCP协议TCP通信时序TCP的流量控制和拥塞控制滑动窗口 (TCP流量控制)TCP状态转换半关闭2MSLTCP异常断开网络名词术语解析路由(route)路由器工作原理路由表(Routing Table)路由条目缺省路由条目路由节点以太网交换机工作原理hub工作原理半双工/全双工DNS服务器局域网(LAN)广域网(WAN)端口MTU网络基础 [TOC] 协议的概念 什么是协议 典型协议 网络应用程序设计模式 C/S模式 B/S模式 优缺点 分层模型 网络体系结构分层 OSI七层模型 TCP/IP四层模型 通信过程 协议格式 数据包封装 以太网帧格式 ARP数据报格式?? IP段格式 UDP数据报格式 TCP数据报格式 TCP协议 TCP通信时序 TCP的流量控制和拥塞控制 滑动窗口 (TCP流量控制) TCP状态转换 半关闭 2MSL TCP异常断开 网络名词术语解析 路由(route) 路由器工作原理 路由表(Routing Table) 路由条目 缺省路由条目 路由节点 以太网交换机工作原理 hub工作原理 半双工/全双工 DNS服务器 局域网(LAN) 广域网(WAN) 端口 MTU 协议的概念 什么是协议 从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。 假设，A、B双方欲传输文件。规定： 第一次，传输文件名，接收方接收到文件名，应答OK给传输方； 第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK； 第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。 由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。 这种仅在A、B之间被遵守的协议称之为原始协议。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个标准协议。最早的ftp协议就是由此衍生而来。 TCP协议注重数据的传输。http协议着重于数据的解释。 https://developer.51cto.com/art/201906/597961.htm#topx 典型协议 应用层 : 常见的协议有HTTP协议，FTP协议。 传输层 : 常见协议有TCP/UDP协议。 网络层 : 常见协议有IP协议、ICMP协议、IGMP协议。 网络接口层 : 常见协议有ARP协议、RARP协议。 HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种应用层网络协议。 FTP文件传输协议（File Transfer Protocol） TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 IP协议是因特网互联协议（Internet Protocol）。 ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。 ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。 RARP是反向地址转换协议，通过MAC地址确定IP地址。 网络应用程序设计模式 C/S模式 传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。 B/S模式 浏览器(browser)/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。 优缺点 对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。 因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏魔兽世界。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。 C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。 B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。 B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。 因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。 分层模型 网络体系结构分层 OSI七层模型 OSI模型 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1 网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。 表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 TCP/IP四层模型 TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示： 一般在应用开发过程中，讨论最多的是TCP/IP模型。 通信过程 两台计算机通过TCP/IP协议通讯的过程如下所示： 上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示： 链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。 网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Internet上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。 网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。 TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。 UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。 目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示： 以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。 虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。 协议格式 数据包封装 传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示： 不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。 以太网帧格式 以太网的帧格式如下所示： 其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。 以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。 ARP数据报格式?? 在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。 每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。想一想，为什么表项要有过期时间而不是一直有效？ ARP数据报的格式如下所示： 源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。 看一个具体的例子。 请求帧如下（为了清晰在每行的前面加了字节计数，每行16个字节）： 以太网首部（14字节） 0000: ff ff ff ff ff ff 00 05 5d 61 58 a8 08 06 ARP帧（28字节） 0000: 00 01 0010: 08 00 06 04 00 01 00 05 5d 61 58 a8 c0 a8 00 37 0020: 00 00 00 00 00 00 c0 a8 00 02 填充位（18字节） 0020: 00 77 31 d2 50 10 0030: fd 78 41 d3 00 00 00 00 00 00 00 00 以太网首部：目的主机采用广播地址，源主机的MAC地址是00:05:5d:61:58:a8，上层协议类型0x0806表示ARP。 ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0001表示请求目的主机的MAC地址，源主机MAC地址为00:05:5d:61:58:a8，源主机IP地址为c0 a8 00 37（192.168.0.55），目的主机MAC地址全0待填写，目的主机IP地址为c0 a8 00 02（192.168.0.2）。 由于以太网规定最小数据长度为46字节，ARP帧长度只有28字节，因此有18字节填充位，填充位的内容没有定义，与具体实现相关。 应答帧如下： 以太网首部 0000: 00 05 5d 61 58 a8 00 05 5d a1 b8 40 08 06 ARP帧 0000: 00 01 0010: 08 00 06 04 00 02 00 05 5d a1 b8 40 c0 a8 00 02 0020: 00 05 5d 61 58 a8 c0 a8 00 37 填充位 0020: 00 77 31 d2 50 10 0030: fd 78 41 d3 00 00 00 00 00 00 00 00 以太网首部：目的主机的MAC地址是00:05:5d:61:58:a8，源主机的MAC地址是00:05:5d:a1:b8:40，上层协议类型0x0806表示ARP。 ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0002表示应答，源主机MAC地址为00:05:5d:a1:b8:40，源主机IP地址为c0 a8 00 02（192.168.0.2），目的主机MAC地址为00:05:5d:61:58:a8，目的主机IP地址为c0 a8 00 37（192.168.0.55）。 思考题：如果源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？ IP段格式 IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。 想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？ UDP数据报格式 下面分析一帧基于UDP的TFTP协议帧。 以太网首部(数据链路层) 0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00 // 源MAC地址 目的MAC地址 上层协议类型0x0800表示IP IP首部(网络层) 0000: 45 00 // 版本号为IPv4，首部长度为5 服务类型为0 0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8 // 16位总长度字段53字节, IP报标识0x9325, 标志字段和片偏移字段设置为0x0000, TTL是0x80, 上层协议0x11表示UDP协议, IP首部校验和，源主机IP ，目的主机IP 0020: 00 01 UDP首部(传输层) 0020： 05 d4 00 45 00 3f ac 40 // 源端口号 , 目的端口号 , UDP报长度为 , 校验和 TFTP协议(应用层) 0020: 00 01 'c'':''\\''q' 0030: 'w''e''r''q''.''q''w''e'00 'n''e''t''a''s''c''i' 0040: 'i'00 'b''l''k''s''i''z''e'00 '5''1''2'00 't''i' 0050: 'm''e''o''u''t'00 '1''0'00 't''s''i''z''e'00 '0' 0060: 00 以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。 IP首部：每一个字节0x45包含4位版本号和4位首部长度，版本号为4，即IPv4，首部长度为5，说明IP首部不带有选项字段。服务类型为0，没有使用服务。 16位总长度字段（包括IP首部和IP层payload的长度）为0x0053，即53字节，加上以太网首部14字节可知整个帧长度是97字节。IP报标识是0x9325，标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。TTL是0x80，也就是128。上层协议0x11表示UDP协议。IP首部校验和为0x25ec，源主机IP是c0 a8 00 37（192.168.0.55），目的主机IP是c0 a8 00 01（192.168.0.1）。 UDP首部：源端口号0x05d4（1492）是客户端的端口号，目的端口号0x0045（69）是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。 TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是： c:\\qwerq.qwe netascii blksize 512 timeout 10 tsize 0 一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口。在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。==/etc/services==中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。 很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号，想想这是为什么？ 前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如： 发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。 接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。 通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。 因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于 各种文件的传输。TCP协议又是如何用面向连接的服务来代替应用程序解决传输的可靠性问题呢。 TCP数据报格式 与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小稍后详细解释。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，本节稍后将解释SYN、ACK、FIN、RST四个位，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。紧急指针和各种选项的解释从略。 TCP协议 TCP通信时序 下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的三次握手和四次握手。 在这个例子中，首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出，例如段2的箭头上标着SYN, 8000(0), ACK1001, ，表示该段中的SYN位置1，32位序号是8000，该段不携带有效载荷（数据字节数为0），ACK位置1，32位确认序号是1001，带有一个mss（Maximum Segment Size）最大报文长度选项值为1024。 三次握手 建立连接（三次握手）的过程： 客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。 ​ 客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。 服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。 ​ 服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。 客户必须再次回应服务器端一个ACK报文，这是报文段3。 ​ 客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。 在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误Connection refused： $ telnet 192.168.0.200 8080 Trying 192.168.0.200... telnet: Unable to connect to remote host: Connection refused 数据传输 数据传输的过程： 客户端发出段4，包含从序号1001开始的20个字节数据。 服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。 客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。 在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。 四次挥手 关闭连接（四次握手）的过程： 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 客户端发出段7，FIN位表示关闭连接的请求。 服务器发出段8，应答客户端的关闭连接请求。 服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。 客户端发出段10，应答服务器的关闭连接请求。 建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。 TCP的流量控制和拥塞控制 滑动窗口 (TCP流量控制) 介绍UDP时我们描述了这样的问题：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。TCP协议通过“滑动窗口（Sliding Window）”机制解决这一问题。看下图的通讯过程： 发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三次握手结束。 发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。 接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。 接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。 发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。 接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。 接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。 接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。 接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。 上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，虚线框表示接收缓冲区，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。 从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。 TCP状态转换 这个图N多人都知道，它排除和定位网络或系统故障时大有帮助，但是怎样牢牢地将这张图刻在脑中呢？那么你就一定要对这张图的每一个状态，及转换的过程有深刻的认识，不能只停留在一知半解之中。下面对这张图的11种状态详细解析一下，以便加强记忆！不过在这之前，先回顾一下TCP建立连接的三次握手过程，以及 关闭连接的四次握手过程。 CLOSED：表示初始状态。 LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。 SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。 ESTABLISHED：表示连接已经建立。 FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是： FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。 FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。 FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。 TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。 LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。 半关闭 当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。 从程序的角度，可以使用API来控制实现半连接状态。 #include int shutdown(int sockfd, int how); sockfd: 需要关闭的socket的描述符 how: 允许为shutdown操作选择以下几种方式: SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。 该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。 SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。 SHUT_RDWR(2): 关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。 shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。 使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。 注意: 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。 2MSL 2MSL (Maximum Segment Lifetime) TIME_WAIT状态的存在有两个理由： （1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。 （2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost uplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。 另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost uplicate加上incarnation connection，则会对我们的传输造成致命的错误。 TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq=1000, 来了一个lost duplicate为seq=1000，len=1000, 则TCP认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。 该状态为什么设计在主动关闭这一方： （1）发最后ACK的是主动关闭一方。 （2）只要有一方保持TIME_WAIT状态，就能起到避免incarnation connection在2MSL内的重新建立，不需要两方都有。 如何正确对待2MSL TIME_WAIT? RFC要求socket pair在处于TIME_WAIT时，不能再起一个incarnation connection。但绝大部分TCP实现，强加了更为严格的限制。在2MSL等待期间，socket中使用的本地端口在默认情况下不能再被使用。 若A 10.234.5.5 : 1234和B 10.55.55.60 : 6666建立了连接，A主动关闭，那么在A端只要port为1234，无论对方的port和ip是什么，都不允许再起服务。这甚至比RFC限制更为严格，RFC仅仅是要求socket pair不一致，而实现当中只要这个port处于TIME_WAIT，就不允许起连接。这个限制对主动打开方来说是无所谓的，因为一般用的是临时端口；但对于被动打开方，一般是server，就悲剧了，因为server一般是熟知端口。比如http，一般端口是80，不可能允许这个服务在2MSL内不能起来。 解决方案是给服务器的socket设置SO_REUSEADDR选项，这样的话就算熟知端口处于TIME_WAIT状态，在这个端口上依旧可以将服务启动。当然，虽然有了SO_REUSEADDR选项，但sockt pair这个限制依旧存在。比如上面的例子，A通过SO_REUSEADDR选项依旧在1234端口上起了监听，但这时我们若是从B通过6666端口去连它，TCP协议会告诉我们连接失败，原因为Address already in use. RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。 RFC (Request For Comments)，是一系列以编号排定的文件。收集了有关因特网相关资讯，以及UNIX和因特网社群的软件文件。 程序设计中的问题 做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果： $ ./server bind error: Address already in use 这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下： $ netstat -apn |grep 6666 tcp 1 0 192.168.1.11:38103 192.168.1.11:6666 CLOSE_WAIT 3525/client tcp 0 0 192.168.1.11:6666 192.168.1.11:38103 FIN_WAIT2 - server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。 现在用Ctrl-C把client也终止掉，再观察现象： $ netstat -apn |grep 6666 tcp 0 0 192.168.1.11:6666 192.168.1.11:38104 TIME_WAIT - $ ./server bind error: Address already in use client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。TCP协议规定，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。 MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。至于为什么要规定TIME_WAIT的时间，可参考UNP 2.7节。 端口复用 在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。 在server代码的socket()和bind()调用之间插入如下代码： int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)); 有关setsockopt可以设置的其它选项请参考UNP第7章。 TCP异常断开 心跳检测机制 在TCP网络通信中，经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态。常用的解决方法就是在程序中加入心跳机制。 Heart-Beat线程 这个是最常用的简单方法。在接收和发送数据时个人设计一个守护进程(线程)，定时发送Heart-Beat包，客户端/服务器收到该小包后，立刻返回相应的包即可检测对方是否实时在线。 该方法的好处是通用，但缺点就是会改变现有的通讯协议！大家一般都是使用业务层心跳来处理，主要是灵活可控。 UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测，还是在业务层以心跳包做检测比较好，也方便控制。 设置TCP属性 SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。 根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。 keepAlive = 1; setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&keepAlive, sizeof(keepAlive)); 如果我们不能接受如此之长的等待时间，从TCP-Keepalive-HOWTO上可以知道一共有两种方式可以设置，一种是修改内核关于网络方面的 配置参数，另外一种就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三个选项。 The tcp_keepidle parameter specifies the interval of inactivity that causes TCP to generate a KEEPALIVE transmission for an application that requests them. tcp_keepidle defaults to 14400 (two hours). /*开始首次KeepAlive探测前的TCP空闭时间 */ The tcp_keepintvl parameter specifies the interval between the nine retriesthat are attempted if a KEEPALIVE transmission is not acknowledged. tcp_keep ntvldefaults to 150 (75 seconds). /* 两次KeepAlive探测间的时间间隔 */ The tcp_keepcnt option specifies the maximum number of keepalive probes tobe sent. The value of TCP_KEEPCNT is an integer value between 1 and n, where n s the value of the systemwide tcp_keepcnt parameter. /* 判定断开前的KeepAlive探测次数*/ int keepIdle = 1000; int keepInterval = 10; int keepCount = 10; Setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&keepIdle, sizeof(keepIdle)); Setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&keepInterval, sizeof(keepInterval)); Setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&keepCount, sizeof(keepCount)); SO_KEEPALIVE设置空闲2小时才发送一个“保持存活探测分节”，不能保证实时检测。对于判断网络断开时间太长，对于需要及时响应的程序不太适应。 当然也可以修改时间间隔参数，但是会影响到所有打开此选项的套接口！关联了完成端口的socket可能会忽略掉该套接字选项。 网络名词术语解析 路由(route) 路由（名词） 数据包从源地址到目的地址所经过的路径，由一系列路由节点组成。 路由（动词） 某个路由节点为数据包选择投递方向的选路过程。 路由器工作原理 路由器（Router）是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号的设备。 传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数， 并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。 路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。 网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。 路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。 路由表(Routing Table) 在计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。 路由条目 路由表中的一行，每个条目主要由目的网络地址、子网掩码、下一跳地址、发送接口四部分组成，如果要发送的数据包的目的网络地址匹配路由表中的某一行，就按规定的接口发送到下一跳地址。 缺省路由条目 路由表中的最后一行，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址。 路由节点 一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。 以太网交换机工作原理 以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。 以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。 hub工作原理 集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。 集线器功能是随机选出某一端口的设备，并让它独占全部带宽，与集线器的上联设备（交换机、路由器或服务器等）进行通信。从Hub的工作方式可以看出，它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力，是—个标准的共享式设备。其次是Hub只与它的上联设备(如上层Hub、交换机或服务器)进行通信，同层的各端口之间不会直接进行通信，而是通过上联设备再将信息广播到所有端口上。 由此可见，即使是在同一Hub的不同两个端口之间进行通信，都必须要经过两步操作： 第一步是将信息上传到上联设备； 第二步是上联设备再将该信息广播到所有端口上。 半双工/全双工 Full-duplex（全双工）全双工是在通道中同时双向数据传输的能力。 Half-duplex（半双工）在通道中同时只能沿着一个方向传输数据。 DNS服务器 DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。 它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。 局域网(LAN) local area network，一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网。 覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。 使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s） 通信延迟时间短，可靠性较高 局域网可以支持多种传输介质 广域网(WAN) wide area network，一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。 覆盖的范围比局域网（LAN）和城域网（MAN）都广。广域网的通信子网主要使用分组交换技术。 广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。 适应大容量与突发性通信的要求； 适应综合业务服务的要求； 开放的设备接口与规范化的协议； 完善的通信服务与网络管理。 端口 逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。 端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。 客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号； 大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。 我们应该在自定义端口时，避免使用well-known的端口。如：80、21等等。 MTU MTU:通信术语 最大传输单元（Maximum Transmission Unit，MTU） 是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。 以下是一些协议的MTU： FDDI协议：4352字节 以太网（Ethernet）协议：1500字节 PPPoE（ADSL）协议：1492字节 X.25协议（Dial Up/Modem）：576字节 Point-to-Point：4470字节 常见网络知识题 TCP如何建立链接 TCP如何通信 TCP如何关闭链接 什么是滑动窗口 什么是半关闭 局域网内两台机器如何利用TCP/IP通信 internet上两台主机如何进行通信 如何在internet上识别唯一一个进程 答：通过“IP地址+端口号”来区分不同的服务 为什么说TCP是可靠的链接，UDP不可靠 路由器和交换机的区别 点到点，端到端 "},"linux-internet/tcp-udp.html":{"url":"linux-internet/tcp-udp.html","title":"TCP/UDP","keywords":"","body":"Socket编程 TCP/UDP预备知识套接字概念网络字节序IP地址转换函数sockaddr数据结构TCP网络套接字函数C/S模型-TCP出错处理封装函数UDP服务器C/S模型-UDP多播(组播)其它常用函数socket IPCserverclientSocket编程 TCP/UDP [TOC] 预备知识 套接字概念 网络字节序 IP地址转换函数 sockaddr数据结构 TCP 网络套接字函数 C/S模型-TCP 出错处理封装函数 UDP服务器 C/S模型-UDP 多播(组播) 其它常用函数 socket IPC server client 预备知识 套接字概念 Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。 既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 套接字的内核实现较为复杂，不宜在学习初期深入学习。 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。 套接字通信原理如下图所示： 套接字通讯原理示意 在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。 TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。本章的主要内容是socket API，主要介绍TCP协议的函数接口，最后介绍UDP协议和UNIX Domain Socket的函数接口。 网络字节序 我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。 TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。 为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。 #include uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); h表示host，n表示network，l表示32位长整数，s表示16位短整数。 如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。 IP地址转换函数 早期： #include #include #include int inet_aton(const char *cp, struct in_addr *inp); in_addr_t inet_addr(const char *cp); char *inet_ntoa(struct in_addr in); 只能处理IPv4的ip地址 不可重入函数 注意参数是struct in_addr 现在： #include int inet_pton(int af, const char *src, void *dst); const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); IP地址转换函数,字符串类型转换为网络字节序,参3:传出参数 支持IPv4和IPv6 可重入函数 其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。 因此函数接口是void *addrptr。 \"192.168.1.24\"字符串 –-> unsigned int —-> htonl() —-> 网络字节序 网络字节序 —-> ntohl() —-> unsigned int —-> \"192.168.1.24\"字符串 \"192.168.1.24\"字符串 ------------------> 网络字节序 inet_pton(); 网络字节序 ------------------> \"192.168.1.24\"字符串 inet_ntop(); sockaddr数据结构 strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 sockaddr数据结构 struct sockaddr { sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 使用sudo grep -r \"struct sockaddr\\_in {\" /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。 struct sockaddr_in { __kernel_sa_family_t sin_family; /* Address family */ 地址结构类型 __be16 sin_port; /* Port number */ 端口号 struct in_addr sin_addr; /* Internet address */ IP地址 /* Pad to size of `struct sockaddr'. */ unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)]; }; struct in_addr { /* Internet address. */ __be32 s_addr; }; struct sockaddr_in6 { unsigned short int sin6_family; /* AF_INET6 */ __be16 sin6_port; /* Transport layer port # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ __u32 sin6_scope_id; /* scope id (new in RFC2553) */ }; struct in6_addr { union { __u8 u6_addr8[16]; __be16 u6_addr16[8]; __be32 u6_addr32[4]; } in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32 }; struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ }; Pv4和IPv6的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，IPv6地址用sockaddr_in6结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在sys/un.h中，用sock-addr_un结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void *类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如： struct sockaddr_in servaddr; bind(listen_fd, (struct sockaddr *)&servaddr, sizeof(servaddr)); /* initialize servaddr */ TCP socket模型创建流程图 网络套接字函数 socket函数 socket套接字打开一个网络通讯端口 #include #include int socket(int domain, int type, int protocol); 成功：返回指向新创建的socket的文件描述符， 失败：返回-1，设置errno 参数： domain: AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址 AF_INET6 与上面类似，不过是来用IPv6的地址 AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用 type: SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。 SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。 SOCK_SEQPACKET 该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。 SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议） SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序 protocol: 传0 表示使用默认协议。 socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。 bind函数 bind绑定IP地址和端口号 #include #include int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功：返回0， 失败：返回-1, 设置errno 参数： sockfd： socket文件描述符 addr: 构造出IP地址+端口号 addrlen: sizeof(addr)长度 服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。 bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如： struct sockaddr_in servaddr; bzero(&servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(6666); 首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为INADDR_ANY，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。 listen函数 listen监听socket状态 #include /* See NOTES */ #include int listen(int sockfd, int backlog); sockfd: socket文件描述符 backlog: 排队建立3次握手队列和刚刚建立3次握手队列的链接数总和 查看系统默认backlog cat /proc/sys/net/ipv4/tcp_max_syn_backlog # 2048 典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。 accept函数 accept接受连接 #include #include int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 成功：返回一个新的socket文件描述符，用于和客户端通信， 失败：返回-1，设置errno sockdf: socket文件描述符 addr: 传出参数，返回链接客户端地址信息，含IP地址+端口号。 addrlen: 传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小 三次握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的ip地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。 我们的服务器程序结构是这样的： while (1) { cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &cliaddr_len); n = read(connfd, buf, MAXLINE); ...... close(connfd); } 整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。 connect函数 客户端需要调用connect()连接服务器 #include #include int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功：返回0， 失败：返回-1，设置errno sockdf: socket文件描述符 addr: 传入参数，指定服务器端地址信息，含IP地址和端口号 addrlen: 传入参数,传入sizeof(addr)大小 客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。 C/S模型-TCP socket模型创建流程图 下图是基于TCP协议的客户端/服务器程序的一般流程： TCP协议通讯流程 服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。 数据传输的过程： 建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。 如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。 在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段 server 下面通过最简单的客户端/服务器程序的实例来学习socket API。 server.c的作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。 #include #include #include #include #include #include #include #define MAXLINE 80 #define SERV_PORT 6666 int main(void){ struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int i, n; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)); listen(listenfd, 20); printf(\"Accepting connections ...\\n\"); while (1) { cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &cliaddr_len); n = read(connfd, buf, MAXLINE); printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (i = 0; i client client.c的作用是从命令行参数中获得一个字符串发给服务器，然后接收服务器返回的字符串并打印。 #include #include #include #include #include #include #define MAXLINE 80 #define SERV_PORT 6666 int main(int argc, char *argv[]){ struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, n; char *str; if (argc != 2) { fputs(\"usage: ./client message\\n\", stderr); exit(1); } str = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, \"127.0.0.1\", &servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)); write(sockfd, str, strlen(str)); n = read(sockfd, buf, MAXLINE); printf(\"Response from server:\\n\"); write(STDOUT_FILENO, buf, n); close(sockfd); return 0; } 由于客户端不需要固定的端口号，因此不必调用bind()，客户端的端口号由内核自动分配。注意，客户端不是不允许调用bind()，只是没有必要调用bind()固定一个端口号，服务器也不是必须调用bind()，但如果服务器不调用bind()，内核会自动给服务器分配监听端口，每次启动服务器时端口号都不一样，客户端要连接服务器就会遇到麻烦。 客户端和服务器启动后可以使用netstat命令查看链接情况： netstat -apn | grep 6666 nc(netcat)连接服务器 nc 常用： 侦听任意端口，以TCP/UDP 方式 端口扫描 传输文件 测速 常用命令： 1) -l 用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。 2) -p 限制数据发送原端口 3) -s 指定发送数据的源IP地址，适用于多网卡机 4) -u 指定nc使用UDP协议，默认为TCP 5) -v 输出交互或出错信息，新手调试时尤为有用 6）-w 超时秒数，后面跟数字 7）-z 表示zero，表示扫描时不发送任何数据 sudo apt install netcat nc 127.0.0.1 8000 # nc 连接服务器 出错处理封装函数 上面的例子不仅功能简单，而且简单到几乎没有什么错误处理，我们知道，系统调用不能保证每次都成功，必须进行出错处理，这样一方面可以保证程序逻辑正常，另一方面可以迅速得到故障信息。 为使错误处理的代码不影响主程序的可读性，我们把与socket相关的一些系统函数加上错误处理代码包装成新的函数，做成一个模块wrap.c： wrap.c wrap.h UDP服务器 传输层主要应用的协议模型有两种，一种是TCP协议，另外一种则是UDP协议。TCP协议在网络通信中占主导地位，绝大多数的网络通信借助TCP协议完成数据传输。但UDP也是网络通信中不可或缺的重要通信手段。 相较于TCP而言，UDP通信的形式更像是发短信。不需要在数据传输之前建立、维护连接。只专心获取数据就好。省去了三次握手的过程，通信速度可以大大提高，但与之伴随的通信的稳定性和正确率便得不到保证。因此，我们称UDP为“无连接的不可靠报文传递”。 那么与我们熟知的TCP相比，UDP有哪些优点和不足呢？由于无需创建连接，所以UDP开销较小，数据传输速度快，实时性较强。多用于对实时性要求较高的通信场合，如视频会议、电话会议等。但随之也伴随着数据传输不可靠，传输数据的正确率、传输顺序和流量都得不到控制和保证。所以，通常情况下，使用UDP协议进行数据传输，为保证数据的正确性，我们需要在应用层添加辅助校验协议来弥补UDP的不足，以达到数据可靠传输的目的。 与TCP类似的，UDP也有可能出现缓冲区被填满后，再接收数据时丢包的现象。由于它没有TCP滑动窗口的机制，通常采用如下两种方法解决： 1) 服务器应用层设计流量控制，控制发送数据速度。 2) 借助setsockopt函数改变接收缓冲区大小。如： #include int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); int n = 220x1024 setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)); C/S模型-UDP UDP处理模型 由于UDP不需要维护连接，程序逻辑简单了很多，但是UDP协议是不可靠的，保证通讯可靠性的机制需要在应用层实现。 编译运行server，在两个终端里各开一个client与server交互，看看server是否具有并发服务的能力。用Ctrl+C关闭server，然后再运行server，看此时client还能否和server联系上。和前面TCP程序的运行结果相比较，体会无连接的含义。 server #include #include #include #include #include #include #include #define MAXLINE 80 #define SERV_PORT 6666 int main(void){ struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int sockfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int i, n; sockfd = socket(AF_INET, SOCK_DGRAM, 0); bzero(&servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)); printf(\"Accepting connections ...\\n\"); while (1) { cliaddr_len = sizeof(cliaddr); n = recvfrom(sockfd, buf, MAXLINE,0, (struct sockaddr *)&cliaddr, &cliaddr_len); if (n == -1) perror(\"recvfrom error\"); printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (i = 0; i client #include #include #include #include #include #include #include #define MAXLINE 80 #define SERV_PORT 6666 int main(int argc, char *argv[]){ struct sockaddr_in servaddr; int sockfd, n; char buf[MAXLINE]; sockfd = socket(AF_INET, SOCK_DGRAM, 0); bzero(&servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, \"127.0.0.1\", &servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); while (fgets(buf, MAXLINE, stdin) != NULL) { n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&servaddr, sizeof(servaddr)); if (n == -1) perror(\"sendto error\"); n = recvfrom(sockfd, buf, MAXLINE, 0, NULL, 0); if (n == -1) perror(\"recvfrom error\"); write(STDOUT_FILENO, buf, n); } close(sockfd); return 0; } 多播(组播) 组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。 224.0.0.0～224.0.0.255 为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用； 224.0.1.0～224.0.1.255 是公用组播地址，可以用于Internet；欲使用需申请。 224.0.2.0～238.255.255.255 为用户可用的组播地址（临时组地址），全网范围内有效； 239.0.0.0～239.255.255.255 为本地管理组播地址，仅在特定的本地范围内有效。 可使用ip ad命令查看网卡编号，如： $ ip ad 1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp1s0: mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000 link/ether 2c:60:0c:4a:38:6f brd ff:ff:ff:ff:ff:ff 3: wlx200db0129d50: mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 20:0d:b0:12:9d:50 brd ff:ff:ff:ff:ff:ff inet 192.168.1.107/24 brd 192.168.1.255 scope global noprefixroute dynamic wlx200db0129d50 valid_lft 4428sec preferred_lft 4428sec inet6 fe80::27a7:2153:73c6:55cd/64 scope link noprefixroute valid_lft forever preferred_lft forever if_nametoindex 命令可以根据网卡名，获取网卡序号。 server client 其它常用函数 名字与地址转换 gethostbyname根据给定的主机名，获取主机信息。 过时，仅用于IPv4，且线程不安全。 gethostbyaddr函数，此函数只能获取域名解析服务器的url和/etc/hosts里登记的IP对应的域名。 getservbyname getservbyport 根据服务程序名字或端口号获取信息。使用频率不高。 getaddrinfo getnameinfo freeaddrinfo 可同时处理IPv4和IPv6，线程安全的。 套接口和地址关联 getsockname 根据accpet返回的sockfd，得到临时端口号 getpeername 根据accpet返回的sockfd，得到远端链接的端口号，在exec后可以获取客户端信息。 socket IPC （本地套接字Domain Socket） socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制，就是UNIX Domain Socket。虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。 UNIX Domain Socket是全双工的，API接口语义丰富，相比其它IPC机制有明显的优越性，目前已成为使用最广泛的IPC机制，比如X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的。 使用UNIX Domain Socket的过程和网络socket十分相似，也要先调用socket()创建一个socket文件描述符，address family指定为AF_UNIX，type可以选择SOCK_DGRAM或SOCK_STREAM，protocol参数仍然指定为0即可。 UNIX Domain Socket与网络socket编程最明显的不同在于地址格式不同，用结构体sockaddr_un表示，网络编程的socket地址是IP地址+端口号，而本地套接字UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。 对比网络套接字地址结构和本地套接字地址结构： struct sockaddr_in { __kernel_sa_family_t sin_family; /* Address family */ 地址结构类型 __be16 sin_port; /* Port number */ 端口号 struct in_addr sin_addr; /* Internet address */ IP地址 }; struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ 地址结构类型 char sun_path[UNIX_PATH_MAX]; /* pathname */ socket文件名(含路径) }; 以下程序将UNIX Domain socket绑定到一个地址。 size = offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path); #define offsetof(type, member) ((int)&((type *)0)->MEMBER) server client "},"linux-internet/duo-jin-cheng-bing-fa.html":{"url":"linux-internet/duo-jin-cheng-bing-fa.html","title":"多进程线程并发","keywords":"","body":"多进程/线程并发服务器多进程并发服务器serverclient多线程并发服务器serverclient多进程/线程并发服务器 [TOC] 多进程并发服务器 server client 多线程并发服务器 server client 多进程并发服务器 使用多进程并发服务器时要考虑以下几点： 父进程最大文件描述个数(父进程中需要close关闭accept返回的新文件描述符) 系统内创建进程个数(与内存大小相关) 进程创建过多是否降低整体服务性能(进程调度) server /* server.c */ client /* client.c */ 多线程并发服务器 在使用线程模型开发服务器时需考虑以下问题： 调整进程内最大文件描述符上限 线程如有共享数据，考虑线程同步 服务于客户端线程退出时，退出处理。（退出值，分离态） 系统负载，随着链接客户端增加，导致其它线程不能及时得到CPU server /* server.c */ client /* client.c */ "},"linux-internet/duo-lu-IO-zhuan-jie.html":{"url":"linux-internet/duo-lu-IO-zhuan-jie.html","title":"多路IO转接","keywords":"","body":"多路I/O转接服务器多路I/O转接服务器selectpollepollepoll进阶线程池并发处理服务器多路I/O转接服务器 [TOC] 多路I/O转接服务器 select poll epoll epoll进阶 线程池并发处理服务器 多路I/O转接服务器 多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。 主要使用的方法有三种select，poll，epoll。 select select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数 解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力。 #include /* According to earlier standards */ #include #include #include int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout); nfds: 监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态 readfds： 监控有读数据到达文件描述符集合，传入传出参数 writefds： 监控有写数据到达文件描述符集合，传入传出参数 exceptfds： 监控异常发生达文件描述符集合，如带外数据到达异常，传入传出参数 timeout： 定时阻塞监控时间，3种情况 1.NULL，永远等下去 2.设置timeval，等待固定时间 3.设置timeval里时间均为0，检查描述字后立即返回，轮询 ​ struct timeval { long tv_sec; /* seconds */ long tv_usec; /* microseconds */ }; 文件描述符集合操作 void FD_CLR(int fd, fd_set *set); //把文件描述符集合里fd清0 int FD_ISSET(int fd, fd_set *set); //测试文件描述符集合里fd是否置1 void FD_SET(int fd, fd_set *set); //把文件描述符集合里fd位置1 void FD_ZERO(fd_set *set); //把文件描述符集合里所有位清0 server /* server.c */ client /* client.c */ pselect pselect原型如下。此模型应用较少，有需要的同学可参考select模型自行编写C/S #include int pselect(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, const struct timespec *timeout,const sigset_t *sigmask); struct timespec { long tv_sec; /* seconds */ long tv_nsec; /* nanoseconds */ }; 用sigmask替代当前进程的阻塞信号集，调用返回后还原原有阻塞信号集 poll #include int poll(struct pollfd *fds, nfds_t nfds, int timeout); struct pollfd { int fd; /* 文件描述符 */ short events; /* 监控的事件 */ short revents; /* 监控事件中满足条件返回的事件 */ }; POLLIN 普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND POLLRDNORM 数据可读 POLLRDBAND 优先级带数据可读 POLLPRI 高优先级可读数据 POLLOUT 普通或带外数据可写 POLLWRNORM 数据可写 POLLWRBAND 优先级带数据可写 POLLERR 发生错误 POLLHUP 发生挂起 POLLNVAL 描述字不是一个打开的文件 nfds 监控数组中有多少文件描述符需要被监控 timeout 毫秒级等待 -1：阻塞等，#define INFTIM -1 Linux中没有定义此宏 0：立即返回，不阻塞进程 >0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值 如果不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。 server /* server.c */ client /* client.c */ ppoll GNU定义了ppoll（非POSIX标准），可以支持设置信号屏蔽字，大家可参考poll模型自行实现C/S。 #define _GNU_SOURCE /* See feature_test_macros(7) */ #include int ppoll(struct pollfd *fds, nfds_t nfds,const struct timespec *timeout_ts, const sigset_t *sigmask); epoll epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。 目前epell是linux大规模并发网络程序中的热门首选模型。 epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。 可以使用cat命令查看一个进程可以打开的socket描述符上限。 cat /proc/sys/fs/file-max 801558 如有需要，可以通过修改配置文件的方式修改该上限值。 sudo vi /etc/security/limits.conf 在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。 * soft nofile 65536 * hard nofile 100000 基础API 创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。 #include int epoll_create(int size) // size：监听数目 控制某个epoll监控的文件描述符上的事件：注册、修改、删除。 #include int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) epfd： 为epoll_creat的句柄 op： 表示动作，用3个宏来表示： EPOLL_CTL_ADD (注册新的fd到epfd)， EPOLL_CTL_MOD (修改已经注册的fd的监听事件)， EPOLL_CTL_DEL (从epfd删除一个fd)； event： 告诉内核需要监听的事件 struct epoll_event { __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭） EPOLLOUT： 表示对应的文件描述符可以写 EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来） EPOLLERR： 表示对应的文件描述符发生错误 EPOLLHUP： 表示对应的文件描述符被挂断； EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的 EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 等待所监控文件描述符上有事件的产生，类似于select()调用。 #include int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout) 成功：返回有多少文件描述符就绪， 时间到时返回0， 出错返回-1 events： 用来存内核得到事件的集合， maxevents： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size， timeout： 是超时时间 -1： 阻塞 0： 立即返回，非阻塞 >0： 指定毫秒 server / server.c / client /* client.c */ epoll进阶 事件触发模型 EPOLL事件有两种模型： 边缘触发(ET)Edge Triggered 只有数据到来才触发，不管缓存区中是否还有数据。 水平触发(LT)Level Triggered 只要有数据都会触发。 思考如下步骤： 假定我们已经把一个用来从管道中读取数据的文件描述符(RFD)添加到epoll描述符。 管道的另一端写入了2KB的数据 调用epoll_wait，并且它会返回RFD，说明它已经准备好读取操作 读取1KB的数据 调用epoll_wait…… 在这个过程中，有两种工作模式： ET模式 ET模式即Edge Triggered工作模式。 如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用no-block非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。 1) 基于no-block非阻塞文件句柄 2) 只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。 LT模式（默认） LT模式即Level Triggered工作模式。 与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。 LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。 ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once). epoll LT/ET： 基于管道epoll LT/ET触发模式 C/S模型的epoll ET： 基于网络C/S模型的epoll ET触发模式 /* server.c */ /* client.c */ C/S非阻塞epoll ET： 基于网络C/S非阻塞模型的epoll ET触发模式 /* server.c */ /* client.c */ 线程池并发处理服务器 预先创建阻塞于accept多线程，使用互斥锁上锁保护accept 预先创建多线程，由主线程调用accept "},"web-server/":{"url":"web-server/","title":"Web服务器","keywords":"","body":"linux-Web服务器linux-Web服务器 "},"web-server/untitled.html":{"url":"web-server/untitled.html","title":"Untitled","keywords":"","body":"UntitledUntitled "},"html/":{"url":"html/","title":"HTML","keywords":"","body":"HTMLhtml概述HTML [toc] html概述 html简介 HTML是 HyperText Mark-up Language 的首字母简写，意思是超文本标记语言，超文本指的是超链接，标记指的是标签，是一种用来制作网页的语言，这种语言由一个个的标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm，一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。 HTML特点 语法非常简洁、比较松散,以相应的英语单词关键字进行组合 html标签不区分大小写 大多数标签是成对出现的, 有开始, 有结束. 不成对出现的称之为短标签 什么是 HTML？ HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 标签 HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 HTML 标签通常是成对出现的，比如 和 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 HTML 文档 = 网页 HTML 文档描述网页 HTML 文档包含 HTML 标签和纯文本 HTML 文档也被称为网页 Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。 html基本结构 一个html的基本结构如下： 网页标题 网页显示内容 第一行是文档声明，第二行“”标签和最后一行“”定义html文档的整体，“”标签中的‘lang=“en”’定义网页的语言为英文，定义成中文是'lang=\"zh-CN\"',不定义也没什么影响，它一般作为分析统计用。 “”标签和“”标签是它的第一层子元素，“”标签里面负责对网页进行一些设置以及定义标题，设置包括定义网页的编码格式，外链css样式文件和javascript文件等，设置的内容不会显示在网页上，标题的内容会显示在标题栏，“”内编写网页上显示的内容。 声明文档类型 与 之间的文本描述网页 与之间的文本标签里面负责对网页进行一些设置以及定义标题 与显示在浏览器窗口的标题栏中“网页名称” 与 之间的文本是可见的页面内容 HTML文档版本 声明帮助浏览器正确地显示网页。 目前常用的两种文档版本类型是xhtml 1.0和html5 xhtml 1.0 xhtml 1.0 是html5之前的一个常用的版本，目前许多网站仍然使用此版本。 文档示例： xhtml 1.0 文档类型 html5 html5是向下兼容的 文档示例： html5文档类型 两种文档的区别 文档声明和编码声明 html5新增了标签元素以及元素属性 "},"html/html.html":{"url":"html/html.html","title":"HTML基础","keywords":"","body":"htmlhtml基础html [toc] html基础 注释 html文档代码中可以插入注释，注释是对代码的说明和解释，注释的内容不会显示在页面上，html代码中插入注释的方法是： 标题标签 通过 、、、、、,标签可以在网页上定义6种级别的标题。6种级别的标题表示文档的6级目录层级关系，比如说： 用作主标题，其后是 ，再其次是 ，以此类推。搜索引擎会使用标题将网页的结构和内容编制索引，所以网页上使用标题是很重要的。 这是一级标题 这是二级标题 这是三级标题 这是四级标题 段落标签 标签定义一个文本段落，一个段落含有默认的上下间距，段落之间会用这种默认间距隔开，代码如下： 段落 HTML是 HyperText Mark-up Language 的首字母简写，意思是超文本标记语言，超 文本指的是超链接，标记指的是标签，是一种用来制作网页的语言，这种语言由一个个的 标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm。 一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用文本的方 式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页，显示的网 页可以从一个网页链接跳转到另外一个网页。 文本标签?? 属性: color: 文字颜色 表示方式: 英文单词: red green blue...... 使用16进制的形式表示颜色: #ffffff -- (rgb) 使用rgb(255, 255, 0) size: 文字大小 范围 1 -- 7 文本格式化 HTML 可定义很多供格式化输出的元素，比如粗体和斜体字。 文本格式化标签 标签 描述 定义粗体文本。 定义大号字。 定义着重文字。 定义斜体字。 定义小号字。 定义加重语气。 定义下标字。 定义上标字。 定义插入字。 定义删除字。 不赞成使用。使用 代替。 不赞成使用。使用 代替。 不赞成使用。使用样式（style）代替。 “计算机输出”标签 标签 描述 定义计算机代码。 定义键盘码。 定义计算机代码样本。 定义打字机代码。 定义变量。 定义预格式文本。 不赞成使用。使用 代替。 不赞成使用。使用 代替。 不赞成使用。使用 代替。 引用、引用和术语定义 标签 描述 定义缩写。 定义首字母缩写。 定义地址。 定义文字方向。 定义长的引用。 定义短的引用语。 定义引用、引证。 定义一个定义项目。 换行标签 代码中成段的文字，直接在代码中回车换行，在渲染成网页时候不认这种换行，如果真想换行，可以在代码的段落中插入来强制换行，代码如下： 一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用 文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件 渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。 水平线 属性: color: 3种表示方法 size: 1-7 字符实体 代码中成段的文字，如果文字间想空多个空格，在代码中空多个空格，在渲染成网页时只会显示一个空格，如果想显示多个空格，可以使用空格的字符实体&nbsp;,代码如下： &nbsp;&nbsp;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用 文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件 渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。 在网页上显示 “” 会误认为是标签，想在网页上显示“”可以使用它们的字符实体 &lt; &gt;，比如： ” 的字符实体为 &lt; 和 &gt; --> 3 &lt; 5 10 &gt; 5 HTML 中有用的字符实体 注释：实体名称对大小写敏感！ 显示结果 描述 实体名称 实体编号 空格     小于号 > 大于号 > > & 和号 & & \" 引号 \" \" ' 撇号 ' (IE不支持) ' ￠ 分（cent） ¢ ¢ £ 镑（pound） £ £ ¥ 元（yen） ¥ ¥ € 欧元（euro） € € § 小节 § § © 版权（copyright） © © ® 注册商标 ® ® ™ 商标 ™ ™ × 乘号 × × ÷ 除号 ÷ ÷ 块标签 大多数 HTML 元素被定义为块级元素或内联元素。 块级元素在浏览器显示时，通常会以新行来开始（和结束）。 例子：, , , 内联元素在显示时通常不会以新行开始。 例子：, , , 可以通过 和 将 HTML 元素组合起来。 标签 行间块元素，表示一块内容，定义文档中的分区或节。 标签 行内元素，表示一行中的一小段内容，定义 span，用来组合文档中的行内元素。 元素 HTML 元素是块级元素，它是可用于组合其他 HTML 元素的容器。 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 如果与 CSS 一同使用， 元素可用于对大的内容块设置样式属性。 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 元素进行文档布局不是表格的正确用法。 元素的作用是显示表格化的数据。 属性: 对齐方式 align left, center, right 元素 HTML 元素是内联元素，可用作文本的容器。 元素也没有特定的含义。 当与 CSS 一同使用时， 元素可用于为部分文本设置样式属性。 style 属性样式 style 属性用于改变 HTML 元素的样式。 HTML 的 style 属性提供了一种改变所有 HTML 元素的样式的通用方法。 样式是 HTML 4 引入的，它是一种新的首选的改变 HTML 元素样式的方式。通过 HTML 样式，能够通过使用 style 属性直接将样式添加到 HTML 元素，或者间接地在独立的样式表中（CSS 文件）进行定义。 背景颜色 background-color 属性为元素定义了背景颜色： This is a paragraph. 字体、颜色和尺寸 font-family、color 以及 font-size 属性分别定义元素中文本的字体系列、颜色和字体尺寸： A paragraph. 文本对齐 text-align 属性规定了元素中文本的水平对齐方式 This is a heading 图像标签 标签可以在网页上插入一张图片，它是独立使用的标签，它的常用属性有： src属性 定义图片的引用地址 alt属性 定义图片加载失败时显示的文字，搜索引擎会使用这个文字收录图片、盲人读屏软件会读取这个文字让盲人识别图片，所以此属性非常重要。 title: 提示文本 鼠标放到图片上显示的文字 width: 图片宽度 height: 图片高度 图片没有定义宽高的时候,图片按照百分之百比例显示。 如果只更改图片的宽度或者高度,图片等比例缩放。 路径 像网页上插入图片这种外部文件，需要定义文件的引用地址，引用外部文件还包括引用外部样式表，javascript等等，引用地址分为绝对地址和相对地址。 绝对地址：相对于磁盘的位置去定位文件的地址 相对地址：相对于引用文件本身去定位被引用的文件地址 绝对地址在整体文件迁移时会因为磁盘和顶层目录的改变而找不到文件，相对路径就没有这个问题。相对路径的定义技巧： “ ./ ” 表示当前文件所在目录下，比如：“./pic.jpg” 表示当前目录下的pic.jpg的图片，这个使用时可以省略。 “ ../ ” 表示当前文件所在目录下的上一级目录，比如：“../images/pic.jpg” 表示当前目录下的上一级目录下的images文件夹中的pic.jpg的图片。 链接标签 超链接标签 标签可以在网页上定义一个链接地址，它的常用属性有： href属性 定义跳转的地址 title属性 定义鼠标悬停时弹出的提示文字框 target属性 定义链接窗口打开的位置 target=\"_self\" 缺省值，新页面替换原来的页面，在原来位置打开 target=\"_blank\" 新页面会在新开的一个浏览器窗口打开 百度 测试页面 锚链接 先定义一个id锚点: 超链接到锚点: 回到顶点 有序列表 在网页上定义一个有编号的内容列表可以用、配合使用来实现，代码如下： 列表文字一 列表文字二 列表文字三 在网页上生成的列表，每条项目上会按1、2、3编号，有序列表在实际开发中较少使用。 属性: type -- 序号 1 -- 默认 a A i -- 罗马数字(小) I -- 罗马数字(大) start 从序号的什么位置开始表示 无序列表 在网页上定义一个无编号的内容列表可以用、配合使用来实现，代码如下： 新闻标题一 新闻标题二 新闻标题三 在网页上生成的列表，每条项目上会有一个小图标，这个小图标在不同浏览器上显示效果不同，所以一般会用样式去掉默认的小图标，如果需要图标，可以用样式自定义图标，从而达到在不同浏览器上显示的效果相同,实际开发中一般用这种列表。 属性: type 实心圆圈: disc -- 默认 空心圆圈: circle 小方块: squar 定义列表 定义列表通常用于术语的定义。标签表示列表的整体。标签定义术语的题目。标签是术语的解释。一个中可以有多个题目和解释，代码如下： 前端三大块 html 负责页面的结构 css 负责页面的表现 javascript 负责页面的行为 表单 表单用于搜集不同类型的用户输入，表单由不同类型的标签组成，相关标签及属性用法如下： 1、标签 定义整体的表单区域 action属性 定义表单数据提交地址 method属性 定义表单提交的方式，一般有“get”方式和“post”方式 2、标签 为表单元素定义文字标注 3、标签 定义通用的表单元素 type属性 type=\"text\" 定义单行文本输入框 type=\"password\" 定义密码输入框 type=\"radio\" 定义单选框 type=\"checkbox\" 定义复选框 type=\"file\" 定义上传文件 type=\"submit\" 定义提交按钮 type=\"reset\" 定义重置按钮 type=\"button\" 定义一个普通按钮 type=\"image\" 定义图片作为提交按钮，用src属性定义图片地址 type=\"hidden\" 定义一个隐藏的表单域，用来存储值 value属性 定义表单元素的值 name属性 定义表单元素的名称，此名称是提交数据时的键名 4、标签 定义多行文本输入框 5、标签 定义下拉表单元素 6、标签 与标签配合，定义下拉表单元素中的选项 注册表单实例： 姓名： 密码： 性别： 男 女 爱好： 唱歌 跑步 游泳 照片： 个人描述： 籍贯： 北京 上海 广州 深圳 --> 表格 1、标签：声明一个表格，它的常用属性如下： border属性 定义表格的边框，设置值是数值 cellpadding属性 定义单元格内容与边框的距离，设置值是数值 cellspacing属性 定义单元格与单元格之间的距离，设置值是数值 align属性 设置整体表格相对于浏览器窗口的水平对齐方式,设置值有：left | center | right 2、标签：定义表格中的一行 3、和标签：定义一行中的一个单元格，td代表普通单元格，th表示表头单元格，它们的常用属性如下： align 设置单元格中内容的水平对齐方式,设置值有：left | center | right valign 设置单元格中内容的垂直对齐方式 top | middle | bottom colspan 设置单元格水平合并，设置值是数值 rowspan 设置单元格垂直合并，设置值是数值 基本情况 15% 25% 15% 25% 1 2 3 4 11 22 33 44 11 22 44 01 04 页面布局概述 布局也可以叫做排版，它指的是把文字和图片等元素按照我们的意愿有机地排列在页面上，布局的方式分为两种： 1、布局：通过table元素将页面空间划分成若干个单元格，将文字或图片等元素放入单元格中，隐藏表格的边框，从而实现布局。这种布局方式也叫传统布局，目前主要使用在EDM(广告邮件中的页面)中，主流的布局方式不用这种。 2、+CSS布局：主要通过CSS样式设置来布局文字或图片等元素，需要用到CSS盒子模型、盒子类型、CSS浮动、CSS定位、CSS背景图定位等知识来布局，它比传统布局要复杂，目前是主流的布局方式。 布局 table来做整体页面的布局，布局的技巧归纳为如下几点： 1、按照设计图的尺寸设置表格的宽高以及单元格的宽高。 2、将表格border、cellpadding、cellspacing全部设置为0，表格的边框和间距就不占有页面空间，它只起到划分空间的作用。 3、针对局部复杂的布局，可以在单元格里面再嵌套表格，嵌套表格划分局部的空间。 4、单元格中的元素或者嵌套的表格用align和valign设置对齐方式 5、通过属性或者css样式设置单元格中元素的样式 table布局实例（个人简历页面布局实例） 使用表格的 HTML 布局 注释： 元素不是作为布局工具而设计的。 元素的作用是显示表格化的数据。 使用 元素能够取得布局效果，因为能够通过 CSS 设置表格元素的样式： html The table element was not designed to be a layout tool. CSS table.lamp { width:100%; border:1px solid #d4d4d4; } table.lamp th, td { padding:10px; } table.lamp td { width:40px; } +CSS布局 使用 元素的 HTML 布局 注释： 元素常用作布局工具，因为能够轻松地通过 CSS 对其进行定位。 html City Gallery London Paris Tokyo London London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants. Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium. Copyright W3School.com.cn CSS： #header { background-color:black; color:white; text-align:center; padding:5px; } #nav { line-height:30px; background-color:#eeeeee; height:300px; width:100px; float:left; padding:5px; } #section { width:350px; float:left; padding:10px; } #footer { background-color:black; color:white; clear:both; text-align:center; padding:5px; } HTML 字符集 如需正确地显示 HTML 页面，浏览器必须知道使用何种字符集。 万维网早期使用的字符集是 ASCII。ASCII 支持 0-9 的数字，大写和小写英文字母表，以及一些特殊字符。 由于很多国家使用的字符并不属于 ASCII，现代浏览器的默认字符集是 ISO-8859-1。 如果网页使用不同于 ISO-8859-1 的字符集，就应该在 标签进行指定。 charset=iso-8859-1 西欧的编码,说明网站采用的编码是英文; charset=gb2312 说明网站采用的编码是简体中文; charset=utf-8 代表世界通用的语言编码;可以用到中文、韩文、日文等世界上所有语言编码上 charset=big5 说明网站采用的编码是繁体中文; "},"http/":{"url":"http/","title":"HTTP协议","keywords":"","body":"HTTPhttp协议概述HTTP [TOC] http协议概述 超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。 HTTP是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用TCP协议。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，但是在HTTP协议中并没有规定它必须使用或它支持的层。事实上HTTP可以在任何互联网协议或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用，所以其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息。(维基百科) 短连接和长连线 在HTTP 0.9和1.0中，TCP连线在每一次请求/回应对之后关闭。在HTTP 1.1中，引入了保持连线的机制，一个连接可以重复在多个请求/回应使用。持续连线的方式可以大大减少等待时间，因为在发出第一个请求后，双方不需要重新运行TCP握手程序。 "},"http/http.html":{"url":"http/http.html","title":"HTTP基础","keywords":"","body":"http协议请求消息(Request)响应消息(Response)URLhttp协议 [TOC] http协议 - 应用层 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。 请求消息(Request) 请求消息(Request) - 浏览器给服务器发送的数据 客户端发送一个HTTP请求到服务器的请求消息包括四部分: 请求行, 请求头, 空行, 请求数据 请求行: 说明请求类型, 要访问的资源, 以及使用的http版本 请求头: 说明服务器要使用的附加信息 空行: 空行是必须要有的, 即使没有请求数据 请求数据: 也叫主体, 可以添加任意的其他数据 请求方法 HTTP1.1的五种请求方法 下面的表格列出了其他一些 HTTP 请求方法： 方法 描述 GET 请求指定的页面信息数据，并返回实体主体。 POST 向指定资源提交数据进行处理的请求(例如提交表单或者上传文件)。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 HEAD 类似于get请求，但只返回 HTTP 报头，不返回文档主体，用于获取报头。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 OPTIONS 返回服务器支持的 HTTP 方法。 CONNECT 把请求连接转换到透明的 TCP/IP 通道。 在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。 GET - 从指定的资源请求数据。 POST - 向指定的资源提交要被处理的数据。 GET 方法 使用get方法请求数据: GET /test.txt HTTP/1.1 // 请求行 Host: localhost:2222 // 请求头 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:24.0) Gecko/201001 01 Firefox/24.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/ *;q=0.8 Accept-Language: zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: keep-alive If-Modified-Since: Fri, 18 Jul 2014 08:36:36 GMT\\r\\n // 空行 请求数据(可以为空) // 请求数据 请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的： /test/demo_form.asp?name1=value1&name2=value2 有关 GET 请求的其他一些注释： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 请求示例： 当在浏览器地址栏输入http://192.168.43.118:3434/text.txt向服务器发送请求： GET /test.txt HTTP/1.1 // 请求行，要访问资源 /test.txt Host: 192.168.43.118:3434 // 请求头 Connection: keep-alive DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 // 空行 请求数据空(可以为空) // 请求数据 百度请求示例： GET / HTTP/1.1 // 请求行，要访问资源 / Host: www.baidu.com // 请求头 Connection: keep-alive Cache-Control: max-age=0 DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: BIDUPSID=F59F13A20C5C1BD4105595034149E154; PSTM=1592187477; BAIDUID=F59F13A20C5C1BD4F2D6FC754668989A:FG=1; BD_UPN=123353; BD_HOME=1; H_PS_PSSID=1423_32124_32140_32045_32231_32145_32257; delPer=0; BD_CK_SAM=1; PSINO=5; ZD_ENTRY=empty // 空行 请求数据空(可以为空) // 请求数据 浏览器地址栏: 192.168.1.115/hello.c 浏览器封装一个http请求协议？？ get /hello.c http/1.1 POST 方法 使用post方法请求数据: POST HTTP/1.1 // 请求行 Host: localhost:2222 // 请求头 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:24.0) Gecko/201001 01 Firefox/24.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/ *;q=0.8 Accept-Language: zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: keep-alive If-Modified-Since: Fri, 18 Jul 2014 08:36:36 GMT // 空行 user=詹姆斯&pwd=James&sex=男 // 请求数据 请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&name2=value2 有关 POST 请求的其他一些注释： POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 比较 GET 与 POST 下面的表格比较了两种 HTTP 方法：GET 和 POST。 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 响应消息(Response) 响应消息(Response) - 服务器给浏览器发送的数据 响应消息四部分: 状态行(必须), 消息报头, 空行(必须), 响应正文 状态行: 包括http协议版本号, 状态码, 状态信息 消息报头: 说明客户端要使用的一些附加信息 空行: 空行是必须要有的 响应正文: 服务器返回给客户端的文本信息 HTTP/1.1 200 Ok // 状态行 Server: micro_httpd // 消息报头 Date: Fri, 18 Jul 2014 14:34:26 GMT Content-Type: text/plain; charset=utf-8 (重要，响应的数据类型) Content-Length: 32 //响应的数据的长度 Content-Language: zh-CN Last-Modified: Fri, 18 Jul 2014 08:36:36 GMT Connection: close // 空行 xxx响应正文 // 响应正文 百度响应示例： HTTP/1.1 200 OK // 状态行 Cache-Control: private // 消息报头 Connection: keep-alive Content-Encoding: gzip Content-Type: html;charset=utf-8 Date: Fri, 10 Jul 2020 04:29:01 GMT Expires: Fri, 10 Jul 2020 04:28:51 GMT Server: BWS/1.1 Set-Cookie: BDSVRTM=0; path=/ Set-Cookie: BD_HOME=1; path=/ Set-Cookie: H_PS_PSSID=1423_32124_32140_32045_32231_32145_32257; path=/; domain=.baidu.com Strict-Transport-Security: max-age=172800 Traceid: 1594355341057394381816994770365719048149 X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked // 空行 // 响应正文 百度一下 这是百度的主页面 http状态码 当浏览器从 web 服务器请求服务时，可能会发生错误。 从而有可能会返回下面的一系列状态消息： 状态代码有三位数字组成,第一个数字定义了响应的类别,共分五种类别: 1xx:指示信息 ​ 表示请求已接收,继续处理 2xx:成功 ​ 表示请求已被成功接收、理解、接受 3xx:重定向 ​ 要完成请求必须进行更进一步的操作 4xx:客户端错误 ​ 请求有语法错误或请求无法实现 5xx:服务器端错误 ​ 服务器未能实现合法的请求 常见状态码: 状态码 描述 200 OK 客户端请求成功 400 Bad Request 客户端请求有语法错误,不能被服务器所理解 401 Unauthorized 请求未经授权,这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求,但是拒绝提供服务 404 Not Found 请求资源不存在，如输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求,一段时间后可能恢复正常 http中文件类型 普通文件: text/plain; charset=utf-8 .html: text/html; charset=utf-8 .jpg : image/jpeg .gif : image/gif .png: image/png .wav: audio/wav .avi : video/x-msvideo .mov: video/quicktime .mp3: audio/mpeg 字符集 charset=iso-8859-1 西欧的编码,说明网站采用的编码是英文; charset=gb2312 说明网站采用的编码是简体中文; charset=utf-8 代表世界通用的语言编码;可以用到中文、韩文、日文等世界上所有语言编码上 charset=big5 说明网站采用的编码是繁体中文; URL URL组成 统一资源定位器（URL） - Uniform Resource Locator 统一资源定位器（URL）用于定位万维网上的文档（或其他数据）。 URL 也被称为网址。URL 可以由单词组成，比如 “baidu.com”，或者是因特网协议（IP）地址：192.168.1.253。 当您点击 HTML 页面中的某个链接时，对应的 标签指向万维网上的一个地址。 scheme://host.domain:port/path/filename https://www.baidu.com:443/ scheme - 定义因特网服务的类型。最常见的类型是 http,https,ftp host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 w3school.com.cn :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 一个完整的URL例子： 一个完整的URL包括：协议部分、域名部分、端口部分、虚拟目录部分、文件名部分、参数部分、锚部分 1.协议：模式/协议（scheme）,在Internet中可使用多种协议，如HTTP，FTP等。在”HTTP”后面的“//”为分隔符 2.域名：也可使用IP地址作为域名使用。 3.端口：不是一个URL必须的部分，如果省略端口部分，将采用默认端口。 4.虚拟目录：从域名后的第一个“/”开始到最后一个“/”为止。虚拟目录不是一个URL必须的部分。 5.文件名：从域名后的最后一个“/”至“？”(或“#”或至结束)为止，是文件名部分。文件名部分不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。 7.参数：从“？”开始到“#”（或至结束）为止之间的部分为参数部分，又称搜索部分、查询部分。参数间用“&”作为分隔符。 6.锚：或称片段（fragment），HTTP请求不包括锚部分，从“#”开始到最后，都是锚部分。本例中的锚部分是“r_70732423“。锚部分不是一个URL必须的部分。 锚点作用：打开用户页面时滚动到该锚点位置。如：一个html页面中有一段代码【...】，该url的hash为r_70732423 基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名，如下： 协议：//授权/路径?查询 完整的、带有授权部分的普通统一资源标志符语法看上去如下： 协议：//用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志 URL 编码 URL 编码会将字符转换为可通过因特网传输的格式。 URL 只能使用 ASCII 字符集来通过因特网进行发送。 由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。 URL 编码使用 \"%\" 其后跟随几位的十六进制数来替换非 ASCII 字符。 URL 不能包含空格。URL 编码通常使用 + 来替换空格。 你好 ––>> %e4%bd%a0%e5%a5%bd 一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。只有字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*'(),[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。 GET和POST方法的编码，用的是网页的编码。编码方法由网页的编码决定，也就是由HTML源码中字符集的设定决定。 如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。 实现http服务器 编写函数解析http请求 ○ GET /hello.html HTTP/1.1\\r\\n ○ 将上述字符串分为三部分解析出来 编写函数根据文件后缀,返回对应的文件类型 sscanf - 读取格式化的字符串中的数据 ○ 使用正则表达式拆分 ○ [^ ]的用法 通过浏览器请求目录数据 ○ 读指定目录内容 ○ opendir ○ readdir ○ closedir ○ scandir - 扫描dir目录下(不包括子目录)内容 http中数据特殊字符编码解码问题 ○ 编码 ○ 解码 "},"design-pattern/":{"url":"design-pattern/","title":"设计模式","keywords":"","body":"设计模式设计模式 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 1.软件建模概述 2.UML 3.用例图 4.类图 5.对象图 6.时序图 7.活动图 1.设计模式概述 2.面向对象设计原则 3.创建型模型 4.结构型模式 5.行为型模式 "},"design-pattern/uml.html":{"url":"design-pattern/uml.html","title":"UML","keywords":"","body":"UML统一建模语言1.软件建模概述1.1什么是建模1.2建模原则1.3软件建模的实现过程2.UML2.1 UML一共有10种图3.用例图3.1 用例之间的关系——泛化关系3.2 用例之间的关系——包含关系3.3 用例之间的关系——扩展关系4.类图4.1类的表示法4.2类之间的关系-泛化关系4.3 类之间的关系-实现关系4.4 类之间的关系-依赖关系4.5 类之间的关系-关联关系4.6 关联关系的名称4.7 关联关系的角色4.8 关联关系的多重性4.9 类之间的关系关联-聚合4.10 类之间的关系关联—组合4.11 类图练习题5.对象图6.时序图6.1 借书时序图6.2 ATM 用户成功登陆的时序图6.3 时序图中的基本概念6.4 时序图练习题7.活动图7.1 活动图中的基本概念7.2 用户登录活动图7.3活动图练习题8.从C ++代码生成UML？UML统一建模语言 [TOC] 1.软件建模概述 1.1什么是建模 1.2建模原则 1.3软件建模的实现过程 2.UML 2.1 UML一共有10种图 3.用例图 3.1 用例之间的关系——泛化关系 3.2 用例之间的关系——包含关系 3.3 用例之间的关系——扩展关系 4.类图 4.1类的表示法 4.2类之间的关系-泛化关系 4.3 类之间的关系-实现关系 4.4 类之间的关系-依赖关系 4.5 类之间的关系-关联关系 4.6 关联关系的名称 4.7 关联关系的角色 4.8 关联关系的多重性 4.9 类之间的关系关联-聚合 4.10 类之间的关系关联—组合 4.11 类图练习题 5.对象图 6.时序图 6.1 借书时序图 6.2 ATM 用户成功登陆的时序图 6.3 时序图中的基本概念 6.4 时序图练习题 7.活动图 7.1 活动图中的基本概念 7.2 用户登录活动图 7.3活动图练习题 8.从C ++代码生成UML？ 1.软件建模概述 1.1什么是建模 任何事情都要先想清楚了才能做，软件开发更是如此！软件开发过程不可能一上来就开始盲目写代码，写代码之前必须搞清楚下面一些基本问题： 要做什么？ 做成什么样？ 怎么去做？ 1.2建模原则 选择建立什么样的模型对如何发现和解决问题具有重要的影响。正确的模型有助于提高开发者的洞察力。 每个模型可以有多种表达方式. 使用者的身份和使用的原因是评判模型好坏的关键。 最好的模型总是能够切合实际. 模型是现实的简化，必须保证简化过程不会掩盖任何重要的细节。 1.3软件建模的实现过程 软件建模的作用是把源于现实世界的问题转化为计算机可以理解和实现的过程。 软件建模的实现过程是从需求入手, 用模型表达分析设计过程, 最终将模型映射成软件实现. 2.UML （1）UML(United Modeling Language, 统一建模语言): 是一种基于面向对象的可视化建模语言. （2）UML 采用了一组形象化的图形(如类图)符号作为建模语言, 使用这些符号可以形象地描述系统的各个方面. （3）UML 通过建立图形之间的各种关系(如类与类之间的关系)来描述模型. 2.1 UML一共有10种图 类图 ★★★★★ 对象图 ★★★☆☆ 包图 ★☆☆☆☆ 组件图 ★☆☆☆☆ 部署图 ★☆☆☆☆ 用例图 ★★★☆☆ 时序图 ★★★☆☆ 协作图 ★☆☆☆☆ 状态图 ★★☆☆☆ 活动图 ★★☆☆☆ 2.2 UML中的关系 UML中的关系主要包括4种： 关联关系*(association) 依赖关系*(dependency) 泛化关系*(generalization) 实现关系*(realization) 3.用例图 （1）用例图(Use Case Diagram): 也称为用户模型图, 是从软件需求分析到最终实现的第一步, 它是从客户的角度来描述系统功能. （2）用例图包含 3 个基本组件: 参与者(Actor): 与系统打交道的人或其他系统即使用该系统的人或事物. 在 UML 中参与者用人形图标表示 用例(Use Case): 代表系统的某项完整的功能. 在 UML 中使用一个椭圆来表示 关系: 定义用例之间的关系 ------ 泛化关系, 扩展关系, 包含关系 3.1 用例之间的关系——泛化关系 泛化关系: 表示同一业务目的(父用例)的不同技术实现(各个子用例). 在 UML 中, 用例泛化用一个三角箭头从子用例指向父用例. 以下是某购物网站为用户提供不同的支付方式 3.2 用例之间的关系——包含关系 一个用例可以包含其他用例具有的行为, 并把它包含的用例行为作为自身行为的一部分. 在 UML 中包含关系用虚线箭头加 “>”, 箭头指向被包含的用例. 3.3 用例之间的关系——扩展关系 如果在完成某个功能的时候偶尔会执行另外一个功能, 则用扩展关系表示.在 UML 中扩展关系用虚线箭头加 “>”, 箭头指向被扩展的用例. 4.类图 类图是面向对象系统建模中最常用的图. 是定义其他图的基础. 类图主要是用来显示系统中的类, 接口以及它们之间的关系. 类图包含的主要元素有类, 接口和关系. 其中关系有泛化关系,关联关系, 依赖关系和实现关系. 在类图中也可以包含注释和约束. 4.1类的表示法 1. 类是类图的主要组件, 由3部分组成: 类名, 属性和方法. 在 UML 中, 类用矩形来表示, 顶端部分存放类的名称, 中间部分存放类的属性, 属性的类型及值, 底部部分存放类的方法, 方法的参数和返回类型. 2.在 UML 中可以根据实际情况有选择的隐藏属性部分或方法部分或两者都隐藏 3.在 UML 中, 共有类型有 + 表示, 私有类型用 – 表示, 保护类型用 # 表示. UML 的工具开发商可以使用自己定义的符号表示不同的可见性 4.2类之间的关系-泛化关系 1. 在 UML 中, 泛化关系用来表示类与类, 接口与接口之间的继承关系. 泛化关系有时也称为”is a kind of“关系. 2. 在 UML 中泛化关系用一条实线空心箭头有子类指向父类. 4.3 类之间的关系-实现关系 在 UML 中, 实现关系用来表示类与接口之间的实现关系. 在 UML 中实现关系用一条虚线空心箭头由子类指向父类 4.4 类之间的关系-依赖关系 对于两个相对独立的系统，当一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务时，这两个系统之间体现为依赖关系. 例如生产零件的机器和零件，机器负责构造零件对象; 充电电池和充电器，充电电池通过充电器来充电;自行车Bicycle和打气筒Pump，自行车通过打气筒来充气。 4.5 类之间的关系-关联关系 对于两个相对独立的系统，当一个系统的实例与另一个系统的一些特定实例存在固定的对应关系时，这两个系统之间为关联关系。例如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单；公司和员工，每个公司对应一些特定的员工，每个员工对应一特定的公司；自行车和主人，每辆自行车属于特定的主人，每个主人有特定的自行车。而充电电池和充电器之间就不存在固定的对应关系，同样自行车和打气筒之间也不存在固定的对应关系。 4.6 关联关系的名称 关联关系的名称: 关联关系可以有一个名称, 用于描述该关系的性质. 此关联名称应该是动词短语, 因为它表明源对象正在目标对象上执行动作. 4.7 关联关系的角色 当一个类处于关联的某一端时, 该类就在这个关系中扮演一个特定的角色. 具体来说, 角色就是关联关系中一个类对另一个类所表现的职责. 角色名称是名词或名称短语. 4.8 关联关系的多重性 关联关系的多重性是指有多少对象可以参与该关联, 多重性可以用来表达一个取值范围, 特定值, 无限定的范围. 4.9 类之间的关系关联-聚合 1. 聚合关系是关联关系的一种，是更强的关联关系。 2. 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成。 3. 聚合关系也是通过成员变量来实现的。但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同的层次上，一个代表整体，一个代表部分。 4.10 类之间的关系关联—组合 1. UML类图关系中合成关系是关联关系的一种，是比聚合关系还要强的关系。 2. 代表整体的对象负责代表部分对象的生命周期。 4.11 类图练习题 4.11.1 类图练习题一 根据以下网友描述出艺人之间关系的”类： 4.11.2 类图练习题二 汽车和自行车都是交通工具(vehicle). 一辆自行车(bicycle)只归一个人(person)所有, 但一辆汽车(auto)可归一个人或两个人所有. 一个人可能没有自行车或汽车, 也可能有多辆自行车或汽车. 人分为男人(male)和女人(female). 每个人都有年龄(age)和名字(name). 每辆交通工具都有自己的颜色(color)和商标(brand). 每辆汽车都只有两个前灯(headlight)和一台发动机(motor)。 5.对象图 1. 对象图是类图的一个实例, 用于显示系统执行时的一个可能的快照. 即在某一个时间上系统可能出现的样子. 对象图用带下划线的对象名称来表示对象. 2. 表现对象的特征 3. 对象图展现了多个对象的特征及对象之间的交互 6.时序图 1. 时序图用于描述对象之间的传递消息的时间顺序, 即用例中的行为顺序. 2. 当执行一个用例时, 时序图中的每条消息对应了一个类操作或者引起转换的触发事件. 3. 在 UML 中, 时序图表示为一个二维的关系图, 其中, 纵轴是时间轴, 时间延竖线向下延伸. 横轴代表在协作中各个独立的对象. 当对象存在时, 生命线用一条虚线表示, 消息用从一个对象的生命线到另一个对象的生命线的箭头表示. 箭头以时间的顺序在图中上下排列. 6.1 借书时序图 6.2 ATM 用户成功登陆的时序图 6.3 时序图中的基本概念 对象: 时序图中对象使用矩形表示, 并且对象名称下有下划线. 将对象置于时序图的顶部说明在交互开始时对象就已经存在了. 如果对象的位置不在顶部, 表示对象是在交互的过程中被创建的. 生命线: 生命线是一条垂直的虚线. 表示时序图中的对象在一段生命周期内的存在. 每个对象底部中心的位置都带有生命线. 消息: 两个对象之间的单路通信. 从发送方指向接收方. 在时序图中很少使用返回消息. 激活: 时序图可以描述对象的激活和钝化. 激活表示该对象被占用已完成某个任务. 钝化指对象处于空闲状态, 等待消息. 在 UML 中, 对象的激活时将对象的生命线拓宽为矩形来表示的. 矩形称为计划条或控制期. 对象就是在激活条的顶部被激活的. 对象在完成自己的工作后被钝化. 对象的创建和销毁: 在时序图中, 对象的默认位置是在图的顶部. 这说明对象在交互开始之前就已经存在了. 如果对象是在交互过程中创建的, 那么就应该将对象放到中间部分. 如果要撤销一个对象, 在其生命线终止点处放置 “ X” 符号. 6.4 时序图练习题 画出三层架构登录的时序图. 7.活动图 在 UML 中, 活动图本质上就是流程图. 它用于描述系统的活动, 判定点和分支等. 7.1 活动图中的基本概念 动作状态: 原子的,不可中断的动作,并在此动作完成之后向另一个动作转变. 在 UML 中动作状态用圆角矩形表示,动作状态所表示的动作写在圆角矩形内部. 分支与合并: 分支在软件系统中很常见. 一般用于表示对象类所具有的条件行为. 用一个布尔型表达式的真假来判定动作的流向. 条件行为用分支和合并表达.在活动图中, 分支用空心小菱形表示. 分支包括一个入转换和两个带条件的出转换, 出转换的条件应该是互斥的, 须保证只有一条出转换能够被触发. 合并包含两个带条件的入转换和一个出转换. 分叉与汇合: 分叉用来描述并发线程, 每个分叉可以有一个输入转换和两个或多个输出转换. 每个转换都可以是独立的控制流. 汇合代表两个或多个并发控制流同步发生, 当所有的控制流都达到汇合点后, 控制才能继续往下进行. 每个汇合可以有两个或多个输入转换和一个输出转换. 在 UML 中分叉和汇合用一条粗直线表示. 泳道: 泳道将活动图中的活动划分为若干组, 并将每一组指定给负责这组活动的业务组织. 泳道区分负责活动的对象, 明确地表示哪些活动是由哪些对象进行的. 每个活动指定明确地属于一个泳道. 在活动图中, 泳道用垂直实线绘出, 垂直线分隔的区域即为泳道. 7.2 用户登录活动图 7.3活动图练习题 某公司销售人员接到订单后, 将订单传给财务人员和仓库人员. 财务人员开具发票, 并收款. 仓库人员准备货物, 并查看是否货物加急, 若是加急采用 EMS 方式发货, 否则采用普通包裹方式发货. 完成之后由销售人员关闭该订单. 根据上面描述画出该公司销售过程的活动图. 8.从C ++代码生成UML？ Microsoft Visio 使用Microsoft Visio 2000将工程代码逆向转换为UML图的分步指南 - http://msdn.microsoft.com/zh-cn/library/aa140255(office.10).aspx https://www.zhihu.com/question/31687711 BoUML - http://bouml.fr/features.html StarUML - http://staruml.sourceforge.net/en/ https://www.fanjiafei.cn/2018/03/30/%E6%A0%B9%E6%8D%AE%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90uml%E7%B1%BB%E5%9B%BE/ 在弱类型容器的情况下从C ++代码逆向工程UML类图（2001） - http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.9064 Umbrello UML建模器 - http://uml.sourceforge.net/ 其他工具清单 - http://plg.uwaterloo.ca/\\~migod/uml.html 如何用Rational Rose进行C++代码分析 https://www.ibm.com/developerworks/cn/rational/r-shenzj/index.html 使用PlantUML绘制类图 https://blog.csdn.net/flueky/article/details/84819154 https://blog.csdn.net/ZK295794411/article/details/102974779 http://www.umlchina.com/Tools/Newindex1.htm "},"design-pattern/design-pattern.html":{"url":"design-pattern/design-pattern.html","title":"设计模式","keywords":"","body":"设计模式1.设计模式概述1.1 设计模式从何而来1.2 软件设计模式又从何而来1.3 软件设计模式的种类1.4 软件设计模式有什么用？1.5 设计模式总览表2.面向对象设计原则2.0 面向对象设计原则2.1 开闭原则案例2.2 迪米特法则案例2.3 合成复用原则案例2.4 依赖倒转原则案例3.创建型模型3.1 简单工厂模式3.2 工厂方法模式3.3 抽象工厂模式3.4 单例模式4.结构型模式4.1 代理模式4.2 装饰模式4.3 外观模式4.4 适配器模式5.行为型模式5.1 模板方法模式5.2 命令模式5.3 策略模式5.4 观察者模式设计模式 [TOC] 1.设计模式概述 1.1 设计模式从何而来 1.2 软件设计模式又从何而来 1.3 软件设计模式的种类 1.4 软件设计模式有什么用？ 1.5 设计模式总览表 2.面向对象设计原则 2.0 面向对象设计原则 2.1 开闭原则案例 2.2 迪米特法则案例 2.3 合成复用原则案例 2.4 依赖倒转原则案例 3.创建型模型 3.1 简单工厂模式 3.2 工厂方法模式 3.3 抽象工厂模式 3.4 单例模式 4.结构型模式 4.1 代理模式 4.2 装饰模式 4.3 外观模式 4.4 适配器模式 5.行为型模式 5.1 模板方法模式 5.2 命令模式 5.3 策略模式 5.4 观察者模式 1.设计模式概述 如果把修习软件开发当做武功修炼的话，那么可以分为招式和内功。 招式： Java、C#、C++等编程语言； ​ Eclipse、Visual Studio等开发工具； ​ JSP、ASP.net等开发技术； ​ Struts、Hibernate、JBPM等框架技术； 内功： 数据结构、算法、设计模式、重构、软件工程 每一位软件开发人员也都希望成为一名兼具淋漓招式和深厚内功的“上乘”软件工程师，而对设计模式的学习与领悟将会让你“内功”大增，再结合你日益纯熟的“招式”，你的软件开发“功力”一定会达到一个新的境界。 招式可以很快学会，但是内功的修炼需要更长的时间。 1.1 设计模式从何而来 Christopher Alexander（克里斯托弗.亚历山大）——哈佛大学建筑学博士、美国加州大学伯克利分校建筑学教授、加州大学伯克利分校环境结构研究所所长、美国艺术和科学院院士。 “每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。” ——《建筑的永恒之道》by Christopher Alexander Christopher Alexander在《建筑的永恒之道》中给出了设计模式的定义，这些话可以总结出一句话那就是：“设计模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。”——（设计模式的定义） 1.2 软件设计模式又从何而来 四人组（Gang of Four），简称GoF Ralph Johnson，Richard Helm，Erich Gamma，John Vlissides GoF将模式的概念引入软件工程领域，这标志着软件模式的诞生。软件模式(Software Patterns)是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式。 软件模式与具体的应用领域无关，也就是说无论你从事的是移动应用开发、桌面应用开发、Web应用开发还是嵌入式软件的开发，都可以使用软件模式。无论你是使用Java、C#、Objective-C、VB.net、Smalltalk等纯面向对象编程语言，还是使用C++、PHP、Delphi、JavaScript等可支持面向对象编程的语言，你都需要了解软件设计模式！ 我们可用一句大白话：“在一定环境下，用固定套路解决问题。” 1.3 软件设计模式的种类 GoF提出的设计模式有23个，包括： 创建型(Creational)模式： 如何创建对象； 结构型(Structural )模式： 如何实现类或对象的组合； 行为型(Behavioral)模式： 类或对象怎样交互以及怎样分配职责。 有一个“简单工厂模式”不属于GoF 23种设计模式，但大部分的设计模式书籍都会对它进行专门的介绍。 设计模式目前种类： GoF的23种 + “简单工厂模式” = 24种。 1.4 软件设计模式有什么用？ 从高端来讲的话，那么作用大了去了，这里我们也体会不到，那么对于初学者来说，学习设计模式将有助于更加深入地理解面向对象思想, 让你知道： 如何将代码分散在几个不同的类中？ 为什么要有“接口”？ 何谓针对抽象编程？ 何时不应该使用继承？ 如果不修改源代码增加新功能？ 更好地阅读和理解现有类库与其他系统中的源代码。 学习设计模式会让你早点脱离面向对象编程的“菜鸟期”。 如何学好设计模式 设计模式的基础是：多态。 初学者： 积累案例， 不要盲目的背类图。 初级开发人员：多思考，多梳理，归纳总结，尊重事物的认知规律，注意临界点的突破，不要浮躁。 中级开发人员：合适的开发环境，寻找合适的设计模式来解决问题。 多应用， 对经典则组合设计模式的大量，自由的运用。要不断的追求。 1.5 设计模式总览表 模式类别 模式名称 作用 创建型模式 Creational Pattern（5+1） 单例模式★★★★☆ 是保证一个类仅有一个实例，并提供一个访问它的全局访问点。 (简单工厂模式)★★★☆☆ 通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 工厂方法模式★★★★★ 定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 抽象工厂模式★★★★★ 提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。 原型模式★★★☆☆ 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 建造者模式★★☆☆☆ 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 模式类别 模式名称 作用 结构型模式Structural Pattern（7） 适配器模式★★★★☆ 将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式★★★☆☆ 将抽象部分与实际部分分离，使它们都可以独立的变化。 组合模式★★☆☆☆ 将对象组合成树形结构以表示“部分--整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。 装饰模式★★★☆☆ 动态的给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更为灵活。 外观模式★★★★★ 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式★☆☆☆☆ 以共享的方式高效的支持大量的细粒度的对象。 代理模式★★★★☆ 为其他对象提供一种代理以控制对这个对象的访问。 模式类别 模式名称 作用 行为型模式Behavioral Pattern（11） 职责链模式★★☆☆☆ 在该模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 命令模式★★★★☆ 将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 解释器模式★☆☆☆☆ 如何为简单的语言定义一个语法，如何在该语言中表示一个句子，以及如何解释这些句子。 迭代器模式★☆☆☆☆ 提供了一种方法顺序来访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 中介者模式★★☆☆☆ 定义一个中介对象来封装系列对象之间的交互。终结者使各个对象不需要显示的相互调用 ，从而使其耦合性松散，而且可以独立的改变他们之间的交互。 备忘录模式★★☆☆☆ 是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 观察者模式★★★★★ 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 状态模式★★☆☆☆ 对象的行为，依赖于它所处的状态。 策略模式★★★★☆ 准备一组算法，并将每一个算法封装起来，使得它们可以互换。 模板方法模式★★★☆☆ 得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 访问者模式★☆☆☆☆ 表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 2.面向对象设计原则 对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。 原则的目的： 高内聚，低耦合 2.0 面向对象设计原则 设计原则 单一职责原则 开闭原则 里氏代换原则 依赖倒转原则 接口隔离原则 合成复用原则 迪米特法则(最少知识) 名称 定义 单一职责原则(Single Responsibility Principle, SRP) 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。 开闭原则(Open-Closed Principle, OCP) 类的改动是通过增加代码进行的，而不是修改源代码。 里氏代换原则(Liskov Substitution Principle, LSP) 任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。 依赖倒转原则(Dependence Inversion Principle, DIP) 依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程。 接口隔离原则(Interface Segregation Principle, ISP) 不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。 合成复用原则(Composite Reuse Principle, CRP) 如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。 迪米特法则(Law of Demeter, LoD)(最少知识) 一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理） 2.1 开闭原则案例 2.2 迪米特法则案例 2.3 合成复用原则案例 2.4 依赖倒转原则案例 传统的设计模式通常是自顶向下逐级依赖，这样，底层模块，中间层模块和高层模块的耦合度极高，若任意修改其中的一个，很容易导致全面积的修改，非常麻烦，那么依赖倒转原则利用多态的先天特性，对中间抽象层进行依赖，这样，底层和高层之间进行了解耦合。 3.创建型模型 3.1 简单工厂模式 简单工厂模式并不属于GoF的23种设计模式。 那么为什么我要用工厂模式呢？请看下面的一段程序。 //水果类 class Fruit{ public: Fruit(string name){ m_name = name; } void showFruitName(){ if (m_name.compare(\"apple\") == 0){ cout 不难看出，Fruit类是一个“巨大的”类，在该类的设计中存在如下几个问题： (1) 在Fruit类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。 (2) Fruit类的职责过重，它负责初始化和显示所有的水果对象，将各种水果对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护； (3) 当需要增加新类型的水果时，必须修改Fruit类的源代码，违反了“开闭原则”。 3.1.1 简单工厂模式中的角色和职责 工厂（Factory）角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品（AbstractProduct）角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品（Concrete Product）角色：简单工厂模式所创建的具体实例对象。 3.1.2 简单工厂模式案例 3.1.3 简单工厂模式的优缺点 优点： 实现了对象创建和使用的分离。 不需要记住具体类名，记住参数即可，减少使用者记忆量。 缺点： 对工厂类职责过重，一旦不能工作，系统受到影响。 增加系统中类的个数，复杂度和理解度增加。 违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂。 3.1.4 适用场景 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 3.2 工厂方法模式 工厂方法(Factory Method)模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 工厂方法模式是简单工厂模式的衍生，解决了许多简单工厂模式的问题。首先完全实现‘开－闭 原则’，实现了可扩展。 3.2.1 工厂方法模式中的角色与职责 抽象工厂（Abstract Factory）角色：工厂方法模式的核心，任何工厂类都必须实现这个接口。 具体工厂（Concrete Factory）角色：具体工厂类是抽象工厂的一个实现，负责实例化产品对象。 抽象产品（Abstract Product）角色：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品（Concrete Product）角色：工厂方法模式所创建的具体实例对象。 简单工厂模式 + “开闭原则” = 工厂方法模式 3.2.2 工厂方法模式案例 3.1.3 工厂方法模式的优缺点 优点： 不需要记住具体类名，甚至连具体参数都不用记忆。 实现了对象创建和使用的分离。 系统的可扩展性也就变得非常好，无需修改接口和原类。 缺点： 增加系统中类的个数，复杂度和理解度增加。 增加了系统的抽象性和理解难度。 3.1.4 适用场景 客户端不知道它所需要的对象的类。 抽象工厂类通过其子类来指定创建哪个对象。 3.3 抽象工厂模式 工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。 1.当我们想添加一个新产品的时候，比如葡萄，虽然不用修改代码，但是我们需要添加大量的类，而且还需要添加相对的工厂。（系统开销，维护成本） 2.如果我们使用同一地域的水果（日本，日本，日本），那么我们需要分别创建具体的工厂，如果选择出现失误，将会造成混乱，虽然可以加一些约束，但是代码实现变得复杂。 3.3.1 模式中的角色和职责 {width=\"6.125in\" height=\"4.645833333333333in\"} 抽象工厂（Abstract Factory）角色：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 具体工厂（Concrete Factory）角色：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 抽象产品（Abstract Product）角色：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 具体产品（Concrete Product）角色：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 3.3.2 抽象工厂模式案例 3.3.3 抽象工厂模式的优缺点 优点： 拥有工厂方法模式的优点 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点： 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。 3.3.4 适用场景 系统中有多于一个的产品族。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。 产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 3.3.5 抽象工厂模式练习题 设计一个电脑主板架构，电脑包括（显卡，内存，CPU）3个固定的插口，显卡具有显示功能（display，功能实现只要打印出意义即可）， 内存具有存储功能（storage），cpu具有计算功能（calculate）。 现有Intel厂商，nvidia厂商，Kingston厂商，均会生产以上三种硬件。要求组装两台电脑： 1台（Intel的CPU，Intel的显卡，Intel的内存） 1台（Intel的CPU， nvidia的显卡，Kingston的内存） 用抽象工厂模式实现。 3.4 单例模式 单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。 3.4.1 单例模式中的角色和职责 Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。 如何构建单例: 单例模式的类只提供私有的构造函数， 类定义中含有一个该类的静态私有对象， 该类提供了一个静态的公有的方法用于创建或获取它本身的静态私有对象。 /* 懒汉式 */ //懒汉式,线程不安全 /*饿汉式*/ //饿汉式,线程安全 3.4.2 单例碰到多线程 // 饿汉式单例碰到多线程测试 // 懒汉式单例碰到多线程 练习：用单例模式，模拟公司员工使用打印机场景，打印机可以打印员工要输出的内容，并且可以累积打印机使用次数 思考：当单例模式中的懒汉模式遇见多线程，改怎么办？ 3.4.3 单例模式的优缺点 优点: 单例模式提供了对唯一实例的受控访问。 节约系统资源。由于在系统内存中只存在一个对象。 缺点: 扩展略难。单例模式中没有抽象层。 单例类的职责过重。 3.4.4 适用场景 (1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。 (2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 4.结构型模式 让类和类进行组合，获得更大的结构。 4.1 代理模式 代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 4.1.1模式中的角色和职责 subject（抽象主题角色）：真实主题与代理主题的共同接口。 RealSubject（真实主题角色）：定义了代理角色所代表的真实对象。 Proxy（代理主题角色）：含有对真实主题角色的引用，代理角色通常在将客户端调用传递给真是主题对象之前或者之后执行某些操作，而不是单纯返回真实的对象。 4.1.2 代理模式的案例 4.1.3代理模式的优缺点 优点： 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。 缺点: 代理实现较为复杂。 4.1.4 适用场景 为其他对象提供一种代理以控制对这个对象的访问。 4.1.5 代理模式练习题 1 定义真实玩家(李逍遥) 2 定义代理玩家 3 代理玩家代替李逍遥打怪升级 4.2 装饰模式 装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。 装饰模式就是把要附加的功能分别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择的、按顺序的使用装饰功能包装对象。 4.2.1装饰模式中的角色和职责 Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。 Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 4.2.2装饰模式案例 4.2.3装饰模式的优缺点 优点： 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。 可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。 可以对一个对象进行多次装饰。 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。 缺点： 使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。 4.2.4 适用场景 动态、透明的方式给单个对象添加职责。 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。 4.3 外观模式 根据迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。 Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。 4.3.1外观模式中角色和职责 Façade(外观角色)：为调用方, 定义简单的调用接口。 SubSystem(子系统角色)：功能提供者。指提供功能的类群（模块或子系统） 。 4.3.2外观模式案例 根据类图，实现家庭影院外观模式应用。 实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，dvd打开； 实现游戏模式：电视打开，音响打开，游戏机打开。 4.3.3外观模式的优缺点 优点： 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。 一个子系统的修改对其他子系统没有任何影响。 缺点： 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 4.3.4适用场景 复杂系统需要简单入口使用。 客户端程序与多个子系统之间存在很大的依赖性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。 4.4 适配器模式 ​ 5V 适配器 220V 将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 4.4.1 适配器模式中的角色和职责 Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 根据对象适配器模式结构图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的specificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者specificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。 4.4.2适配器模式的案例 4.4.3适配器模式优缺点 优点： 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 灵活性和扩展性都非常好，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 缺点: 适配器中置换适配者类的某些方法比较麻烦。 4.4.4适应场景 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 5.行为型模式 用来对类或对象怎样交互和怎样分配职责进行描述。 5.1 模板方法模式 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 5.1.1 模板方法模式中的角色和职责 AbstractClass（抽象类）：在抽象类中定义了一系列基本操作，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。 ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。 5.1.2 模板方法模式的案例 5.1.3 模板方法的优缺点 优点： 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。 缺点： 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。 5.1.4 适用场景 具有统一的操作步骤或操作过程; 具有不同的操作细节; 存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却各不相同; 在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以把各个具体的子类和操作步骤解耦合。 5.2 命令模式 将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。 5.2.1 命令模式中的角色和职责 Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。 ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。 Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。 Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。 5.2.2 命令模式的案例 5.2.3 命令模式练习题 联想路边撸串烧烤场景， 有烤羊肉，烧鸡翅命令，有烤串师傅，和服务员MM。根据命令模式，设计烤串场景。 5.2.4 命令模式的优缺点 优点： 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 可以比较容易地设计一个命令队列或宏命令（组合命令）。 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。 5.2.5 适用场景 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。 系统需要将一组操作组合在一起形成宏命令。 5.3 策略模式 策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 5.3.1 策略模式中的角色和职责 Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。 Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。 ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。 5.3.2 策略模式案例 5.3.3 策略模式练习题 商场促销有策略A（0.8折） 策略B（消费满200，返现100），用策略模式模拟场景。 5.3.4 策略模式的优缺点 优点： 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。 策略模式提供了一种算法的复用机制。由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。 5.3.5 适用场景 准备一组算法，并将每一个算法封装起来，使得它们可以互换。 5.4 观察者模式 随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。 观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。 5.4.1 观察者模式中的角色和职责 Subject（被观察者或目标，抽象主题）：被观察的对象。当需要被观察的状态发生变化时，需要通知队列中所有观察者对象。Subject需要维持（添加，删除，通知）一个观察者对象的队列列表。 ConcreteSubject（具体被观察者或目标，具体主题）：被观察者的具体实现。包含一些基本的属性状态及其他操作。 Observer（观察者）：接口或抽象类。当Subject的状态发生变化时，Observer对象将通过一个callback函数得到通知。 ConcreteObserver（具体观察者）：观察者的具体实现。得到通知后将完成一些具体的业务逻辑处理。 5.4.2 观察者模式案例 5.4.3 观察者模式练习题 江湖中有多个帮派，还有一名无人不知，无事不晓的百晓生。当江湖中发生武林打斗事件，百晓生作为天生的大嘴巴会广播武林消息，每个帮派的门第对于事件的处理方式均不同，同帮派被欺负，要报仇，同帮派欺负别人，叫好。用观察者模式模拟场景。 5.4.4 观察者模式的优缺点 优点： 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 缺点： 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 5.4.5 适用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 "},"shell/":{"url":"shell/","title":"shell编程","keywords":"","body":"shell 编程shell 编程 shell简介 配置shell 系统可用的shell 查看系统当前shell 查看系统用户shell 切换shell为zsh 配置dash让bash为默认shell 修改用户登录 Shell shell脚本 编写规范 执行脚本 shell变量 环境变量/本地变量 删除变量unset 只读变量readonly 接收用户输入read 通配符 命令代换`` $() 算术代换 $(()) $[ ] 转义字符 \\ 单引号 双引号 位置参数和特殊符号 运算符 算数运算符 字符串运算符 关系运算符 逻辑运算符 && || 语句选择 文件测试运算符 输入输出 echo 管道 | tee 文件重定向 分支 if/then/elif/else/fi case/esac 循环 for/do/done while/do/done break和continue 函数 函数定义 Shell 传递参数 Shell脚本调试方法 "},"shell/shell.html":{"url":"shell/shell.html","title":"shell基础","keywords":"","body":"Shell 编程shell简介配置shell系统可用的shell查看系统当前shell查看系统用户shell切换shell为zsh配置dash让bash为默认shell修改用户登录 Shellshell脚本编写规范执行脚本shell变量环境变量/本地变量删除变量unset只读变量readonly接收用户输入read通配符命令代换`` $()算术代换 $(()) $[ ]转义字符 \\单引号双引号位置参数和特殊符号运算符算数运算符字符串运算符关系运算符逻辑运算符&& || 语句选择文件测试运算符输入输出echo管道 |tee文件重定向分支if/then/elif/else/ficase/esac循环for/do/donewhile/do/donebreak和continue函数函数定义Shell 传递参数Shell脚本调试方法Shell 编程 [TOC] shell简介 配置shell 系统可用的shell 查看系统当前shell 查看系统用户shell 切换shell为zsh 配置dash让bash为默认shell 修改用户登录 Shell shell脚本 编写规范 执行脚本 shell变量 环境变量/本地变量 删除变量unset 只读变量readonly 接收用户输入read 通配符 命令代换`` $() 算术代换 $(()) $[ ] 转义字符 \\ 单引号 双引号 位置参数和特殊符号 运算符 算数运算符 字符串运算符 关系运算符 逻辑运算符 && || 语句选择 文件测试运算符 输入输出 echo 管道 | tee 文件重定向 分支 if/then/elif/else/fi case/esac 循环 for/do/done while/do/done break和continue 函数 函数定义 Shell 传递参数 Shell脚本调试方法 shell简介 Shell的作用是解释执行用户的命令，用户输入一条命令，Shell就解释执行一条，这种方式称为交互式（Interactive），Shell还有一种执行命令的方式称为批处理（Batch），用户事先写一个Shell脚本（Script），其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。 什么是shell？ Shell（外壳） 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 什么是脚本？ 脚本简单地说就是一条条的文字命令，这些文字命令是可以看到的（如可以用记事本打开查看、编辑）。 常见的脚本： JavaScript（JS，前端）， ASP，JSP，PHP（后端），SQL（数据库操作语言），Perl，Shell，python，Ruby，JavaFX，Lua等。 为什么要学习和使用shell？ Shell属于内置的脚本 程序开发的效率非常高，依赖于功能强大的命令可以迅速地完成开发任务（批处理） 语法简单，代码写起来比较轻松，简单易学 常见的shell种类？ 在linux中有很多类型的shell，不同的shell具备不同的功能，shell还决定了脚本中函数的语法，Linux中默认的shell是/bin/bash（重点），流行的shell有ash、bash、ksh、csh、zsh等，不同的shell都有自己的特点以及用途。由于历史原因，UNIX系统上有很多种Shell： sh（Bourne Shell）：由Steve Bourne开发，各种UNIX系统都配有sh。 csh（C Shell）：由Bill Joy开发，随BSD UNIX发布，它的流程控制语句很像C语言，支持很多Bourne Shell所不支持的功能：作业控制，命令历史，命令行编辑。 ksh（Korn Shell）：由David Korn开发，向后兼容sh的功能，并且添加了csh引入的新功能，是目前很多UNIX系统标准配置的Shell，在这些系统上/bin/sh往往是指向/bin/ksh的符号链接。 tcsh（TENEX C Shell）：是csh的增强版本，引入了命令补全等功能，在FreeBSD、MacOS X等系统上替代了csh。 bash（Bourne Again Shell）：由GNU开发的Shell，主要目标是与POSIX标准保持一致，同时兼顾对sh的兼容，bash从csh和ksh借鉴了很多功能，大多数Linux系统默认使用的shell，在Linux系统上/bin/sh往往是指向/bin/bash的符号链接。虽然如此，bash和sh还是有很多不同的，一方面，bash扩展了一些命令和参数，另一方面，bash并不完全和sh兼容，有些行为并不一致，所以bash需要模拟sh的行为：当我们通过sh这个程序名启动bash时，bash可以假装自己是sh，不认扩展的命令，并且行为与sh保持一致。 dash zsh 内建命令 用户在命令行输入命令后，一般情况下Shell会fork并exec该命令，但是Shell的内建命令例外，执行内建命令相当于调用Shell进程中的一个函数，并不创建新的进程。以前学过的cd、alias、umask、exit等命令即是内建命令，凡是用which命令查不到程序文件所在位置的命令都是内建命令，内建命令没有单独的man手册，要在man手册中查看内建命令，应该执行 man bash-builtins # 查看内建命令 bash defines the following built-in commands: : , . , [ , alias, bg, bind, break, builtin, case, cd, command, compgen, complete, continue, declare, dirs, disown, echo, enable, eval, exec, exit, export, fc, fg, getopts, hash, help, history, if, jobs, kill, let, local, logout, popd, printf, pushd, pwd, read, readonly, return, set, shift, shopt, source, suspend, test, times, trap, type, typeset, ulimit, umask, unalias, unset, until, wait, while. 如export、shift、if、eval、[、for、while等等。内建命令虽然不创建新的进程，但也会有Exit Status，通常也用0表示成功非零表示失败，虽然内建命令不创建新的进程，但执行结束后也会有一个状态码，也可以用特殊变量$?读出。 配置shell 系统可用的shell cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/dash /bin/bash /bin/rbash 查看系统当前shell echo $SHELL # 當前shell # /bin/bash ls -l /bin/sh # lrwxrwxrwx 1 root root 4 Jan 2 12:55 /bin/sh -> dash 查看系统用户shell cat /etc/passwd 其中最后一列显示了用户对应的shell类型 root:x :0:0:root:/root:/bin/bash daemon:x :1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x :2:2:bin:/bin:/usr/sbin/nologin sys:x :3:3:sys:/dev:/usr/sbin/nologin chao:x :1000:1000::/home/chao:/bin/bash mongodb:x :119:127::/var/lib/mongodb:/bin/false 切换shell为zsh chsh -s /bin/zsh # 切換zsh chsh -s /bin/bash # 切換回bash -s , --shell SHELL new login shell for the user account 配置dash让bash为默认shell sudo dpkg-reconfigure dash # 选择 取消默认配置dash，自动配置为bash # lrwxrwxrwx 1 root root 4 May 17 21:59 /bin/sh -> bash bash ： Bourne Again Shell 修改用户登录 Shell sudo usermod -s /bin/bash 用户名 # 修改用户登录 Shell -s , --shell SHELL new login shell for the user account shell脚本 编写规范 代码规范： ==#!/bin/bash== # 首行#!(Shebang)指定执行当前脚本要使用的shell解释器 Shell相关指令 #表示注释 文件命名规范： 文件名==.sh== # .sh是linux下bash shell 的默认后缀,可以不是sh 执行脚本 使用流程 创建 xx.sh 文件 添加可执行权限, ./ 可执行的shell脚本必须得有可执行权限 chmod +x test.sh ./运行shell脚本 ./test.sh 创建 xx.sh 文件 ``#! /bin/sh cd .. ls 添加可执行权限, ./ 可执行的shell脚本必须得有可执行权限 $ chmod a+x test.sh ./ 运行shell脚本（fork出子Shell执行） $ ./test.sh # ./ shell脚本必须得有可执行权限,fork子进程 Shell会fork一个子进程并调用exec执行./test.sh这个程序，exec系统调用应该把子进程的代码段替换成./test.sh程序的代码段，并从它的_start开始执行。然而test.sh是个文本文件，根本没有代码段和_start函数，怎么办呢？其实exec还有另外一种机制，如果要执行的是一个文本文件，并且第一行用Shebang指定了解释器，则用解释器程序的代码段替换当前进程，并且从解释器的_start开始执行，而这个.sh文本文件被当作命令行参数传给解释器。因此，执行上述脚本相当于执行程序。 $ /bin/sh ./test.sh # 不需要shell脚本具有可执行权限,fork子shell进程 以这种方式执行不需要test.sh文件具有可执行权限。Shell会fork一个子进程并调用exec执行test.sh这个程序。 如果将命令行下输入的命令用括号()括起来，那么也会fork出一个子Shell执行小括号中的命令，一行中可以输入由分号;隔开的多个命令，比如： $ (cd .. ; ls -l) # fork一个子Shell执行 # drwxr-xr-x 50 chao chao 4096 Mar 21 10:04 chao # chao@deepin:~$ 和上面两种方法执行Shell脚本的效果是相同的，cd ..命令改变的是子Shell的pwd，而不会影响到交互式Shell。 然而不加()括号命令直接在当前交互式Shell下执行的，不会创建子Shell $ cd .. ; ls -l # 不会创建子Shell，当前shell执行 # drwxr-xr-x 50 chao chao 4096 Mar 21 10:04 chao # chao@deepin:/home$ 则有不同的效果，cd ..命令是直接在当前交互式Shell下执行的，改变当前交互式Shell的pwd，然而这种方式相当于这样执行Shell脚本： $ source test.sh # 不会创建子Shell，当前shell执行 $ source ./test.sh # 不会创建子Shell，当前shell执行 $ . test.sh # 不会创建子Shell，当前shell执行 $ . ./test.sh # 不会创建子Shell，当前shell执行 ==source==或者==.==命令是Shell的内建命令，这种方式也==不会创建子Shell==，而是直接在当前交互式Shell下逐行执行脚本中的命令。 shell变量 环境变量/本地变量 有两种类型的Shell变量： 环境变量 环境变量是任何进程都有的概念，环境变量可以从父进程传给子进程，因此Shell进程的环境变量可以从当前Shell进程传给fork出来的子进程。用printenv命令可以显示当前Shell进程的环境变量。 $ env # 环境变量 $ printenv # 环境变量 本地变量 只存在于当前Shell进程，用set命令可以显示当前Shell进程中定义的所有变量（包括本地变量和环境变量）和函数。 $ set # 所有变量（包括本地变量和环境变量）和函数 环境变量是任何进程都有的概念，而本地变量是Shell特有的概念。在Shell中，环境变量和本地变量的定义和用法相似。在Shell中定义或赋值一个变量： # 变量名=\"变量值\" # 定义本地变量 $ VARNAME=value # 定义本地变量 # echo $变量名 # 使用变量: $变量名 $ echo $VARNAME # 使用变量: $变量名 定义变量：class_name=====\"yunwe \" 使用变量：echo ==$==class_name 注意等号两边都不能有空格，否则会被Shell解释成命令和命令行参数。 一个变量定义后仅存在于当前Shell进程，它是本地变量，用==export==命令可以把本地变量导出为==环境变量==，定义和导出环境变量通常可以一步完成： $ export VARNAME=value # 把本地变量导出为环境变量 也可以分两步完成： $ VARNAME=value # 定义本地变量 $ export VARNAME # 把本地变量导出为环境变量 示例 #!/bin/bash mystr=\"hello world!\" echo $mystr dt=`date + '%F %T'` echo dt 变量名规范：Shell变量通常由字母加下划线开头，由任意长度的字母、数字、下划线组成。 定义变量时等号=====两边不能有空格 在使用shell变量的时候一定要在变量名前面添加一个==$==符号 关于单双引号的问题： 双引号能够识别变量，双引号能够实现转义（类似于“\\”） 单引号是不能识别变量，只会原样输出，单引号是不能转义的 注意：反引号==` ==（esc键下方的那个键），当在脚本中需要执行一些指令并且将执行的结果赋给变量的时候需要使用“反引号”。 注意，和C语言不同的是，Shell变量不需要明确定义类型，事实上Shell变量的值都是==字符串==，比如我们定义VAR=45，其实VAR的值是字符串45而非整数。Shell变量不需要先定义后使用，如果对一个没有定义的变量取值，则值为空字符串。 $ echo $? # $?上一个进程退出的返回值 删除变量unset unset命令可以删除已定义的环境变量或本地变量。 unset 变量名 $ unset VARNAME # 删除已定义的变量 #!/bin/bash b=20 echo $b unset b # 删除变量 echo $b 只读变量readonly readonly 变量名 # 定义只读变量 #!/bin/bash a=10 readonly a a=20 # 报错无法修改只读数据 echo $a 接收用户输入read 接受用户的输入并赋值给创建的变量 read -p '提示信息' 变量名valName #!/bin/bash read -p '请输入文件名' filepath # 输入值给 filepath touch $filepath echo '文件创建成功' 通配符 这些用于匹配的字符称为通配符（Wildcard），如：* ? [ ] 具体如下： * 匹配0个或多个任意字符(不同正则) ? 匹配一个任意字符(同正则) [若干字符] 匹配方括号中任意一个字符的一次出现(同正则) $ ls /dev/ttyS* $ ls ch0?.doc $ ls ch0[0-2].doc $ ls ch[012][0-9].txt 注意，Globbing所匹配的文件名是由Shell展开的，也就是说在参数还没传给程序之前已经展开了，比如上述ls ch0[012].txt命令，如果当前目录下有ch00.txt和ch02.txt，则传给ls命令的参数实际上是这两个文件名，而不是一个匹配字符串。 命令代换`` $() 由`反引号括起来的也是一条命令，Shell先执行该命令，然后将输出结果立刻代换到当前命令行中。例如定义一个变量存放date命令的输出： $ DATE=`date` # 命令 $ echo $DATE # 输出日期 命令代换也可以用$()表示： $ DATE=$(date) # 命令 $ echo $DATE # 输出日期 算术代换 $(()) $[ ] 使用$(())，用于算术计算，(())中的Shell变量取值将转换成整数，同样含义的$[ ]等价例如： $ VAR=45 $ echo $(($VAR+3)) # 等价于 $ echo $[VAR+3] # 等价于 $ echo $[$VAR+3] # 等价于 $(())中只能用+-/和()运算符，并且只能做整数运算。 $[base#n]，其中base表示*进制，n按照base进制解释，后面再有运算数，按十进制解释。 echo $[2#10+11] # 2进制 echo $[8#10+11] # 8进制 echo $[16#10+11] # 16进制 转义字符 \\ 和C语言类似，\\在Shell中被用作转义字符，用于去除紧跟其后的单个字符的特殊意义（回车除外），换句话说，紧跟其后的字符取字面值。例如： $ echo $SHELL /bin/bash $ echo \\$SHELL # \\$ 转义$ # $SHELL $ echo \\\\ # \\\\ 转义\\ # \\ 比如创建一个文件名为“$ $.txt”的文件（$间含有空格）可以这样： $ touch \\$\\ \\$.txt # 转义$和空格 还有一个字符虽然不具有特殊含义，但是要用它做文件名也很麻烦，就是-号。如果要创建一个文件名以-号开头的文件，加上\\-转义也还是是不正确的. 因为各种UNIX命令都把-号开头的命令行参数当作命令的选项，而不会当作文件名。如果非要处理以-号开头的文件名，可以有两种办法： $ touch ./-hello # 或者 $ touch -- -hello \\还有一种用法，在\\后敲回车表示续行，Shell并不会立刻执行命令，而是把光标移到下一行，给出一个续行提示符>，等待用户继续输入，最后把所有的续行接到一起当作一个命令执行。例如： chao@deepin:~$ ls \\ # \\后回车表示续行 > -l # 就是 ls -l命令的输出 单引号 和C语言同，Shell脚本中的单引号和双引号一样都是字符串的界定符，而不是字符的界定符。单引号用于保持引号内所有字符串的字面值，即使引号内的\\和回车也不例外，但是字符串中不能出现单引号。如果引号没有配对就输入回车，Shell会给出续行提示符，要求用户把引号配上对。例如： $ echo '$SHELL' SHELL $ echo 'ABC\\（回车） # 引号没有配对 DE'（再按一次回车结束命令） ABC\\ DE 双引号 被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引号的处理方式不同 $ DATE=$(date) # 定义变量 $ echo \"$DATE\" # 输出日期 Wed Dec 18 23:00:55 CST 2019 $ echo '$DATE' # 输出字符的字面值 $DATE 再比如： $ VAR=200 $ echo $VAR # 输出变量值 200 $ echo '$VAR' # 输出字符的字面值 $VAR $ echo \"$VAR\" # 输出字符串变量值 200 位置参数和特殊符号 ==#== 注释 ==;== 暂不输出 ==\\== 续行符 ==:== 空命令，该命令不做任何事，但Exit Status总是真 ==$0== 当前命令,相当于C语言main函数的argv[0] ==$1==、==$2==... 第n个命令行参数，相当于C语言main函数的argv[1]、argv[2]... ==$#== 传递到脚本的参数个数,相当于C语言argc - 1 ==$@== \"$@\"表示参数列表\"$1\" \"$2\" ... \"$n\" ， 可以用在for循环中的in后面 ==$*== \"$*\"表示\"$1 $2 … $n\"，以一个单字符串显示所有向脚本传递的参数 ==$?== 上一条命令的Exit Status退出状态，0表示没有错误，其他任何值表明有错误 ==$-== 显示Shell使用的当前选项，与set命令功能相同。 ==$$== 脚本运行的当前进程号 $! 后台运行的最后一个进程的ID号 位置参数可以用shift命令左移。比如shift 3表示原来的$4现在变成$1，原来的$5现在变成$2等等，原来的$1、$2、$3丢弃，$0不移动。不带参数的shift命令相当于shift 1。例如： #! /bin/sh echo \"The program $0 is now running\" echo \"The first parameter is $1\" echo \"The second parameter is $2\" echo \"The parameter list is $@\" shift # 相当于shift 1 echo \"The first parameter is $1\" echo \"The second parameter is $2\" echo \"The parameter list is $@\" 运算符 在shell中，运算符和其他编程脚本语言一样，常见的有算数运算符、关系运算符、\\逻辑运算符、字符串运算符、文件测试运算符等 算数运算符 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。比较两个数值相等，相同则返回 true（真）。 [ $a == $b ] 返回 false（假）。 != 不相等。比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 expr 和awk，expr 最常用。 expr命令是一款表达式计算工具，使用它能完成表达式的求值操作。 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成2 + 2，这与我们熟悉的大多数编程语言不一样。 #！/bin/bash a=20 b=10 echo 'a+b=' `expr $a + $b` echo 'a-b=' `expr $a - $b` echo 'a*b=' `expr $a \\* $b` # 乘 * 需转义，与通配符*区分 echo 'a/b=' `expr $a / $b` echo 'a%b=' `expr $a % $b` 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 expr 和awk，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')： `#!/bin/bash val=\\expr 2 + 2` echo \"两数之和为 : $val\" 两点注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 #！/bin/bash if [ $a == $b ] then echo 'a等于b' else echo 'a不等于b' fi if [ $a ！= $b ] then echo 'a等于b' else echo 'a不等于b' fi 注意：条件表达式要放在方括号[]之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [$a == $b ]。 字符串运算符 下表列出了常用的字符串运算符，假定变量 a 为 \"abc\"，变量 b 为 \"efg\"： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否不为0，不为0返回 true。 [ -n $a ] 返回 true。 -z zero 零 -n not zero 非零 #！/bin/bash a='qbc' b='def' if [ $a = $b ] # 字符串是否相等 then echo 'true' else echo 'false' fi if [ $a != $b ] # 字符串是否不相等 then echo 'true' else echo 'false' fi 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字 下表列出了常用的数值关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回false。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 -eq：equal -ne：not equal -gt：great than -lt：less than -ge：great than or equal -le：less than or equal #!/bin/bash a=10 b=20 echo \"a = $a\" echo \"b = $b\" if [ $a -eq $b ] # -eq 等于 等价于 == then echo 'a 等于 b' else echo 'a 不等于 b' fi if [ $a -gt $b ] # -gt 大于 then echo 'a 大于 b' else echo 'a 不大于 b' fi 逻辑运算符 下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或(或者)运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与(并且)运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 ！ 非 -o or 或 -a and 与 #！/bin/bash a=10 b=20 if [ $a -lt 20 -o $b -gt 100 ] # -o 或 then echo '真' fi && || 语句选择 ==&&==相当于“if…then…”,只有当前一条语句为真执行成功才执行后一条,失败了则跳过后面的语句 ==||==相当于“if not…then…”,只有当前一条语句为真执行失败才执行后一条,成功了则跳过后面的语句&&和||用于连接两个命令，而上面讲的-a和-o仅用于在测试表达式中连接两个测试条件，和C语言类似，&&和||具有Short-circuit特性 test \"$(whoami)\" != 'root' && (echo you are using a non-privileged account; exit 1) # && 前一句为真才执行后一句,否则跳过后一句 test \"$(whoami)\" != 'root' || (echo you are using a root account; exit 1) # || 前一句为假才执行后一句,否则跳过后一句 &&和||用于连接两个命令，而上面讲的-a和-o仅用于在测试表达式中连接两个测试条件，要注意它们的区别，例如： test \"$VAR\" -gt 12 -a \"$VAR\" -lt 33 和以下写法是等价的 test \"$VAR\" -gt 12 && test \"$VAR\" -lt 33 文件测试运算符 文件测试运算符用于检测 Unix/Linux 文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 ==-d== file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 ==-f== file 检测文件是否是普通文件（既不是目录，也不是设备文件） [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 ==-r== file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 ==-w== file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 ==-x== file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 ==-s== file 检测文件是否非空（文件大小是否大于0），非空返回 true。 [ -s $file ] 返回 true。 ==-e== file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 #!/bin/bash file=\"test.sh\" if [ -f $file ] then echo \"文件为普通文件\" else echo \"文件为特殊文件\" fi if [ -d $file ] then echo \"文件是个目录\" else echo \"文件不是个目录\" fi if [ -s $file ] then echo \"文件不为空\" else echo \"文件为空\" fi if [ -e $file ] then echo \"文件存在\" else echo \"文件不存在\" fi if [ -r $file ] then echo \"文件可读\" else echo \"文件不可读\" fi if [ -w $file ] then echo \"文件可写\" else echo \"文件不可写\" fi if [ -x $file ] then echo \"文件可执行\" else echo \"文件不可执行\" fi 输入输出 echo 显示文本行或变量，或者把字符串输入到文件。 echo [option] string echo \"hello\\n\\n\" echo -e \"hello\\n\\n\" echo \"hello\" echo -n \"hello\" ==-e== 解析转义字符 -n 不回车换行。默认情况echo回显的内容后面跟一个回车换行。 管道 | 可以通过 | 把一个命令的输出传递给另一个命令做输入。 cat myfile | more ls -l | grep \"myfile\" df -k | awk '{print $1}' | grep -v \"Filesystem\" # df -k 查看磁盘空间，找到第一列，去除“Filesystem”，并输出 tee tee命令把结果输出到标准输出，另一个副本输出到相应文件。 df -k | awk '{print $1}' | grep -v \"Filesystem\" | tee a.txt # 输出并写到文件 df -k | awk '{print $1}' | grep -v \"Filesystem\" | tee -a a.txt # 输出并追加到文件 tee -a a.txt表示追加操作。 ==-a== 追加到文件 文件重定向 cmd > file # >把标准输出重定向到新文件中 ls > a.txt cmd >> file # >>追加 ls >> a.txt cmd > file 2>&1 标准出错也重定向到1所指向的file里 cmd >> file 2>&1 追加 cmd file2 输入输出都定向到文件里 cmd &fd 把文件描述符fd作为标准输出 cmd 分支 if/then/elif/else/fi 和C语言类似，在Shell中用if、then、elif、else、fi这几条命令实现分支控制。这种流程控制语句本质上也是由若干条Shell命令组成的 单行写法： if [condition]; then command; fi 多行写法： if [ condition1 ] then command1 elif [ condition2 ] then command2 else commandN fi 示例 if [ -f ~/.bashrc ]; then . ~/.bashrc fi 其实是三条命令，if [ -f ∼/.bashrc ]是第一条，then . ∼/.bashrc是第二条，fi是第三条。如果两条命令写在同一行则需要用;号隔开，一行只写一条命令就不需要写;号了，另外，then后面有换行，但这条命令没写完，Shell会自动续行，把下一行接在then后面当作一条命令处理。和[命令一样，要注意命令和各参数之间必须用空格隔开。if命令的参数组成一条子命令，如果该子命令的Exit Status为0（表示真），则执行then后面的子命令，如果Exit Status非0（表示假），则执行elif、else或者fi后面的子命令。if后面的子命令通常是测试命令，但也可以是其它命令。Shell脚本没有{}括号，所以用fi表示if语句块的结束。 #! /bin/sh if [ -f /bin/bash ] then echo \"/bin/bash is a file\" else echo \"/bin/bash is NOT a file\" fi if :; then echo \"always true\"; fi ==:==是一个特殊的命令，称为空命令，该命令不做任何事，但Exit Status总是真。此外，也可以执行/bin/true或/bin/false得到真或假的Exit Status。再看一个例子： #! /bin/sh echo \"Is it morning? Please answer yes or no.\" read YES_OR_NO if [ \"$YES_OR_NO\" = \"yes\" ]; then echo \"Good morning!\" elif [ \"$YES_OR_NO\" = \"no\" ]; then echo \"Good afternoon!\" else echo \"Sorry, $YES_OR_NO not recognized. Enter yes or no.\" exit 1 fi exit 0 上例中的read命令的作用是等待用户输入一行字符串，将该字符串存到一个Shell变量中。 case/esac case命令可类比C语言的switch/case语句，esac表示case语句块的结束。C语言的case只能匹配整型或字符型常量表达式，而Shell脚本的case可以匹配字符串和Wildcard，每个匹配分支可以有若干条命令，末尾必须以==;;==结束，执行时找到第一个匹配的分支并执行相应的命令，然后直接跳到esac之后，不需要像C语言一样用break跳出。 echo \"Is it morning? Please answer yes or no.\" read YES_OR_NO case \"$YES_OR_NO\" in yes|y|Yes|YES) # 条件1 echo \"Good Morning!\" ;; # 分支必须以;;结束 [nN]*) # 条件2 echo \"Good Afternoon!\" ;; *) # 其他 echo \"Sorry, $YES_OR_NO not recognized. Enter yes or no.\" exit 1 ;; esac exit 0 使用case语句的例子可以在系统服务的脚本目录/etc/init.d中找到。这个目录下的脚本大多具有这种形式（以/etc/init.d/nfs-kernel-server为例）： case \"$1\" in # case xxx in start) # xxx)条件 ... ;; # 分支必须以;;结束， ;; 等价C break stop) ... ;; reload | force-reload) ... ;; restart) ... *) # *)其他条件 log_success_msg\"Usage: nfs-kernel-server \\ {start|stop|status|reload|force-reload|restart}\" exit 1 ;; esac 启动nfs-kernel-server服务的命令是 sudo /etc/init.d/nfs-kernel-server start $1是一个特殊变量，在执行脚本时自动取值为第一个命令行参数，也就是start，所以进入start)分支执行相关的命令。同理，命令行参数指定为stop、reload或restart可以进入其它分支执行停止服务、重新加载配置文件或重新启动服务的相关命令。 循环 for/do/done Shell脚本的for循环结构和C语言很不一样，它类似于某些编程语言的foreach循环。例如： #! /bin/sh for FRUIT in apple banana pear # 循环条件 do echo \"I like $FRUIT\" done FRUIT是一个循环变量，第一次循环$FRUIT的取值是apple，第二次取值是banana，第三次取值是pear。再比如，要将当前目录下的chap0、chap1、chap2等文件名改为chap0~、chap1~、chap2~等（按惯例，末尾有~字符的文件名表示临时文件），这个命令可以这样写： # 批量重命名 for FILENAME in chap? do mv $FILENAME $FILENAME~ done 也可以这样写： $ for FILENAME in `ls chap?`; do mv $FILENAME $FILENAME~; done while/do/done while的用法和C语言类似。比如一个验证密码的脚本： #! /bin/sh echo \"Enter password:\" read TRY while [ \"$TRY\" != \"secret\" ] # 循环条件 do echo \"Sorry, try again\" read TRY done 下面的例子通过算术运算控制循环的次数： #! /bin/sh COUNTER=1 while [ \"$COUNTER\" -lt 10 ] do echo \"Here we go again\" COUNTER=$(($COUNTER+1)) done 另，Shell还有until循环，类似C语言的do…while。 break和continue break跳出循环，continue跳过本次循环。 break[n] # 可以指定跳出n层循环 continue # 跳过本次循环，但不会跳出循环 函数 函数定义 和C语言类似，Shell中也有函数的概念，但是函数定义中没有返回值也没有参数列表。例如： #! /bin/sh myfuc(){ echo \"Function foo is called\";} # 定义函数写一行 echo \"-=start=-\" myfuc # 调用 echo \"-=end=-\" foo(){ echo \"Function foo is called\" } echo \"-=start=-\" foo echo \"-=end=-\" 注意函数体的左花括号 { 和后面的命令之间必须有空格或换行，如果将最后一条命令和右花括号 } 写在同一行，命令末尾必须有分号;。但，不建议将函数定义写至一行上，不利于脚本阅读。 在定义foo()函数时并不执行函数体中的命令，就像定义变量一样，只是给foo这个名一个定义，到后面调用foo函数的时候（注意Shell中的函数调用不写括号）才执行函数体中的命令。Shell脚本中的函数必须先定义后调用，一般把函数定义语句写在脚本的前面，把函数调用和其它命令写在脚本的最后（类似C语言中的main函数，这才是整个脚本实际开始执行命令的地方）。 Shell函数没有参数列表并不表示不能传参数，事实上，函数就像是迷你脚本，调用函数时可以传任意个参数，在函数内同样是用$0、$1、$2等变量来提取参数，函数中的位置参数相当于函数的局部变量，改变这些变量并不会影响函数外面的$0、$1、$2等变量。函数中可以用return命令返回，如果return后面跟一个数字则表示函数的Exit Status。 下面这个脚本可以一次创建多个目录，各目录名通过命令行参数传入，脚本逐个测试各目录是否存在，如果目录不存在，首先打印信息然后试着创建该目录。 #! /bin/sh is_directory() # 定义函数 { DIR_NAME=$1 if [ ! -d $DIR_NAME ]; then return 1 else return 0 fi } for DIR in \"$@\"; do if is_directory \"$DIR\" # 调用函数，参数$1 then : # 文件夹存在，啥也不干 else echo \"$DIR doesn't exist. Creating it now...\" mkdir $DIR > /dev/null 2>&1 # 若mkdir错误信息重定向 if [ $? -ne 0 ]; then # $?上一条命令的Exit Status echo \"Cannot create directory $DIR\" exit 1 fi fi done 注意：is_directory()返回0表示真返回1表示假。 Shell 传递参数 我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数$1，2 为执行脚本的第二个参数$2，以此类推…… 参数处理 说明 $0 当前命令 $1 传递到脚本的第一个参数 $2 传递到脚本的第2个参数 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数。 如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示 上一条命令的退出状态。0表示没有错误，其他任何值表明有错误。 #!/bin/bash echo \"Shell 传递参数实例！\"; echo \"执行的文件名：$0\"; echo \"第一个参数为：$1\"; echo \"第二个参数为：$2\"; echo \"第三个参数为：$3\"; echo \"参数个数为：$#\"; echo \"传递的参数作为一个字符串显示：$*\"; Shell脚本调试方法 Shell提供了一些用于调试脚本的选项，如： -n 读一遍脚本中的命令但不执行，用于检查脚本中的语法错误。 -v 一边执行脚本，一边将执行过的脚本命令打印到标准错误输出。 -x 提供跟踪执行信息，将执行的每一条命令和结果依次打印出来。 这些选项有三种常见的使用方法： 在命令行提供参数。如： $ sh -x ./script.sh # 调试脚本 在脚本开头提供参数。如： #! /bin/sh -x # 调试脚本 ...... 在脚本中用set命令启用或禁用参数。如： #! /bin/sh if [ -z \"$1\" ]; then set -x # 启用调试 echo \"ERROR: Insufficient Args.\" exit 1 set +x # 结束调试 fi set -x和set +x分别表示启用和禁用-x参数，这样可以只对脚本中的某一段进行跟踪调试。 "},"python/":{"url":"python/","title":"Python","keywords":"","body":"PythonPython "},"python/python.html":{"url":"python/python.html","title":"Python基础","keywords":"","body":"UntitledUntitled "},"vim/":{"url":"vim/","title":"vim编辑器","keywords":"","body":"vim 编辑器vim 编辑器 vim 是从 vi 发展出来的一个文本编辑器，支持 代码补全、编译 及 错误跳转 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 编辑器之神，和Emacs并列成为类Unix系统用户最喜欢的编辑器。 vim 的特点： 没有图形界面 的编辑器 只能是编辑 文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 在使用 vi 命令时，注意 关闭中文输入法 vim简介 Vim打开文件 vim 三种模式 命令模式 末行模式 编辑模式 常用命令速查图 vim的配置 "},"vim/vim.html":{"url":"vim/vim.html","title":"vim编辑器","keywords":"","body":"vim 编辑器vim简介Vim打开文件异常退出处理vim 三种模式命令模式1. 光标移动2. 插入文本3. 选中文本4. 复制5. 粘贴6. 剪切/删除7. 查找字符8. 替换字符9. 修改内容10. 撤销/恢复11. 缩进/合并12. 重复上次命令格式化代码查看man13. 书签标记14. 宏末行模式1. 搜索/查找2. *查找当前单词3. 查找并替换4. 文件操作5. :X 加密/解密文件6. 保存退出7. 临时调用外部命令:!8. 行操作9. 分屏命令10. :help帮助命令11. vim配置编辑模式1. 进入编辑模式2. vim代码提示3. vim多行注释代码4. vim中计算器的使用常用命令速查图vim的配置vim 编辑器 [TOC] vim简介 Vim打开文件 异常退出处理 vim 三种模式 命令模式 1. 光标移动 2. 插入文本 3. 选中文本 4. 复制 5. 粘贴 6. 剪切/删除 7. 查找字符 8. 替换字符 9. 修改内容 10. 撤销/恢复 11. 缩进/合并 12. 重复上次命令 格式化代码 查看man 13. 书签标记 14. 宏 末行模式 1. 搜索/查找 2. *查找当前单词 3. 查找并替换 4. 文件操作 5. :X 加密/解密文件 6. 保存退出 7. 临时调用外部命令:! 8. 行操作 9. 分屏命令 10. :help帮助命令 11. vim配置 编辑模式 1. 进入编辑模式 2. vim代码提示 3. vim多行注释代码 4. vim中计算器的使用 常用命令速查图 vim的配置 vim简介 vi 是 Visual interface 的简称，是 Linux 中 最经典 的文本编辑器 vim 即vi improved,是从 vi 发展出来的一个文本编辑器，支持 代码补全、编译 及 错误跳转 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 编辑器之神，和Emacs并列成为类Unix系统用户最喜欢的编辑器。 vim 的特点： 没有图形界面 的编辑器 只能是编辑 文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 在使用 vi 命令时，注意 关闭中文输入法 Vim打开文件 命令 功能 vim 文件路径 打开文件，并且将光标移动到首行，如果文件不存在，则新建 vim 文件的路径 +行号 打开文件，并且将光标移动到指定行号位置 vim 文件的路径 + 打开文件，并且将光标移动到最后一行 vim 文件的路径 +/关键词 打开文件，并且高亮显示搜索关键词 vim 文件的路径 -r 在上次vim编辑时崩溃，恢复编辑 vim 文件路径1 文件路径2 文件路径3 同时打开多个文件，依次编辑 vim password.txt +/login # 高亮显示==login==字符 vim打开文件，如果文件不存在，则会新建一个文件 异常退出处理 什么是异常退出：在编辑文件之后并没有正常的去wq（保存退出），而是遇到突然关闭终端或者断电的情况，则会显示下面的效果，这个情况称之为异常退出 如果 vi 异常退出，在磁盘上会生成隐藏的xxx.swp交换文件（在编程过程中产生的临时文件）,下次再使用 vi 编辑该文件时，会看到以下屏幕信息 解决办法：根据提示按下字母 d 可以 删除交换文件 或者 手动rm .xxx.swp删除隐藏的交换文件即可 rm -f .xxx.swp # 删除隐藏的交换文件 vim 三种模式 vi 有三种基本工作模式： 命令模式 —— 执行定位、翻页、复制、粘贴、删除…… 打开文件后默认进入命令模式，是使用vim的入口 通过命令对文件进行常规的编辑操作，例如：定位、翻页、复制、粘贴、删除…… 末行模式 —— 执行 保存、退出、 搜索、替换、撤销、高亮等操作 要退出 vim 返回到控制台，需要在末行模式下输入命令 末行模式是 vim 的出口 编辑模式 —— 正常的编辑文字 命令模式 实现光标移动，复制，粘贴，删除 1. 光标移动 上、下、左、右 快捷键 功能 手指 h 或 (←) 3h 左移 左移3格 食指 j 或 (↓) 3j 下移 下移3行 食指 k 或 (↑) 3k 上移 上移3行 中指 l 或(→) 3l 右移 右移3格 无名指 Space 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 ==hjkl== 是排列在一行的，因此可以使用这四个按钮来移动光标。 在命令模式下，先输入一个数字，再跟上一个命令，可以让该命令 重复执行指定次数 3h向左移动 3 3j向下移动 3 行 3k 向上移动 3行 3l向右移动 3 行内移动 命令 英文 功能 h 向前移动一个字符 l 向后移动一个字符 ==w== word 向前移动一个单词(在单词==开头==) ==b== back 向后移动一个单词(在单词==开头==) ==e== end 移到当前单词的末尾(==词尾==)，或向后移动一个单词(在单词==末尾==)(与w区别) 0 行首次行开头，不论是否有字符 ^ 行首第一个字符的位置 $ 行尾最后一个字符的位置 3w # 前移 3 个单词 dw # 删除前一个单词 db # 删除后一个单词 行数移动 命令 英文 功能 ==gg== gogo 到文档第一行 ==G== Go 移动到文档最后一行 3- ==3k== 上跳3行 3+ ==3j== 下跳3行(同下) 8 下跳8行(连续跳8个Enter) :行号 跳到指定行号(作用同下) 行号G 跳到指定行号(作用同下) ==行号gg== 123gg 跳到指定行号 :行号11 移动光标到行号为11的行 11gg 移动光标到行号为11的行,最快 查找字符移动 命令 功能 ==f== 向前查找字母 ==F== 向后查找字母 fx 向前查找字符 x 屏幕内移动 命令 英文 功能 H Head 光标移至屏幕顶部 M Middle 光标移至屏幕中间 ==L== Low 光标移至屏幕底部 段落移动 vi 中使用 空行 来区分段落 命令 功能 =={== 上一段(空行分隔) ==}== 下一段(空行分隔) vi 中使用 . 来区分句子 命令 功能 ==(== 上一句子( . 分隔) ==)== 下一句子( . 分隔) 括号间切换 在程序世界中，()、[]、{} 使用频率很高，而且 都是成对出现的 命令 功能 ==%== 光标切换到括号另一半 括号自动匹配高亮()、[]、{} 翻屏 命令 英文 功能 ==Ctrl + u== up 向上翻屏（上半屏） ==Ctrl + d== down 向下翻屏（下半屏） Ctrl + b back 向上翻屏（整屏） Ctrl + f forward 向下翻屏（整屏） 2. 插入文本 i a o I A O 进入编辑模式 命令 英文 功能 ==i== insert 在当前字符前插入文本 ==a== append 在当前字符后追加文本 ==I== 在行首插入文本 ==A== 在行尾追加文本 ==o== over 在当前行下面插入一空行 ==O== 在当前行上面插入一空行 i(insert)插入，a(append)追加，o(over)空行，小写表示下，大写表示上 3. 选中文本 在 vim 中要选择文本，需要先使用Visual命令切换到 可视模式 vim中提供了 三种 可视模式，可以方便程序员选择 选中文本的方式 命令 模式 功能 ==v== 可视模式 选中光标经过的单个==字符== ==V== 可视行模式 选中光标经过的==整行== Ctrl + v 可视块模式 垂直方向选中文本 ggVG 选中全文 可视模式下，可以和 移动命令 连用，例如：ggVG 能够选中所有内容 注销多行代码：Ctrl + V 选中多行代码，==I== 在选中的行首插入 // 按 ESC 可以放弃选中，返回到 命令模式 4. 复制 快捷键 ==y== 复制选中 ==yw== 向前复制一个单词，复制从光标开始到词尾的字符 ==yb== 向后复制一个单词 3yw y3w 复制从光标开始的3个单词 y^ 复制从光标到行首的内容 y$ 复制从光标到行尾的内容 ==yy== 复制光标所在整行 3yy 向下复制 3 行 数字yy 以光标所在行为准（包含当前行），向下复制指定的行数 在想要粘贴的地方按下p键粘贴 5. 粘贴 快捷键 ==p== 粘贴paste，粘贴在当前光标后（append） ==P== 粘贴在光标前，（insert） ==Ctrl + ;== 在编辑模式，调出 ==Fcitx== 的剪贴板==粘贴==(实现vim粘贴系统粘贴板复制的内容) 注意: vim 中的 文本缓冲区 和系统的 剪贴板 不是同一个,所以在其他软件中使用 CTRL + C 复制的内容，不能在 vim 中通过 P 命令粘贴, 可以在 编辑模式 下使用 鼠标右键粘贴，或者==Ctrl + ;==调出 ==Fcitx== 的剪贴板实现vim粘贴系统粘贴板复制的内容 6. 剪切/删除 命令 英文 功能 ==x== Delete Delete 删除光标所在字符 3x 删除3个字符 ==X== Backspace Backspace 删除光标左边字符 ==d== delete 删除==选中==内容 ==dd== 删除光标所在整行 3dd 删除 3 行 ==dw== d+w ==删除==前一个==单词== 3dw d3w 删除前3个单词 ==db== d+b ==删除==后一个==单词== de d+e 删除后一个单词（到词尾） ==d0== d+0 删除至行首 ==d$== D 删除至行尾 ==d行号gg== d25gg 删除到指定行号 d3h 删除左3字符 d3l 右3 d3j 下3 d3k 上3 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，以下是常见的组合命令： dw # 删除后一个单词 db # 删除前一个单词 d0 # 删除到行首 d} # 从光标位置删除到段落结尾 8dd # 从光标位置向下连续删除 8 行 d行号gg # 从光标所在行 删除到 指定代码行 之间的所有代码 d'a # 从光标所在行 删除到 标记a 之间的所有代码 7. 查找字符 命令 功能 ==f== 向前查找字母，跳到字母位置 ==F== 向后查找字母 fx 向前查找字符 x 8. 替换字符 命令 英文 功能 ==r== replace 替换当前字符 ==R== replace 替换当前行光标后的所有字符 R 命令可以进入 替换模式，替换完成后，按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 9. 修改内容 命令 英文 功能 c ==change== ch 修改右边一个字符（删除右边字符，并进入编辑模式） cl dli 修改右边一个字符（删除右边字符，并进入编辑模式） ==cw== dwi 修改前一个单词（删除前一个单词，并进入编辑模式） cb dbi 修改后一个单词（删除后一个单词，并进入编辑模式） ==c$== d$i 修改到行尾（删除到行尾，并进入编辑模式） ==cc== ddi 修改整行（删除当前行，并进入编辑模式） ncw ndwi 修改指定数目n个单词（删除n个单词，并进入编辑模式） nC nddi 修改指定数目的行（删除n行，并进入编辑模式） s 删除当前字符，并进入编辑模式 S 删除当前行，并进入编辑模式 10. 撤销/恢复 快捷键 ==u== 撤销操作： （undo） ==Ctrl + r== 恢复操作： (restore) U 撤销对该行的所有操作 11. 缩进/合并 命令 功能 ==>>== 单行向右增加缩进 单行向左减少缩进 ==>== 先可视化v选中行,右缩进 先可视化v选中行,左缩进 ==.== 重复上次缩进 ==J== 删除行尾的换行符，下一行接上来，合并光标所在行及下一行为一行 缩进命令 在开发程序时，统一增加代码的缩进 在 可视模式 下，缩进命令只需要使用 一个 > 或者 注销多行代码： Ctrl + V 选中多行代码，==I== 在选中的行首插入 // 12. 重复上次命令 命令 功能 ==.== 重复上次操作命令 格式化代码 格式化代码=自动缩进 命令 功能 ==gg=G== 自动缩进全文，格式化全文 ====== 自动缩进当前行 查看man 命令 功能 ==shift+k== / ==K== 查看光标所在命令的man手册 将光标移动到需要查找帮助的关键字上，按下K，就可以查看光标所在命令的man手册 13. 书签标记 使用 m 增加一个标记，可以在需要时快速地定位跳转回来 标记名称 可以是 a~z 或者 A~Z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 英文 功能 m[a~Z] mark 添加标记，标记号是 a~z 或 A~Z 之间的任意一个字母 'a ‘ 直接定位到标记 a 所在位置 14. 宏 命令 功能 q[a~Z] 开始记录当前开始的操作为宏，名称可为[a~Z]，然后用q终止录制宏 reg 显示当前定义的所有的宏，用@[a~Z]来在当前光标处执行宏[a-Z] 末行模式 进入方式：输入 : 或者 /（表示查找） 退出方式：连按 2 次Esc键 按下Esc,(延迟1s) 删除末行全部输入字符 1. 搜索/查找 命令 功能 ==/关键词== 向下查找==搜索==关键词 ?关键词 向上查找关键词 查找到指定内容之后，使用n Next查找下一个出现的位置： n: 查找下一个 N: 查找上一个 设置高亮显示搜索 ==:set hls== 关闭高亮显示搜索 ==:set nohls== 如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可,或者关闭高亮显示搜索:set nohls【no highlight search】 2. *查找当前单词 命令 功能 ==*== 向下查找当前光标所在单词 # 向前查找当前光标所在单词 n: 查找下一个 N: 查找上一个 3. 查找并替换 记忆命令格式： :%s/old/new/gc 命令 功能 :s/旧文本/新文本 选中范围只替换每行第一处文本 :s/旧文本/新文本/g 选中范围替换,直接替换 :s/旧文本/新文本/gc 选中范围全部替换，提示确认 ==:2,9s/旧文本/新文本/gc== 在 2 到 9 行内全部替换(包括端点) :%s/旧文本/新文本 整个文档中只替换每行第一处文本 :%s/旧文本/新文本/g 整个文档全局替换 ==:%s/旧文本/新文本/gc== 整个文档==全局==替换，提示确认 s (search )搜索 %表示整个文件 g (global)全局（全部） c (confime)确认 确认提示: y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 全局替换 一次性替换文件中的 所有出现的旧文本 :%s/旧文本/新文本 # 全文只替换每行第一处文本 :%s/旧文本/新文本/g # 全文替换,直接替换 :%s/旧文本/新文本/gc # 全文替换,每次确认 选中域替换 先选中 要替换文字的 范围 :s/旧文本/新文本 # 选中范围只替换每行第一处文本 :s/旧文本/新文本/g # 选中范围替换,直接替换 :s/旧文本/新文本/gc # 选中范围替换,每次确认 :' 自带开头 指定行内替换 在 2 到 9 行内进行替换(包括端点) :2,9s/旧文本/新文本/gc # 在2到9行内进行替换(包括端点)，直接替换 :2,9s/旧文本/新文本/gc # 在2到9行内进行替换(包括端点)，每次确认 确认替换 如果把末尾的 g 改成 gc 在替换的时候，会有提示！推荐使用！ :%s/旧文本/新文本/gc # 全局替换，每次确认 :s/旧文本/新文本/gc # 选中范围替换，每次确认 g global 全局（全部） c confime 确认 4. 文件操作 命令 英文 功能 ==:n1,n2 write temp.c== 将n1行到n2行之间的内容写到temp.c文件中 ==:write file.c== 将整个文件的内容写到file.c文件中 ==:read file.c== 将file.c文件的内容插入到当前光标所在行的下面 ==:e .== edit 浏览要当前目录下的文件,上下选择,Enter可打开文件 :e filename 打开filename文件编辑 ==:e!== 放弃修改文件内容，重新载入该文件编辑 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 ==:files== 查看当前已经打开的文件名称 :open 已经打开的文件名 切换到已经打开的文件名 切换文件之前，必须保证当前这个文件已经被保存！ 1. 当前文件 使用vim同时打开多个文件，在末行模式下进行切换文件 查看当前已经打开的文件名称：“:files” :files # 查看当前已经打开的文件名称 在%a的位置有2种显示可能 %a：a=active，表示当前正在打开的文件； #：表示上一个打开的文件 2. 切换文件 如果需要指定切换文件的名称，则可以输入：“:open 已经打开的文件名” :open 已经打开的文件名 # 切换到已经打开的文件名 可以通过其他命令来切换上一个文件/下一个文件 :bn # 切换到下一个文件（back next） :bp # 切换到上一个文件（back previous） 连按2次esc键,退出末行模式 5. :X 加密/解密文件 命令 功能 ==:X== 大写X ,两次输入密码,进行加密 必须==:wq==保存才能生效(Ctrl+zz不行) 6. 保存退出 快捷键 功能 :w 保存（write） :w 路径 另存为 :q 退出（quit） ==:wq== 保存并退出 ==:q!== 强制退出，不做保存 :x 保存并退出(文件没有修改则直接退出，文件被修改保存并退出) ==Shift + zz== 等价:x保存并退出(文件没有修改则直接退出，文件被修改保存并退出) 当没有权限修改文件时，无法保存修改 7. 临时调用外部命令:! ==:!外部bash命令==，临时调用外部bash命令 快捷键 功能 ==:!外部bash命令== 临时调用外部bash命令 :!ls 临时调用外部bash命令ls查看文件目录 ==:r !外部bash命令== 将shell命令command的输出结果插入到当前行的下一行 :r !date 读取系统时间并插入到当前行的下一行 :n1 !command 将n1行的内容输入到shell命令command处理，并将处理结果替换n1行之后的内容，修改内容 . !tr [a-z][A-Z] 将当前行的小写转为大写 :n1,n2 !command 将n1行到n2行之间的内容输入到shell命令command处理，并将处理结果替换1行到n2行之间的内容 :62,72 !sort 将62行到72行的内容进行排序,改变当前编辑的文件的内容 :w !command 将整个文件内容作为command的输入并执行 :n1,n2 w !command 将n1行到n2行之间的内容作为command的输入并执行， 不会改变当前编辑的文件的内容 :62,72 w !sort 将62行到72行的内容进行排序，而不改变当前编辑的文件的内容，而是显示在vim敲命令的区域 ==:62 w !bash== 将会把第62行的内容作为bash命令来执行并显示结果，而不改变当前编辑的文件的内容 ==:. w !bash== 将当前行的内容作为bash命令来执行 ，而不改变当前编辑的文件的内容 ==:w !bash== 将整个文件的内容作为bash命令来执行，而不改变当前编辑的文件的内容 r 插入到当前行的下一行 w 不改变当前编辑的文件的内容 . 当前行 :!ls -lah 临时调用外部bash命令ls查看文件目录 :!date 命令行显示日期，不修改 :r !date 插入到下一行 :w !date 命令行显示日期，不修改 :!bash 无法执行当前脚本 :r !bash 无法执行当前脚本 :w !bash 执行当前脚本，不修改 :2 !bash 执行第二行，修改 :2 w !bash 执行第二行，不修改 8. 行操作 命令 功能 :n1,n2 co n3 将n1行到n2行之间的内容拷贝到 n3 行下 ==:n1,n2 mv n3== 将n1行到n2行之间的内容移动到 n3 行下 ==:n1,n2 d== 将n1行到n2行之间的内容删除 若不指定n1,n2，则将整个文件内容作为command的输入 9. 分屏命令 使用分屏命令，可以同时编辑和查看多个文件 命令 英文 功能 ==:sp [文件名]== split 横向增加分屏 :vsp [文件名] vertical split 纵向增加分屏 ==:close== 关闭当前窗口 1) 切换分屏窗口 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 Ctrl + w + ==w== window 切换到下一个窗口 Ctrl + w + r reverse 互换窗口 Ctrl + w + ==c== close 关闭当前窗口，但是不能关闭最后一个窗口 Ctrl + w + q quit 退出当前窗口，如果是最后一个窗口，则关闭 vi Ctrl + w + o other 关闭其他窗口 2) 调整窗口大小 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 功能 Ctrl + w + + 增加窗口高度 Ctrl + w + - 减少窗口高度 Ctrl + w + > 增加窗口宽度 Ctrl + w + 减少窗口宽度 Ctrl + w + = 等分窗口大小 调整窗口宽高的命令可以和数字连用，例如：5 CTRL + W + 连续 5 次增加高度 10. :help帮助命令 :help # 查看整个帮助 :help xxx # 查看xxx帮助 11. vim配置 7. 忽略大小写 :set ignorecase # 忽略大小写查找 :set noignorecase # 区分大小写查找 8. :set hls 高亮搜索结果 :set hls # 高亮搜索结果【highlight search】 :set nohls # 关闭高亮搜索结果 9. :set nu 显示行号 :set nu # 显示行号 number :set nonu # 不显示行号 no number 10. :syntax 语法着色显示 :syntax on # 显示语法着色 (syntax：语法) :syntax off # 关闭着色显示 编辑模式 1. 进入编辑模式 i a o I A O 进入编辑模式 Esc 退出编辑模式 在 vi 中除了常用的 i 进入 编辑模式 外，还提供了以下命令同样可以进入编辑模式： 命令 英文 功能 ==i== insert 在当前字符前插入文本 ==a== append 在当前字符后追加文本 ==I== 在行首插入文本 ==A== 在行尾追加文本 ==o== over 在当前行下面插入一空行 ==O== 在当前行上面插入一空行 i(insert)插入，a(append)追加，o(over)空行，小写表示下，大写表示上 2. vim代码提示 编辑模式下代码提示 功能 ==Ctrl + n== 编辑模式下，代码提示 3. vim多行注释代码 编辑模式下注释代码 功能 ==:normal i #== 选中区域行首插入 # ==:normal d #== 选中区域行首删除 # V选中多行代码，同时插入# 4. vim中计算器的使用 在编辑文件的时，可以临时使用计算器。 编辑模式下代码提示 功能 ==Ctrl + r + === 编辑模式下，计算器 进入编辑模式 按下ctrl + r，然后输入=，此时光标会变到最后一行 输入需要计算的内容，按下回车 常用命令速查图 vim的配置 Vim是一款编辑器，编辑器也是有配置文件的。 Vim配置有三种情况： a. 在文件打开的时候在末行模式下输入的配置（临时的） b. 个人配置文件~/.vimrc，(如果没有可以自行新建touch ~/.vimrc）家目录下的配置文件优先级更高 c. 全局配置文件（vim自带，/etc/vimrc） vimrc 是 vim 的配置文件，可以设置 vim 的配置，包括：热键、配色、语法高亮、插件 等 vim ~/.vimrc编辑个人配置文件,在配置文件中进行配置,比如显示行号:set nu,配置好之后vim打开文件就会永远显示行号 ~/.vimrc # 个人配置文件(如果没有可以自行新建） /etc/vim/vimrc # 全局配置文件 \" # 显示行号 :set nu“ # 显示语法着色 :syntax on” # 高亮搜索结果 :set hlsearch“ # 忽略大小写查找 :set ignorecase 常用的插件有： 代码补全 代码折叠 搜索 Git 集成 …… "},"doxygen/":{"url":"doxygen/","title":"doxygen","keywords":"","body":"doxygen源码文档生成工具doxygen源码文档生成工具 Doxygen是一个适用于C++,C,Java,Objective-C,Python,IDL,Fortran,VHDL,PHP,C#和D语言的文档生成器。它可以在大多数类Unix操作系统,macOS以及Microsoft Windows上运行。 Doxygen是一个编写软件参考文档的工具，能将程序中的特定批注转换成为说明文件。它可以依据程序本身的结构，将程序中按规范注释的批注经过处理生成一个纯粹的参考手册，通过提取代码结构或借助自动生成的包含依赖图（include dependency graphs）,继承图（inheritance diagram）以及协作图（collaboration diagram）来可视化文档之间的关系， Doxygen生成的帮助文档的格式可以是HTML,PDF,CHM,RTF等。 "},"markdown/":{"url":"markdown/","title":"MarkDown","keywords":"","body":"MarkDownWhat’s Markdown?What’s Typora?MarkDown What’s Markdown? Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、易读易写，并且对于图片，图表、数学式都有支持，人们广泛使用 Markdown 来撰写README帮助文档或论坛博客。例如CSDN、博客园和GitHub的README及Wiki等。 What’s Typora? Typora 是一款简单、高效 Markdown 编辑器，支持即时渲染技术，提供了一种“所见即所得”的全新的 Markdown 写作体验。不像其他Markdown编辑器将「编辑」和「显示」相分离，Typora 把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时渲染生成预览效果，使得你写Markdown就像是写Word文档一样流畅自如，这也是与其他Markdown编辑器最显著的区别。Typora 是目前互联网上最受欢迎的 Markdown 编辑器之一。 Overview typora快捷键 Basic usage Paragraph and line breaks 段落 Headers 标题 # … Emphasis 斜体 … / - … - Strong 加粗 ... / … Code 行内代码 … Strikethrough 删除线 ~~ … ~~ Underlines 下划线 \\ … \\ Subscript 下标 ~ … ~ Superscript 上标 ^ … ^ Highlight 高亮 == … == Emoji 表情 : … : Inline Math 行内公式 $ … $ 无序列表 * / - / + 有序列表 1. 2. 3. Task List 任务列表 - [x] Code Blocks 代码块 ``` ... ``` Blockquotes 块引用 > Math Blocks 数学公式块 $$ ... $$ Tables 表格 Horizontal Rules 水平线 --- YAML Front Matter Table of Contents 目录 [toc] Footnotes 注释 [\\^footnote] Links 链接 [站名](网址) 本地文档链接 [文档](文档路径) Internal Links 内部链接 [](#标题名) Reference Links 参考链接 [名称][id] URLs Images 图片 ![] (路径/URL) Video 视频 Images Table Diagrams Math HTML "},"markdown/markdown.html":{"url":"markdown/markdown.html","title":"MarkDown语法","keywords":"","body":"Typora – Markdown 简介OverviewWhat’s Markdown?What’s Typora?Install Typoratypora快捷键Basic usageParagraph and line breaks 段落Headers 标题 # …Emphasis 斜体 … / - … -Strong 加粗 ... / … Code 行内代码 ` … `Strikethrough 删除线 ~~ … ~~Underlines 下划线 \\ … \\Subscript 下标 ~ … ~Superscript 上标 ^ … ^Highlight 高亮 == … ==Emoji 表情 : … :Inline Math 行内公式 $ … $无序列表 * / - / +有序列表 1. 2. 3.Task List 任务列表 - [x]Code Blocks 代码块 ``` ... ```Blockquotes 块引用 >Math Blocks 数学公式块 $$ ... $$Tables 表格Horizontal Rules 水平线 --- / *YAML Front MatterTable of Contents 目录 [toc]Footnotes 注释 [\\^footnote]Links 链接 [站名](网址)本地文档链接 [文档](文档路径)Internal Links 内部链接 [](#标题名)Reference Links 参考链接 [名称][id]URLsImages 图片 ![] (路径/URL)Video 视频Images插入图片方式图片对齐修改图片大小TableCreate Table in TyporaAdd/Delete 行Add/Delete 列文字对齐DiagramsFlowchart 流程图SequenceMermaidMathMath Block $$ $$Inline Math $ $TeX CommandsChemistry Expressions 化学式Cross ReferenceHTMLInline HTMLHTML EntitiesHTML BlockMedia and Embedded ContentsTypora – Markdown 简介 Typora官网 [TOC] Overview What’s Markdown? What’s Typora? Install Typora typora快捷键 Basic usage Paragraph and line breaks 段落 Headers 标题 # … Emphasis 斜体 … / - … - Strong 加粗 ... / … Code 行内代码 ` … ` Strikethrough 删除线 ~~ … ~~ Underlines 下划线 \\ … \\ Subscript 下标 ~ … ~ Superscript 上标 ^ … ^ Highlight 高亮 == … == Emoji 表情 : … : Inline Math 行内公式 $ … $ 无序列表 * / - / + 有序列表 1. 2. 3. Task List 任务列表 - [x] Code Blocks 代码块 ``` ... ``` Blockquotes 块引用 > Math Blocks 数学公式块 $$ ... $$ Tables 表格 Horizontal Rules 水平线 --- / * YAML Front Matter Table of Contents 目录 [toc] Footnotes 注释 [\\^footnote] Links 链接 [站名](网址) 本地文档链接 [文档](文档路径) Internal Links 内部链接 [](#标题名) Reference Links 参考链接 [名称][id] URLs Images 图片 ![] (路径/URL) Video 视频 Images 插入图片方式 图片对齐 修改图片大小 Table Create Table in Typora Add/Delete 行 Add/Delete 列 文字对齐 Diagrams Flowchart 流程图 Sequence Mermaid Math Math Block $$ $$ Inline Math $ $ TeX Commands Chemistry Expressions 化学式 Cross Reference HTML Inline HTML HTML Entities HTML Block Media and Embedded Contents Comments Html 标签 内嵌图标?? Reference Overview What’s Markdown? Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、易读易写，并且对于图片，图表、数学式都有支持，人们广泛使用 Markdown 来撰写README帮助文档或论坛博客。例如CSDN、博客园和GitHub的README及Wiki等。 What’s Typora? Typora 是一款简单、高效 Markdown 编辑器，支持即时渲染技术，提供了一种“所见即所得”的全新的 Markdown 写作体验。不像其他Markdown编辑器将「编辑」和「显示」相分离，Typora 把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时渲染生成预览效果，使得你写Markdown就像是写Word文档一样流畅自如，这也是与其他Markdown编辑器最显著的区别。Typora 是目前互联网上最受欢迎的 Markdown 编辑器之一。 Typora 的优点： 实时渲染：Typora 支持即时渲染，可以在同一个界面实时看到渲染后的效果，所见即所得； 扩展语法：Typora 支持 GitHub 风格的 Markdown 语法，还支持部分HTML语法； LaTeX公式：支持LaTeX公式编辑； 快捷操作：Typora 对常用的 Markdown 语法操作都提供了快捷键操作，用起来非常高效； 简单漂亮：Typora 默认支持 5 种主题，可自由切换，操作简单，非常容易上手； 跨平台：Typora 支持 macOS、Windows 和Linux系统； 免费：Typora 完全免费，这点很重要。 You can get more information on the official website of typora. Install Typora 进入Typora官网进行下载，支持 Mac、 Windows 和 Linux ，有详细的安装介绍。 Ubuntu 进入Typora官网进行下载安装，有详细的安装介绍。 # apt-key sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE # add Typora's repository sudo add-apt-repository 'deb https://typora.io/linux ./' sudo apt-get update # install typora sudo apt-get install typora # typora编辑器 sudo apt-get install pandoc # 文档转换import/export插件(可选) Windowns 进入Typora官网进行下载安装，有详细的安装介绍。 MacOS 进入Typora官网进行下载安装，有详细的安装介绍。 typora快捷键 名称 快捷键 ==源代码模式== ==Ctrl +/== 标题H1-H6 Ctrl + 1/2/3/4/5/6 加粗 Ctrl + B 斜体 Ctrl + I 下划线 Ctrl + U Table表格 Ctrl + T 超链接 Ctrl + K 复制格式 Ctrl + C 复制为Markdown Ctrl + Shift + C 粘贴格式 Ctrl + V 纯文本粘贴 Ctrl + Shift + V 引用 Ctrl + Shift + Q 图片 Ctrl + Shift + I 选中单词 Ctrl + D 选中行 Ctrl + L Basic usage Paragraph and line breaks 段落 Enter # 新段落 Shift + Enter # 新行 Headers 标题 # … # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 Emphasis 斜体 … / - … - single asterisks正常 *single asterisks斜体 (推荐 \\* ...\\*)* _single underscores斜体_ single asterisks正常 single asterisks斜体 (推荐 \\ ...*)* single underscores斜体 Strong 加粗 ... / … double asterisks正常 **double asterisks 加粗 (推荐 \\** ... \\**)** __double underscores 加粗__ double asterisks正常 double asterisks 加粗 (推荐 \\ ... *)* double underscores 加粗 Code 行内代码 ` … ` Use the `print()` function. Use the print() function. Strikethrough 删除线 ~~ … ~~ ~~Mistaken text~~ Mistaken text Underlines 下划线 \\ … \\ Underline Underline Subscript 下标 ~ … ~ H~2~O X~long\\ text~ H~2~O X~long\\ text~ Superscript 上标 ^ … ^ X^2^ X^2^ Highlight 高亮 == … == ==highlight高亮== ==highlight高亮== Emoji 表情 : … : :smile: :eyes: :smile: :eyes: Inline Math 行内公式 $ … $ 例如: $\\lim_{x \\to \\infty} \\exp(-x) = 0$ will be rendered as LaTeX command. 例如: $\\lim_{x \\to \\infty} \\exp(-x) = 0$ will be rendered as LaTeX command. 无序列表 * / - / + 无序列表 : * - + - Red - Green - Blue Red Green Blue 有序列表 1. 2. 3. 有序列表 : 1. 2. 3. 1. First 2. Second 3. Third First Second Third Task List 任务列表 - [x] -[] 复选框任务项 -[] 未勾选 -[x] 勾选 复选框任务项 未勾选 勾选 Code Blocks 代码块 ``` ... ``` ​```python # python import tensorflow as tf ​ ```python # python import tensorflow as tf Blockquotes 块引用 > > 引用块 第一行 > > 第三行 引用块 第一行 第三行 Math Blocks 数学公式块 $$ ... $$ $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\\\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\\\ \\end{vmatrix} $$ $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\ \\end{vmatrix} $$ Tables 表格 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell | Left-Aligned | Center Aligned | Right Aligned | | :------------ |:---------------:| -------------:| | :左对齐 | :居中: | 右对齐: | | :左对齐 | :居中: | 右对齐: | Left-Aligned Center Aligned Right Aligned :左对齐 :居中: 右对齐: :左对齐 :居中: 右对齐: Horizontal Rules 水平线 --- / * *** 水平线 --- 水平线 * YAML Front Matter 首行添加--- --- layout: post title: Blogging Like a Hacker --- Table of Contents 目录 [toc] [toc] [TOC] Footnotes 注释 [\\^footnote] 这个有悬停注释[^footnote] # 定义注释 [^footnote]: 鼠标悬停显示**注释footnotes** # 悬停显示的内容 这个有悬停注释footnote footnote. 鼠标悬停显示注释footnotes ↩ Links 链接 [站名](网址) [百度](http://www.baidu.com) # 按住 Ctrl + 鼠标左键 跳转至百度 百度 # 按住 Ctrl + 鼠标左键 跳转至百度 本地文档链接 [文档](文档路径) [打开文件 README.md](./README.md) # 按住 Ctrl + 鼠标左键 打开文档 [打开文件 LICENSE](./LICENSE) # 按住 Ctrl + 鼠标左键 打开文档 打开文件 README.md # 按住 Ctrl + 鼠标左键 打开文档 打开文件 LICENSE # 按住 Ctrl + 鼠标左键 打开文档 Internal Links 内部链接 [](#标题名) 按住 Ctrl + 鼠标 [跳转到标题Overview](#Overview) 实现文档内部跳转到`Overview` 按住 Ctrl + 鼠标 跳转到标题Overview 实现文档内部跳转到 Overview Reference Links 参考链接 [名称][id] 更详细的语法说明 [Cmd Markdown 简明语法手册][1] 进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] [1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown [2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册 更详细的语法说明 Cmd Markdown 简明语法手册 进阶用户可以参考 Cmd Markdown 高阶语法手册 This is [谷歌][googleid] reference-style link. # [googleid]:指明参考链接 [googleid]: http://google.com/ \"Optional Title\" This is 谷歌 reference-style link. # googleid:指明参考链接 This is another [百度][] reference-style link. # [百度][]省略参考链接id,直接用内容作为id [百度]: http://baidu.com/ This is another 百度 reference-style link. # [百度][]省略参考链接id,直接用内容作为id URLs 标准URL自动链接,按住 Ctrl + 鼠标左键 可访问 www.typora.io https://www.baidu.com/ # 标准URL www.baidu.com # 自动链接standard URL # URL www.typora.io https://www.baidu.com/ # 标准URL www.baidu.com # 自动链接standard URL # URL Images 图片 ![] (路径/URL) ![网络图](http://www.shu.edu.cn/images/logo.jpg) ![image绝对路径](/home/chao/Desktop/assets/img.jpg) ![image相对路径](./assets/img.png) ![image](./assets/img.jpg \"Optional title标题??\") ![gif动图](./assets/drag-img.gif) # 拖动即可添加图片 Video 视频 Images Images in Typora 插入图片方式 Write the Markdown ![网络图](http://www.shu.edu.cn/images/logo.jpg) ![image绝对路径](/home/chao/Desktop/assets/img.jpg) ![image相对路径](./assets/img.jpg) ![image](./assets/img.png \"Optional title标题??\") ![gif动图](./assets/drag-img.gif) # HTML设置图片大小 Drag & Drop 拖动图片丢到Typora即可添加图片 Select from local files 本地选择 Edit → Image Tools → Insert Local Images… from Paste images from clipboard 粘贴 复制图片→粘贴 图片对齐 部分HTML代码不能即时渲染，仅当导出为PDF或HTML时这部分HTML代码才有效 Currently Typora does not support image alignment. But you could use HTML code like ![img](src)to align images on exported HTML or PDF. ![img](src) # 中心对齐图片 ![img](src) # 右对齐图片 ![img](src) # 左对齐图片 使用 HTML 右对齐图片 使用 HTML ![image相对路径](./assets/img.jpg) 中心对齐图片 修改图片大小 Resize Images Typora allows to use tag for displaying images, which can also be used to adjust the size of images. ？？ Table Table Editing Create Table in Typora |First Header | Second Header| + Enter | First Header | Second Header | ||| || | First Header | Second Header | | ------------ | ------------- | | | | | | | + Enter First Header Second Header Add/Delete 行 Ctrl+Enter First Header Second Header Add/Delete 列 First Header 文字对齐 | Default | Left左 | Right右 | Center中 | | ------- | :---- | :---: | ----: | | cell1 | cell2 | cell3 | cell4 | Default Left左 Right右 Center中 cell1 cell2 cell3 cell4 Diagrams Draw Diagrams With Markdown Flowchart 流程图 flowchart.js ​```flow st=>start: Start op=>operation: Your Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op ​ ```flow st=>start: Start op=>operation: Your Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op Sequence js-sequence ​```sequence Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks! ​ ```sequence Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks! Mermaid mermaid Sequence ​```mermaid %% Example of sequence diagram sequenceDiagram Alice->>Bob: Hello Bob, how are you? alt is sick Bob->>Alice: Not so good :( else is well Bob->>Alice: Feeling fresh like a daisy end opt Extra response Bob->>Alice: Thanks for asking end ​ ```mermaid %% Example of sequence diagram sequenceDiagram Alice->>Bob: Hello Bob, how are you? alt is sick Bob->>Alice: Not so good :( else is well Bob->>Alice: Feeling fresh like a daisy end opt Extra response Bob->>Alice: Thanks for asking end Flowchart ​```mermaid graph LR A[Hard edge] -->B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] ​ ```mermaid graph LR A[Hard edge] -->B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] Gantt ​```mermaid %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h ​ ```mermaid %% Example with selection of syntaxes gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h Math Math and Academic Functions Math Block $$ $$ 质能守恒公式LaTeX$$E=mc^2$$ $$ \\begin{align} y = y(x,t) &= A e^{i\\theta} \\ &= A (\\cos \\theta + i \\sin \\theta) \\ &= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\ &= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\ &= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\ &= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t) \\end{align} $$ Inline Math $ $ e.g: $f = \\frac{2 \\pi}{T}$ TeX Commands TeX commands \\begin{XXX} ... \\end{XXX} Chemistry Expressions 化学式 mhchem $\\ce{CH4 + 2 $\\left( \\ce{O2 + 79/21 N2} \\right)$}$ Cross Reference Here is a labeled equation: $$ x+1\\over\\sqrt{1-x^2}\\label{ref1} $$ This is a referece : $\\ref{ref1}$ HTML HTML Support in Typora Inline HTML This is red 漢 ㄏㄢˋ Ctrl+F9 Bigger HTML entities like ® ¶ HTML Entities &frac14 &#x1D517 HTML Block I have keys but no locks. I have space but no room. You can enter but can't leave. What am I? A keyboard. Media and Embedded Contents Video Audio Embed Web Contents See the Pen Fancy Animated SVG Menu by Jean Gontijo (@jeangontijo) on CodePen. PDF Comments Html 标签 本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： 值班人员 星期一 星期二 星期三 李强 张明 王平 值班人员 星期一 星期二 星期三 李强 张明 王平 内嵌图标?? 本站的图标系统对外开放，在文档中输入 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 更多关于 Typora 的多详情请参阅 Support 。 Reference Typora Support "},"gitbook/":{"url":"gitbook/","title":"GitBook","keywords":"","body":"GitBookGitBook Modern documentation format and toolchain using Git and Markdown gitbook 使用 Git 和 Markdown 来编排书本。 GitBook除了是一个命令行工具，它同时也是间书籍发布平台和电子书店。桌面版本同时支持Mac、Windows、Linux三种平台。 简介 安装gitbook-cli] GitBook 目录结构介绍] GitBook 使用 gitbook-cli 终端命令 GitBook.com线编辑器 GitBook Editor 客户端 发布到 GitHub Pages build构建书籍%A6%E7%B1%8D) 创建 gh-pages 分支 上传书籍内容到 GitHub "},"gitbook/gitbook.html":{"url":"gitbook/gitbook.html","title":"GitBook笔记","keywords":"","body":"gitbook简介安装gitbook-cliGitBook 目录结构介绍GitBook 使用gitbook-cli 终端命令GitBook.com线编辑器GitBook Editor 客户端发布到 GitHub Pagesbuild构建书籍创建 gh-pages 分支上传书籍内容到 GitHubgitbook [TOC] 简介 安装gitbook-cli GitBook 目录结构介绍 GitBook 使用 gitbook-cli 终端命令 GitBook.com线编辑器 GitBook Editor 客户端 发布到 GitHub Pages build构建书籍 创建 gh-pages 分支 上传书籍内容到 GitHub 简介 Modern documentation format and toolchain using Git and Markdown gitbook 它使用 Git 和 Markdown 来编排书本，这是 gitbook 项目主页上对 gitbook 的定义。 GitBook除了是一个命令行工具，它同时也是间书籍发布平台和电子书店。桌面版本同时支持Mac、Windows、Linux三种平台。 支持格式 GitBook工具能够制作多种格式书籍：PDF、ePub、mobi与线上阅读版本（网站HTML）。 它是开源的,你可以在这里看到工具的源代码，亦可在GitHub上提交问题与意见，甚至写组解决问题或改善程序。 GitBook 的基本特性： 以Markdown轻量级标记语法作为编辑“原稿”的基础。 使用Git作为版本管理架构。 通过云端服务生成各种通用电子书格式。 支持在浏览器中阅读，增加了JavaSript。 读者可直接付费购买，支持创作与正版流通。 提供OPDS流通，可在移动设备上使用支持的阅读软件 安装gitbook-cli gitbook 详细安装指南可以参考 gitbook 文档。 sudo apt-get install nodejs # 安装nodejs node -v # 查看nodejs版本 sudo apt-get install npm # 安装npm sudo npm install gitbook-cli -g # 安装gitbook-cli gitbook -V # 查看gitbook版本 GitBook 目录结构介绍 一本由 GitBook 创建的电子书籍，除了实际内容文件外，还应包含如下文件： README.md:书的介绍文字，如前言、简介，在章节中也可做为章节的简介。（必须） SUMMARY.md:定制书籍的章节结构和顺序。（必须） LANGS.md:多种语言设置。 GLOSSARY.md:词量表和定义描述。 README.md和SUMMARY.md是GitBook 制作电子书的必要文件，可用gitbook init命令自动生成，其余文件如有需要，可手动添加。 GitBook 基本的目录结构如下所示 . ├── book.json ├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md 章节目录 GitBook 使用SUMMARY.md文件作为书籍的目录结构，既多层次章节设置。它同时也被用来制作书籍目录（TOC-Tables Of Contents）。 SUMMARY.md的格式只是简单的连接列表，连接的“名称”就是章节的“标题”，连接标的则是实际内容“文件”（包含路径）。 章节的层级，就是根据清单的层级关系定义的。 多层级可将书籍分为“部”、“章”、“节”或“小节”，而且不会自动赋予标号或固定名称，选择自己想要的结构即可。 没有在SUMMARY.md中出现的文件，GitBook 在生成各种格式电子书的时候是不会将其包含在内的，因此可以自由撰写草稿、参考文件等，只要不将它们加入到SUMMARY.md文件中，就不会被发布。 简单结构目录示例 Summary.md #Summary * [第一章](chapter1.md) * [第二章](chapter2.md) * [第三章](chapter3.md) 多层结构目录示例 Summary.md #Summary * [第一部](part1/README.md) * [写作是没好的](part1/writing.md) * [GitBook 也不错](part1/gitbook.md) * 第二部 * [我们欢迎读者回馈](part2/feedback_please.md) * [对作者更好的工具](part2/better_tools.md) ps. 可以看到“第一部”有连接到实际的文件，可以放一个简单的“章节简介”，或特殊的标题或引言，甚至是展现一张图片都可以。而“第二部”则没有连接任何文件，这样在发布书籍时，就有可能导致“第二部”解析错误，后面有连接实际文件的不会受此影响。 README.md文件默认会作为多层目录结构中的章节连接文件。 # Summary * [Introduction](README.md) * [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) * [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) 这个配置对应的目录结构如下所示: 我们通过使用 标题 或者 水平分割线 标志将 GitBook 分为几个不同的部分 # Summary ### Part I * [Introduction](README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) ---- * [Last part without title](part3/title.md) 这个配置对应的目录结构如下所示： 多语言 GitBook 支持多种语言编写图书。每种语言必须是一个子目录，子目录结构与 GitBook 结构相同（拥有各自的README.md、SUMMARY.md以及实际内容文件）， LANGS.md 在外层父目录（书籍项目根目录），其内容格式如下： LANGS.md * [English](en/) * [zh-hans](zh-hans/) * [zh-tw](zh-tw/) 忽略目录和文件 GitBook 会读取 .gitignore,.bookignore 以及 .ignore 这三个档案，根据里面的内容，忽略特定的文件或子目录。（格式为一行一个文件或目录。） .gitignore #忽略 test.md 文件 test.md #忽略 \"bin\" 目录下所有文件 bin/* 术语表 词汇表文件，默认对应的文件是 GLOSSARY.md。该文件主要存储词汇信息，如果在其他页面中出现了该文件中的词汇，鼠标放到词汇上会给出词汇示意，可以将鼠标移到下面两个词汇上看下效果。 在术语表中指定要显示的术语和其各自的定义。基于这些条件 gitbook 会自动建立索引，并在内容页面中高亮显示这些术语。 GLOSSARY.md # term Definition for this term # Another term With it's definition, this can contain bold text and all other kinds of inline markup ... 配置信息 book.json存放配置信息 GitBook 使用 gitbook-cli 终端命令 gitbook 的基本用法非常简单，基本上就只有两步： 使用 gitbook init 初始化书籍目录 使用 gitbook serve 编译书籍 下面将结合一个非常简单的实例，来介绍 gitbook 的基本用法。 gitbook init gitbook init 创建如下目录结构： $ tree book/ book/ ├── README.md └── SUMMARY.md 0 directories, 2 files README.md 和 SUMMARY.md 是两个必须文件，README.md 是对书籍的简单介绍： $ cat book/README.md # README This is a book powered by [GitBook](https://github.com/GitbookIO/gitbook). SUMMARY.md 是书籍的目录结构。内容如下： $ cat book/SUMMARY.md # SUMMARY * [Chapter1](chapter1/README.md) * [Section1.1](chapter1/section1.1.md) * [Section1.2](chapter1/section1.2.md) * [Chapter2](chapter2/README.md) 创建了这两个文件后，使用 gitbook init，它会为我们创建 SUMMARY.md 中的目录结构。 $ cd book $ gitbook init $ tree . ├── README.md ├── SUMMARY.md ├── chapter1 │ ├── README.md │ ├── section1.1.md │ └── section1.2.md └── chapter2 └── README.md 2 directories, 6 files gitbook serve 书籍目录结构创建完成以后，就可以使用 gitbook serve 来编译和预览书籍了： $ gitbook serve Press CTRL+C to quit ... Live reload server started on port: 35729 Starting build ... Successfully built! Starting server ... Serving book on http://localhost:4000 gitbook serve 命令实际上会首先调用 gitbook build 编译书籍，完成以后会打开一个 web 服务器，监听在本地的 4000 端口。 现在，可以用浏览器打开 http://127.0.0.1:4000查看书籍的效果 现在，gitbook 为我们创建了书籍目录结构后，就可以向其中添加真正的内容了，文件的编写使用 markdown 语法，在文件修改过程中，每一次保存文件，gitbook serve 都会自动重新编译，所以可以持续通过浏览器来查看最新的书籍效果！ 初始化书籍目录 gitbook init 生成静态网页 gitbook build 生成静态网页并运行服务器 gitbook serve 生成时指定gitbook的版本, 本地没有会先下载 gitbook build --gitbook=2.0.1 列出本地所有的gitbook版本 gitbook ls 列出远程可用的gitbook版本 gitbook ls-remote 安装对应的gitbook版本 gitbook fetch 标签/版本号 更新到gitbook的最新版本 gitbook update 卸载对应的gitbook版本 gitbook uninstall 2.0.1 指定log的级别 gitbook build --log=debug 输出错误信息 gitbook builid --debug 列出gitbook所有的命令 gitbook help 输出gitbook-cli的帮助信息 gitbook --help GitBook.com线编辑器 访问gitbook.com，如有GitHub帐号，直接使用GitHub帐号进行授权注册，这里使用GitHub帐号，是因为与GitHub进行关联时无需再次做GitHub授权操作。当然，你也可以注册一个GitBook帐号。 在gitbook仓储设置关联github仓储，可以与github仓储同步。 GitBook Editor 客户端 GitBook Editor 客户端与其在线编辑器完全一样，区别在于一个是在线编辑器，一个是离线编辑器。 发布到 GitHub Pages 除了能够将书籍发布到 GitBook.com 外，还可以将书籍发布到 GitHub Pages，由于没有找到官方文档，所以这里记录的是我自己正在使用的一种方法。 如果读者不了解 GitHub Pages 为何物，简单说就是一个可以托管静态网站的 Git 项目，支持使用 markdown 语法以及 Jekyll 来构建，或者直接使用已经生成好的静态站点。详细可以参考 GitHub Pages 主页。 由于 gitbook 书籍可以通过 gitbook 本地构建出 site 格式，所以可以直接将构建好的书籍直接放到 GitHub Pages 中托管，之后，可以通过如下地址访问书籍： .github.io/ 例如：这本书中使用的例子 'test' 项目可以通过地址：xxx.github.io/test 来访问。 当访问 xxx.github.io/test 时，会访问 xxx/test 项目的 gh-pages 分支的内容，所以需要为项目创建一个 gh-pages 分支，并且将静态站点内容放入其中。也就是说，test 项目将有如下两个分支： master, 保存书籍的源码 gh-pages, 保存书籍编译后的 HTML 文件 build构建书籍 首先，使用 gitbook build 将书籍内容输出到默认目录，也就是当前目录下的 _book 目录。 $ gitbook build Starting build ... Successfully built! $ ls _book GLOSSARY.html chapter1 chapter2 gitbook glossary_index.json index.html search_index.json 创建 gh-pages 分支 执行如下命令来创建分支，并且删除不需要的文件： $ git checkout --orphan gh-pages $ git rm --cached -r . $ git clean -df $ rm -rf *~ 现在，目录下应该只剩下 _book 目录了，首先，忽略一些文件： $ echo \"*~\" > .gitignore $ echo \"_book\" >> .gitignore $ git add .gitignore $ git commit -m \"Ignore some files\" 然后，加入 _book 下的内容到分支中： $ cp -r _book/* . $ git add . $ git commit -m \"Publish book\" 上传书籍内容到 GitHub 现在，可以将编译好的书籍内容上传到 GitHub 中 test 项目的 gh-pages 分支了，虽然这里还没有创建分支，上传和创建会一步完成！ $ git push -u origin gh-pages Counting objects: 49, done. Delta compression using up to 4 threads. Compressing objects: 100% (45/45), done. Writing objects: 100% (49/49), 1.34 MiB | 131.00 KiB/s, done. Total 49 (delta 5), reused 0 (delta 0) To https://github.com/chengweiv5/test.git * [new branch] gh-pages -> gh-pages Branch gh-pages set up to track remote branch gh-pages from github. 现在，书籍的内容已经上传到 GitHub 上，所以通过访问 xxx.github.io/test 就可以阅读 test 这本书了！ Gitbook editor与gitbook，github同步 新版gitbook+github+Typora使用方法 GitBook 使用教程 GitBook 简明教程 GitBook插件整理 gitbook常用的插件 "},"git/":{"url":"git/","title":"Git","keywords":"","body":"GitGit Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git概述 常用操作 Git 基础 Git 分支 服务器上的 Git - 协议 分布式 Git Git 命令 GitHub REFERENCES "},"git/git.html":{"url":"git/git.html","title":"Git&GitHub","keywords":"","body":"git & GitHub教程常用操作Overview版本控制系统Git 简介Git 基础安装 Git配置 Git创建 Git 仓库仓库版本控制log 查看提交历史撤消操作远程仓库tag打标签Git 命令别名Git 分支分支简介分支的新建与合并分支管理分支开发工作流远程分支变基服务器上的 Git - 协议协议在服务器上搭建 Git生成 SSH 公钥配置服务器GitLab服务器搭建过程分布式 Git分布式工作流程向一个项目贡献维护项目Git 命令设置与配置获取与创建项目快照基础分支与合并项目分享与更新检查与比较调试补丁邮件外部系统管理底层命令GitHubGitHub基本概念注册账户配置githubSSH 访问在 Git 中缓存 GitHub 密码github创建仓库github仓储添加文件对项目做出贡献issue派生（Fork）项目维护项目管理组织脚本 GitHubGithub Pages 搭建网站REFERENCESgit & GitHub教程 git中文官方文档 GitHub中文官方帮助 [TOC] 常用操作 Overview 版本控制系统 Git 简介 Git 基础 安装 Git 配置 Git 创建 Git 仓库 仓库版本控制 log 查看提交历史 撤消操作 远程仓库 tag打标签 Git 命令别名 Git 分支 分支简介 分支的新建与合并 分支管理 分支开发工作流 远程分支 变基 服务器上的 Git - 协议 协议 在服务器上搭建 Git 生成 SSH 公钥 配置服务器 GitLab服务器搭建过程 分布式 Git 分布式工作流程 向一个项目贡献 维护项目 Git 命令 设置与配置 获取与创建项目 快照基础 分支与合并 项目分享与更新 检查与比较 调试 补丁 邮件 外部系统 管理 底层命令 GitHub GitHub基本概念 注册账户 配置github SSH 访问 在 Git 中缓存 GitHub 密码 github创建仓库 github仓储添加文件 对项目做出贡献 issue 派生（Fork）项目 维护项目 管理组织 脚本 GitHub Github Pages 搭建网站 REFERENCES 常用操作 本地库初始化 git init # 初始化.git 设置签名 # 系统用户级(全局):登录当前操作系统的用户范围 git config --global user.name tome_glb # 用户名 git config --global user.email goodMorning@qq.com # 邮箱 # 项目级别/仓库级别:仅在当前本地库范围内有效 git config user.name tome_proj git config user.email goodMorning_proj@qq.com 检查配置信息 git config --list 状态查看 git status # 查看工作区、暂存区状态 添加追踪/暂存 git add [file_name] # 将工作区的“新建/修改”添加到暂存区 提交 git commit -m \"commit message\" [file_name] # 将暂存区的内容提交到本地库 查看历史记录 git log git log --pretty=oneline git log --oneline git reflog 版本前进后退 git reset --hard [log索引值] # 切换到指定版本,hard三个区域都切换 删除文件并找回 git reset --hard [log索引值/HEAD] # 版本回退 # 删除操作已经提交到本地库:指向历史记录 # 删除操作尚未提交到本地库:指向 HEAD 比较文件差异 git diff [文件名] # 将工作区中的文件和暂存区进行比较 git diff [log索引值] [文件名] # 将工作区中的文件和本地库log历史记录比较 git diff # 比较多个文件 创建分支 git branch [分支名] # 创建分支 查看分支 git branch -v # 查看分支 切换分支 git checkout [分支名] # 切换分支 新建并切换分支 git checkout -b [分支名] # 新建并切换分支 合并分支 git checkout [吞并其他的分支名] # 切换到准备吞并其他分支的分支 git merge [被吞并分支名] # merge合并 解决合并时冲突 vim [冲突文件名] # 编辑文件,删除特殊符号 >master git add [冲突文件名] # 添加文件到暂存区 git commit -m \"日志信息\" # 提交更新,注意:此时 commit 一定不能带具体文件名 查看远程仓储库 git remote -v # 查看当前所有远程仓储库别名 git remote show [远程别名] # 查看远程分支的更多信息 添加远程仓储库 git remote add [远程别名] [远程地址https] # 别名 推送到远程 首次本地推送到远程,必须是新建的空仓储库(仓储名字可以不一致)?? 使用 git push 将本地分支上的提交推送到远程仓库。 git push 命令使用两个参数： 远程命令，如 origin 分支名称，如 master git push git push origin master # 推送本地更改到在线仓库master分支 git push [远程别名] [同名分支名] # 将本地的 分支推送到远程仓库上的 同名 分支？？ 重命名分支 将本地分支推送到远程不同名分支上（相当于重命名分支） git push : git push [远程别名] [本地branch]:[远程remotebranch] # 将本地的[本地branch]分支推送到远程仓库的[远程remotebranch]分支 推送标记 默认情况下，没有其他参数时，git push 会发送所有名称与远程分支相同的匹配分支。 要推送单一标记，可以发出与推送分支相同的命令： git push 要推送所有标记，可以输入命令： git push --tags 删除远程分支或标记 git push : 请注意，冒号前有一个空格。 命令与重命名分支的步骤类似。 但这里是告诉 Git 不要推送任何内容到 REMOTENAME 上的 BRANCHNAME。 因此，git push 会删除远程仓库上的分支。 克隆仓储库 git clone [远程地址] # 克隆远程仓储库 完整的把远程库下载到本地,默认创建 origin 为远程地址别名,默认分支origin/master 仅抓取远程数据 git fetch [远程库别名] [远程分支] # 仅从远程指定分支,而不合并 git fetch [别名] # 仅从远程抓取本地没有的数据,而不合并?? 拉取远程库 git pull [远程库别名] [远程分支] # 从服务器上指定分支数据,然后合并支。 git pull # 从服务器上抓取所跟踪的服务器与分支数据然后合并入那个远程分支。 pull= fetch + merge 删除远程分支 git push [远程库别名] --delete [远程分支] # 删除一个远程服务器的分支 移除远程仓库 git remote rm [远程库别名] # 移除一个远程仓库 重命名远程仓库 git remote rename [远程库别名] [新别名] # 修改一个远程仓库的简写名 跟踪分支 从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 git checkout -b [branch] [remotename]/[branch]等效于git checkout --track [remotename]/[branch]新建本地分支[branch](可以重命名,忽略为默认master)并自动跟踪远程分支[remotename]/[branch] git checkout --track origin/serverfix git checkout -b [branch] [remotename]/[branch] # 新建分支并追踪 git branch -u /设置当前已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支,你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。 $ git branch -u origin/serverfix # 设置当前分支跟踪远程 查看设置的所有跟踪分支，可以使用 git branch -vv ,这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。 git branch -vv Overview 版本控制系统 版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况得系统。 版本控制系统 VCS (Version Control System)具体功能： 记录文件的所有历史变化 随时可恢复到任何一个历史状态 多人协作开发或修改 错误恢复 1. 本地版本控制系统 2. 集中化的版本控制系统 CVCS (Centralized Version Control System) CVS(老) , SVN (Subversion开源) , VSS (Visual Source Safe微软) , ClearCase(IBM收费)以及 Perforce 3. 分布式版本控制系统 DVCS (Distributed Version Control System) Git、Mercurial、Bazaar 以及 Darcs Git 简介 Git是一款免费、开源的分布式版本控制系统 Git可以有效、高速的处理从很小到非常大的项目版本管理。 Git最初由 Linux 之父 Linus Trovalds（林纳斯·托瓦兹） 开发，用作Linux内核代码的管理。 Git原理 直接记录快照，而非差异比较 Git 有三种状态 Git 有三种状态，你的文件可能处于其中之一：已修改（modified）、已暂存（staged）已提交和（committed）。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全的保存在本地数据库中。 Git 三个工作区域 Git 项目的三个工作区域的概念：工作目录、暂存区域以及Git 仓库。 工作区（Working Directory）：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你添加、编辑、修改文件等。 暂存区域：暂存已经修改的文件最后统一提交到Git仓库中。是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 Git 仓库：最终确定的文件保存到仓库，成为一个新的版本，并对他人可见。是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 本地库和远程库 Git远程仓库 团队内部协作 跨团队协作 Git 基础 安装 Git 在 Ubuntu 上安装 sudo apt-get install git 配置 Git 设置用户名 git config --global user.name 'John Doe' 设置用户邮箱 git config --global user.email johndoe@example.com 配置文本编辑器(可省) 配置默认文本编辑器,如果未配置，Git 会使用操作系统默认的文本编辑器. git config --global core.editor vim 查看配置 git config --list 创建 Git 仓库 有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。 - 初始化本地仓库 如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入： cd 项目目录 git init # 初始化本地仓库 会在项目目录下创建一个名为 .git 的隐藏子目录 - 克隆服务器的仓库 克隆服务器仓库到当前文件目录下 git clone [url] git clone https://github.com/libgit2/libgit2 在克隆远程仓库的时候，自定义本地仓库的名字（重命名） git clone https://github.com/libgit2/libgit2 mylibgit_renamed 仓库版本控制 status 当前状态 git status 当前状态简览 git status -s 状态简览 git status --short 状态简览 A新添加到暂存区中的文件前面有 M 修改过的文件前面有 ??新添加的未跟踪文件前面有 add 添加追踪新文件 git add 对指定文件的追踪 git add test.py git add --all # 添加追踪所有未追踪的文件 add 暂存已修改文件 将编辑过的文件添加到暂存区 git add test.py git add . # 暂存当前目录所有的文件，未跟踪的加入跟踪，同--all git add --all # 暂存所有修改 git add -u # 更新跟踪的文件，不管未跟踪的 u：--update update tracked files -A： --all add changes from all tracked and untracked files 已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来. .gitignore忽略追踪的文件 创建一个名为 .gitignore 的文件，列出要忽略的文件模式 touch .gitignore # 创建.gitignore文件 dedit .gitignore # 编辑.gitignore文件 # ignore all .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf 对于无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等 .gitignore只能忽略原来未被跟踪的文件，因此跟踪过的文件是无法被忽略的。 因此在github上可以看到之前跟踪的需忽略文件的存在。 解决方法就是先把本地缓存删除（改变成未track状态），然后再提交: git rm -r --cached . # 删除git跟踪而保留本地文件 git add . # 重新跟踪所有文件 git commit -m 'update .gitignore' # 重新提交 git push # 更新github git log --pretty=oneline原来的git log 仍然存在 shell 所使用的简化了的正则表达式:星号（*）匹配零个或多个任意字符；问号（?）只匹配一个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 diff 查看差异 查看修改之后还没有add暂存起来内容。（比较工作区和仓库差异） git diff # 比较工作区和仓库差异 查看已暂存的将要添加到下次提交里的内容。（比较暂存区和仓库差异） git diff --staged git diff --cached # 或者 commit 提交到仓库 提交暂存区的文件到仓库,提交说明是必须的，如果没有则会启动文本编辑器 (默认nano)以便输入本次提交的说明,Ctrl+S保存。 #git commit # 没有-m提交说明则会进入vim添加说明 git commit -m \"-m选项,提交说明信息\" 每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit 请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 跳过使用暂存区域，直接全部提交 跳过使用暂存区域的方式，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 git commit -a -m 'added new benchmarks' #git commit -a # 所有已经跟踪过的文件暂存起来一并提交 rm 移除文件 从已跟踪文件清单中移除,并且删除本地文件 git rm README.md # 删除本地文件和仓储文件,且不再追踪 git rm -f README.md # 强制删除 --cached 保留本地磁盘，但是并不想让 Git 继续跟踪 -f强制删除 git rm --cached README.md # 保留本地磁盘文件，但是不继续跟踪 git rm -f --cached README.md # 强制删除,保留本地磁盘文件，但是不继续跟踪 mv 移动文件/重命名 git mv old_filename new_filename # 重命名 log 查看提交历史 log 提交历史日志 git log git log --oneline git log --pretty=oneline git log --graph git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 -p按补丁格式显示每个更新之间的差异。 --stat显示每次更新的文件修改统计信息。 --shortstat只显示 --stat 中最后的行数修改添加移除统计。 --name-only仅在提交信息后显示已修改的文件清单。 --name-status显示新增、修改、删除的文件清单。 --abbrev-commit仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 --relative-date使用较短的相对时间显示（比如，“2 weeks ago”）。 --graph显示 ASCII 图形表示的分支合并历史。 --pretty使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 筛选提交历史日志 git log -3 # 仅显示最近的3条提交 -(n)仅显示最近的 n 条提交 --since, --after仅显示指定时间之后的提交。 --until, --before仅显示指定时间之前的提交。 --author仅显示指定作者相关的提交。 --committer仅显示指定提交者相关的提交。 --grep仅显示含指定关键字的提交 -S仅显示添加或移除了某个关键字的提交 git log --oneline --decorate # 查看各个分支当前所指的对象 git log --oneline --decorate --graph --all # 输出你的提交历史、各个分支的指向以及项目的分支分叉情况 git log --oneline --decorate --graph --all 输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 撤消操作 撤消对工作区的修改 本地工作区修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。 撤消对工作区单个文件/文件夹的修改： $ git checkout -- readme.md # 撤销单个文件修改 # ?? $ git checkout -- src # 单个文件夹?? 撤消对工作区所有文件/文件夹的修改： $ git checkout -- . # 撤销所有修改 $ git checkout . 本地工作区新增了一堆文件(并没有git add到暂存区)，想放弃新增的文件，直接删除。 删除工作区单个文件/文件夹： $ rm filename $ rm -r dir 删除工作区所有文件/文件夹： $ git clean -xdf -df 删除 文件 和 目录 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除! 取消暂存的文件 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。 git reset --mixed(默认) HEAD当前头指针 撤销暂存的单个文件/文件夹： $ git reset HEAD readme.md # 撤销单个文件暂存 # ?? $ git reset HEAD src # 单个文件夹?? 撤销暂存的所有文件/文件夹： $ git reset HEAD . # 撤销所有暂存 撤销暂存及修改回到上次提交时的状态： 如果你现在的工作目录(work tree)里搞的一团乱麻, 但是你现在还没有把它们提交; 你可以通过下面的命令, 让工作目录回到上次提交时的状态(last committed state): git reset --hard HEAD 这条命令会把你工作目录中所有未提交的内容清空(当然这不包括未置于版控制下的文件 untracked files) reset撤销提交 本地通过git add & git commit 之后，想要撤销此次commit reset三种模式: --hard --soft --mixed(默认) reset --hard： 重置stage区和工作目录 reset --hard 会在重置 HEAD 和branch的同时，重置stage区和工作目录里的内容。当你在 reset 后面加了 --hard 参数时，你的stage区和工作目录里的内容会被完全重置为和HEAD的新位置相同的内容。换句话说，就是你的没有commit的修改会被全部擦掉。 $ git reset --hard commit_id # 返回到某个节点，修改会被全部擦掉。 // 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码也将会清除！ reset --soft： 保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区 reset --soft 会在重置 HEAD 和 branch 时，保留工作目录和暂存区中的内容，并把重置 HEAD 所带来的新的差异放进暂存区。 此模式下会保留 working tree工作目录的內容，不会改变到目前所有的git管理的文件夹的內容；也会 保留 index暂存区的內容，让 index 暂存区与 working tree 工作目录的內容是一致的。就只有 repository 中的內容的更变需要与 reset 目标节点一致，因此原始节点与reset节点之间的差异变更集合会存在与index暂存区中(Staged files)，所以我们可以直接执行 git commit 將 index暂存区中的內容提交至 repository 中。当我们想合并「当前节点」与「reset目标节点」之间不具太大意义的 commit 记录(可能是阶段性地频繁提交)時，可以考虑使用 Soft Reset 来让 commit 演进线图较为清晰点。 --soft 和 --hard 的区别：--hard 会清空工作目录和暂存区的改动，而 --soft则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。 $ gitreset --soft commit_id # 返回到某个节点。保留修改 这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 // 撤销之后，你所做的已经commit的修改还在工作区！ reset --mixed： reset 不加参数(默认mixed) 保留工作目录，并清空暂存区 reset 如果不加参数，那么默认使用 --mixed 参数。它的行为是：保留工作目录，并且清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（mixed）放在工作目录中」。 $ gitreset --mixed commit_id # 返回到某个节点。保留修改 reset三种模式区别： --hard：重置位置的同时，直接将 working Tree工作目录、 index 暂存区及 repository 都重置成目标Reset节点的內容,所以效果看起来等同于清空暂存区和工作区。 --soft：重置位置的同时，保留working Tree工作目录和index暂存区的内容，只让repository中的内容和 reset 目标节点保持一致，因此原节点和reset节点之间的【差异变更集】会放入index暂存区中(Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和Reset节点之间的所有差异都会放到暂存区中。 --mixed（默认）：重置位置的同时，只保留Working Tree工作目录的內容，但会将 Index暂存区 和 Repository 中的內容更改和reset目标节点一致，因此原节点和Reset节点之间的【差异变更集】会放入Working Tree工作目录中。所以效果看起来就是原节点和Reset节点之间的所有差异都会放到工作目录中。 reset三种模式使用场景: --hard：(1) 要放弃目前本地的所有改变時，即去掉所有add到暂存区的文件和工作区的文件，可以执行 git reset -hard HEAD 来强制恢复git管理的文件夹的內容及状态；(2) 真的想抛弃目标节点后的所有commit（可能觉得目标节点到原节点之间的commit提交都是错了，之前所有的commit有问题）。 --soft：原节点和reset节点之间的【差异变更集】会放入index暂存区中(Staged files)，所以假如我们之前工作目录没有改过任何文件，也没add到暂存区，那么使用reset --soft后，我们可以直接执行 git commit 將 index暂存区中的內容提交至 repository 中。为什么要这样呢？这样做的使用场景是：假如我们想合并「当前节点」与「reset目标节点」之间不具太大意义的 commit 记录(可能是阶段性地频繁提交,就是开发一个功能的时候，改或者增加一个文件的时候就commit，这样做导致一个完整的功能可能会好多个commit点，这时假如你需要把这些commit整合成一个commit的时候)時，可以考虑使用reset --soft来让 commit 演进线图较为清晰。总而言之，可以使用--soft合并commit节点。 --mixed（默认）：(1)使用完reset --mixed后，我們可以直接执行 git add 将這些改变果的文件內容加入 index 暂存区中，再执行 git commit 将 Index暂存区 中的內容提交至Repository中，这样一样可以达到合并commit节点的效果（与上面--soft合并commit节点差不多，只是多了git add添加到暂存区的操作）；(2)移除所有Index暂存区中准备要提交的文件(Staged files)，我们可以执行 git reset HEAD 来 Unstage 所有已列入 Index暂存区 的待提交的文件。(有时候发现add错文件到暂存区，就可以使用命令)。(3)commit提交某些错误代码，或者没有必要的文件也被commit上去，不想再修改错误再commit（因为会留下一个错误commit点），可以回退到正确的commit点上，然后所有原节点和reset节点之间差异会返回工作目录，假如有个没必要的文件的话就可以直接删除了，再commit上去就OK了。 revert 创建新提交来修复错误 创建一个新的，撤消(revert)了前期修改的提交(commit) 撤消最近的一个提交: $ git revert HEAD 这样就创建了一个撤消了上次提交(HEAD)的新提交, 你就有机会来修改新提交(new commit)里的提交注释信息. 你也可撤消更早期的修改, 下面这条命令就是撤消“上上次”(next-to-last)的提交: $ git revert HEAD^ 在这种情况下,git尝试去撤消老的提交,然后留下完整的老提交前的版本.　如果你最近的修改和要撤消的修改有重叠(overlap),那么就会被要求手工解决冲突(conflicts),　就像解决合并(merge)时出现的冲突一样. 译者注: git revert 其实不会直接创建一个提交(commit), 把撤消后的文件内容放到索引(index)里,你需要再执行git commit命令，它们才会成为真正的提交(commit). amend重新提交 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交： git commit --amend将暂存区中的文件提交,覆盖原来的提交信息。 $ git commit --amend # 修改上次提交 远程仓库 查看远程仓库 如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 origin 是 Git 给你clone克隆的仓库服务器的默认名字 git remote -v # 查看远程仓库 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 git remote show [remote-name] 查看某一个远程仓库的更多信息 git remote show origin # 查看远程仓库详细信息 添加远程仓库 git remote add 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写,可以在命令行中使用简写来代替整个 URL git remote add 添加远程仓库命令使用两个参数： 远程命令，如 origin 远程 URL，如 https://github.com/user/repo.git git remote add origin https://github.com/user/repo.git # 添加远程仓库 git remote add ThisIsShortName https://github.com/user/repo.git # 添加远程仓库 从远程仓库中抓取与拉取 git fetch [remote-name]访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 git fetch [remote-name] 从远程仓库中抓取并合并 git pull git pull --rebase=true # ?? git fetch命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库 git push [remote-name] [branch-name]。当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器： git push git push origin master git push origin master --allow-unrelated-histories # 推送两个部相关的仓储 解决git push错误The requested URL returned error: 403 Forbidden while accessing 原因：私有项目，没有权限，输入用户名密码，或者远程地址采用这种类型。 解决办法：vi .git/config 将 [remote \"origin\"]url = https://github.com/用户名/仓库名.git修改为： [remote \"origin\"]url = https://**用户名:密码@**github.com/用户名/仓库名.git 解决git push错误 Error merging: refusing to merge unrelated histories 原因：两个仓库有不同的开始点，也就是两个仓库没有共同的 commit 出现的无法提交。 解决办法：添加 --allow-unrelated-histories 告诉 git 允许不相关历史合并,git merge master --allow-unrelated-histories , git push origin master --allow-unrelated-histories 更改远程仓库的 URL git remote set-url 命令可更改现有远程仓库的 URL。 HTTPS和SSH都可以 git remote set-url # HTTPS git remote set-url origin https://github.com/USERNAME/REPOSITORY.git # SSH git remote set-url origin git@github.com:USERNAME/REPOSITORY.git 将远程 URL 从HTTPS切换到 SSH 列出现有远程仓库以获取要更改的远程仓库的名称 git remote -v origin https://github.com/USERNAME/REPOSITORY.git (fetch) origin https://github.com/USERNAME/REPOSITORY.git (push) 使用 git remote set-url 命令将远程的 URL 从 HTTPS 更改为 SSH。 git remote set-url origin git@github.com:USERNAME/REPOSITORY.git 验证远程 URL 是否已更改。 git remote -v ``#Verify new remote URL origin git@github.com:USERNAME/REPOSITORY.git (fetch) origin git@github.com:USERNAME/REPOSITORY.git (push) 将远程 URL 从SSH切换到 HTTPS 同理 重命名远程仓库 git remote rename [remote-name] 去修改一个远程仓库的简写名 git remote rename 重命名远程仓库命令使用两个参数： 现有的远程名称，例如 origin 远程的新名称，例如 destination git remote rename OldNameremote NewNameremote 示例 查看现有远程 git remote -v origin https://github.com/OWNER/REPOSITORY.git (fetch) origin https://github.com/OWNER/REPOSITORY.git (push) 将远程名称从 'origin' 更改为 'destination' git remote rename origin destination 验证远程的新名称 git remote -v destination https://github.com/OWNER/REPOSITORY.git (fetch) destination https://github.com/OWNER/REPOSITORY.git (push) 删除远程仓库 git remote rm [remote-name]移除一个远程仓库， git remote rm 删除远程命令使用一个参数： 远程名称，例如 destination git remote rm Deletedremote 注：git remote rm 不会从服务器中删除远程仓库。 它只是从本地仓库中删除远程及其引用。 示例 # 查看当前远程 git remote -v > origin https://github.com/OWNER/REPOSITORY.git (fetch) > origin https://github.com/OWNER/REPOSITORY.git (push) > destination https://github.com/FORKER/REPOSITORY.git (fetch) > destination https://github.com/FORKER/REPOSITORY.git (push) # 删除远程 git remote rm destination # 验证其已删除 git remote -v > origin https://github.com/OWNER/REPOSITORY.git (fetch) > origin https://github.com/OWNER/REPOSITORY.git (push) tag打标签 Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 列出标签 git tag # 显示已有标签 git tag -l 'v1.*' # 过滤显示 这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。 $ git tag v1.0.0 v1.3.0 v2.5.0 使用特定的模式查找标签 $ git tag -l 'v1.*' v1.0.0 v1.3.0 查看标签详细信息 git show v1.4 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 $ git show v1.4 tag v1.4 Tagger: Ben Straub ben@straub.cc Date: Sat May 3 20:19:12 2014 -0700 my version 1.4 commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon schacon@gee-mail.com Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 创建标签 Git 使用两种主要类型的标签：附注标签（annotated）与轻量标签（lightweight）。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 附注标签 附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签 git tag -a -m git tag -a v1.4 -m 'my version 1.4' -a add创建一个附注标签 -m message选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。 通过使用 git show 命令可以看到标签信息与对应的提交信息 轻量标签(不推荐) 一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 git tag 只需要提供标签名字,不需要使用选项，只需要提供标签名字 git tag v1.5lightweight 后期打标签 对过去的提交打标签 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和） git log --oneline # 查询提交历史 #git tag -a git tag -a v1.4 -m 'myVersion1.4' 8a5cbc43 # 对历史打标签 推送标签 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 git push origin [tagname] git push origin v1.5 # 推送指定标签 git push origin --tags # 推送所有标签 --tags 把所有不在远程仓库服务器上的标签全部传送到那里。 删除标签 仅删除掉本地仓库上的标签，并不会从任何远程仓库中移除这个标签 git tag -d v1.4 # 仅删除本地标签 删除远程仓库的标签 git push origin :refs/tags/v1.4 # 删除远程仓库的标签 检出标签 如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令，虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态——这个状态有些不好的副作用： git checkout v2.0.0 # 不要修改提交 在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支 # git checkout -b version2 v2.0.0 # 非改不可，在标签处新建分支 Git 命令别名 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status git config --global alias.last 'log -1 HEAD' Git 分支 分支简介 创建分支 git branch 仅创建 一个新分支，并不会自动切换到新分支中去。 git branch testing # 创建分支 切换分支 切换到一个已存在的分支，你需要使用 git checkout 命令。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。 git checkout testing 查看各分支当前所指的对象 git log --oneline --decorate查看各个分支当前所指的对象 git log --oneline --decorate 查看分支情况 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 git log --oneline --decorate --graph --all 分支的新建与合并 新建分支并切换 git checkout -b 新建分支并同时切换到那个分支上 git checkout -b branchiss53 # 新建分支并切换 # 等效于下面两条命令 # git branch branchiss53 # 新建分支 # git checkout branchiss53 # 切换分支 分支的合并 合并 iss53 分支到 master 分支 检出checkout到你想合并入的分支， git merge git checkout master git merge iss53 # 当前所在分支吞并 iss53 分支 已经被合并的分支可以删除git branch -d git branch -d iss53 遇到冲突时的分支合并 分支管理 显示所有分支名 git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 git branch # 显示所有分支名 查看所有分支的最后一次提交 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令： git branch -v # 显示所有分支名及最后一次提交 已经合并到当前分支 --merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged：在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。 git branch --merged # 显示已经合并过的分支 未合并工作的分支 查看所有包含未合并工作的分支，可以运行 git branch --no-merged：这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败：如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 -D 选项强制删除它。 git branch --no-merged # 显示未合并的分支 分支开发工作流 长期分支 特性分支 远程分支 git ls-remote 来显式地获得远程引用的完整列表 git remote show 获得远程分支的更多信息 远程跟踪分支是远程分支状态的引用。远程分支 / 形式命名,默认 origin/master 分支 git remote -v # 显示远程仓储 git ls-remote # 获得远程引用的完整列表 git remote show # 显示远程分支详细信息 ➜ git-github-tutorial git:(master) ✗ git remote -v origin git@github.com:robotchaoX/git-github-tutorial.git (fetch) origin git@github.com:robotchaoX/git-github-tutorial.git (push) ➜ git-github-tutorial git:(master) ✗ git ls-remote origin0f0bd97982f93c5e359fe04b1aaf38684b925ab7 HEAD 0f0bd97982f93c5e359fe04b1aaf38684b925ab7 refs/heads/master ➜ git-github-tutorial git:(master) ✗ git remote show origin remote origin Fetch URL: git@github.com:robotchaoX/git-github-tutorial.git Push URL: git@github.com:robotchaoX/git-github-tutorial.git HEAD branch: master Remote branch: master tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 抓取远程数据 git fetch 从远程抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针指向新的、更新后的位置。 git fetch 推送 git push 将本地的 分支推送到远程仓库上的 分支。 git push : 将本地的 分支推送到远程仓库上的 分支。 git push 跟踪分支 从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 git checkout --track /等效于git checkout -b /设置本地分支跟踪远程分支/ git checkout --track origin/serverfix git branch -u /设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支 查看设置的所有跟踪分支，可以使用 git branch -vv git branch -vv # 查看所有跟踪的分支 ➜ forage-harvester git:(mutlithreads) git branch -vv TY-percipio eb7947c [origin/TY-percipio] add Qt source files joint compilation master f7b79f1 [origin/master] redesign Qt display interface. * mutlithreads 17838aa update Qt display interface. 拉取 当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。git pull= git fetch + git merge git pull 删除远程分支 git push --delete 删除一个远程服务器的分支 git push origin --delete master 变基 在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 开发任务分叉到两个不同分支，又各自提交了更新 merge合并 之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。 rebase变基合并 对分叉到两个不同分支，又各自提交了更新进行合并 变基:可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。 git checkout experiment # 当前分支修改变基到master之后 git rebase master # 将 C4 中的修改变基到 C3 上 First, rewinding head to replay your work on top of it... Applying: added staged command 它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同） 合并:回到 master 分支，进行一次快进合并。 git checkout master # 回到master合并 git merge experiment # master 分支的快进合并 此时，C4' 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 变基使得提交历史更加整洁 跨支变基合并 在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个特性分支里再分出一个特性分支的提交历史 中的例子那样。 你创建了一个特性分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了特性分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。 假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 git rebase 命令的 --onto 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放： git rebase --onto master server client 以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。 现在可以快进合并 master 分支了。 git checkout master git merge client 接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。 git rebase master server 如下图所示，server 中的代码被“续”到了 master 后面。 然后就可以快进合并主分支 master 了： git checkout master # 切换到master git merge server # master吞并server 至此，client 和 server 分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成下图中的样子： git branch -d client # 删除多余分支 git branch -d server 变基的风险 不要对在你的仓库外有副本的分支执行变基。 服务器上的 Git - 协议 协议 Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。 本地协议（Local） HTTP 协议 SSH（Secure Shell）协议 Git 协议 在服务器上搭建 Git 把现有仓库导出为裸仓库 $ git clone --bare my_project my_project.git 把裸仓库放到服务器上 假设一个域名为 git.example.com 的服务器已经架设好，并可以通过 SSH 连接，你想把所有的 Git 仓库放在 /opt/git目录下。 假设服务器上存在 /opt/git/ 目录，你可以通过以下命令复制你的裸仓库来创建一个新仓库： $ scp -r my_project.git user@git.example.com:/opt/git 生成 SSH 公钥 $ ssh-keygen 默认情况下，用户的 SSH 密钥存储在其 ~/.ssh 目录下。我们需要寻找一对以 id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名。 .pub 文件是你的公钥，另一个则是私钥。 配置服务器 配置服务器 GitLab服务器搭建过程 GitLab官网 GitLab安装说明 分布式 Git 分布式工作流程 集中式工作流 集中式系统中通常使用的是单点协作模型——集中式工作流。 一个中心集线器，或者说仓库，可以接受代码，所有人将自己的工作与之同步。 若干个开发者则作为节点——也就是中心仓库的消费者——并且与其进行同步。 这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。 第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。 这和 Subversion （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。 集成管理者工作流 Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表`‘官方’'项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示 项目维护者推送到主仓库。 贡献者克隆此仓库，做出修改。 贡献者将数据推送到自己的公开仓库。 贡献者给维护者发送邮件，请求拉取自己的更新。 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。 维护者将合并后的修改推送到主仓库。 司令官与副官工作流 一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。 被称为副官（lieutenant）的各个集成管理者分别负责集成项目中的特定部分。 所有这些副官头上还有一位称为司令官（dictator）的总集成管理者负责统筹。 司令官维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。 整个流程看起来是这样的: 普通开发者在自己的特性分支上工作，并根据 master 分支进行变基。 这里是司令官的master分支。 副官将普通开发者的特性分支合并到自己的 master 分支中。 司令官将所有副官的 master 分支并入自己的 master 分支中。 司令官将集成后的 master 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。 向一个项目贡献 提交准则 git diff --check找到可能的空白错误并将它们为你列出来 git add --patch 部分暂存文件 git log --no-merges issue54..origin/master 日志过滤器,只显示所有在后面分支（在本例中是 origin/master）但不在前面分支（在本例中是 issue54）的提交的列表。 私有小型团队 集中式的系统,尽管 Subversion 会对编辑的不同文件在服务器上自动进行一次合并，但 Git 要求你在本地合并提交。 John 必须抓取 Jessica 的改动并合并它们，才能被允许推送。 私有管理团队 使用了一种整合-管理者工作流程，独立小组的工作只能被特定的工程师整合，主仓库的 master 分支只能被那些工程师更新。 在这种情况下，所有的工作都是在基于团队的分支上完成的并且稍后会被整合者拉到一起。 git push -u :将本地branch 分支推送到服务器上的 远程branch 分支 -u 标记；这是 --set-upstream 的简写，该标记会为之后轻松地推送与拉取配置分支。 git log featureA..origin/featureA日志过滤器,只显示新增的日志 fork派生的公开项目?? 首先，你可能想要克隆主仓库，为计划贡献的补丁或补丁序列创建一个特性分支，然后在那儿做工作。 git clone (url) cd project git checkout -b featureA # (work) git commit 当你的分支工作完成后准备将其贡献回维护者，去原始项目中然后点击 “Fork” 按钮，创建一份自己的可写的项目派生仓库。 然后需要添加这个新仓库 URL 为第二个远程仓库，在本例中称作 myfork： git remote add myfork (url) 推送工作到fork派生仓库上面。 git push -u myfork featureA 当工作已经被推送到你的派生后，你需要通知维护者。 这通常被称作一个拉取请求（pull request）request-pull 命令接受特性分支拉入的基础分支，以及它们拉入的 Git 仓库 URL，输出请求拉入的所有修改的总结。 git request-pull origin/master myfork git merge --squash featureB --squash 选项接受被合并的分支上的所有工作，并将其压缩至一个变更集，使仓库变成一个真正的合并发生的状态，而不会真的生成一个合并提交。 这意味着你的未来的提交将会只有一个父提交，并允许你引入另一个分支的所有改动，然后在记录一个新提交前做更多的改动。 通过邮件的公开项目 工作流程与之前的用例是类似的 - 你为工作的每一个补丁序列创建特性分支。 区别是如何提交它们到项目中。 生成每一个提交序列的电子邮件版本然后邮寄它们到开发者邮件列表，而不是派生项目然后推送到你自己的可写版本。 维护项目 在特性分支中工作 如果你想向项目中整合一些新东西，最好将这些尝试局限在特性分支——一种通常用来尝试新东西的临时分支中。 基于 master 分支建立特性分支： git branch master 基于 master 分支建立特性分支,同时立刻切换到新分支上: git checkout -b master 应用来自邮件的补丁 使用 apply 命令应用补丁 git apply --check 检查补丁是否可以顺利应用 git apply应用补丁,需要手动暂存并提交补丁所引入的更改 使用 am 命令应用补丁 git am应用补丁,并自动创建了一个新的提交 检出到远程分支 如果你的贡献者建立了自己的版本库，并且向其中推送了若干修改，之后将版本库的 URL 和包含更改的远程分支发送给你，那么你可以将其添加为一个远程分支，并且在本地进行合并。 $ git remote add jessica git://github.com/jessica/myproject.git # 添加远程 $ git fetch jessica # 获取远程 $ git checkout -b rubyclient jessica/ruby-client # 设置远程分支 git pull 执行一个一次性的抓取，而不会将该 URL 存为远程引用 $ git pull https://github.com/onetimeguy/project 确定引入了哪些东西 把 ... 置于另一个分支名后来对该分支的最新提交与两个分支的共同祖先进行比较 $ git diff master...issue32 仅会显示自当前特性分支与 master 分支的共同祖先起，该分支中的工作 将贡献的工作整合进来 合并工作流 当你完成某个特性分支的工作，或审核通过了其他人所贡献的工作时，你会将其合并进入 master 分支，之后将特性分支删除，如此反复。 大项目合并工作流 Git 项目包含四个长期分支：master、next，用于新工作的 pu（proposed updates）和用于维护性向后移植工作（maintenance backports）的 maint 分支。 变基与拣选工作流 为了保持线性的提交历史，有些维护者更喜欢在 master 分支上对贡献过来的工作进行变基和拣选，而不是直接将其合并。 当你完成了某个特性分支中的工作，并且决定要将其整合的时候，你可以在该分支中运行变基命令，在当前 master 分支（或者是 develop 等分支）的基础上重新构造修改。 Git 中的拣选类似于对特定的某次提交的变基。 它会提取该提交的补丁，之后尝试将其重新应用到当前分支上。 这种方式在你只想引入特性分支中的某个提交，或者特性分支中只有一个提交，而你不想运行变基时很有用。 $ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf Rerere Rerere 是“重用已记录的冲突解决方案（reuse recorded resolution）”的意思——它是一种简化冲突解决的方法。 当启用 rerere 时，Git 将会维护一些成功合并之前和之后的镜像，当 Git 发现之前已经修复过类似的冲突时，便会使用之前的修复方案，而不需要你的干预。 这个功能包含两个部分：一个配置选项和一个命令。 $ git config --global rerere.enabled true 现在每当你进行一次需要解决冲突的合并时，解决方案都会被记录在缓存中，以备之后使用。 为发布打标签 当你决定进行一次发布时，你可能想要留下一个标签，这样在之后的任何一个提交点都可以重新创建该发布。 $ git tag -s v1.5 -m 'my signed 1.5 tag' 如果你为标签签名了，你可能会遇到分发用来签名的 PGP 公钥的问题。 Git 项目的维护者已经解决了这一问题，其方法是在版本库中以 blob 对象的形式包含他们的公钥，并添加一个直接指向该内容的标签。 $ gpg --list-keys找出你所想要的 key 通过导出 key 并通过管道传递给 git hash-object 来直接将 key 导入到 Git 的数据库中，git hash-object 命令会向 Git 中写入一个包含其内容的新 blob 对象，并向你返回该 blob 对象的 SHA-1 值 $ gpg -a --export | git hash-object -w --stdin 通过指定由 hash-object 命令给出的新 SHA-1 值来创建一个直接指向它的标签 $ git tag -a maintainer-pgp-pub 如果你运行 git push --tags 命令，那么 maintainer-pgp-pub 标签将会被共享给所有人。 需要校验标签的人可以通过从数据库中直接拉取 blob 对象并导入到 GPG 中来导入 PGP key： $ git show maintainer-pgp-pub | gpg --import 人们可以使用这个 key 来校验所有由你签名的标签 生成一个构建号 如果你想要为提交附上一个可读的名称，可以对其运行 git describe 命令。 Git 将会给出一个字符串，它由最近的标签名、自该标签之后的提交数目和你所描述的提交的部分 SHA-1 值构成： $ git describe master 准备一次发布 本次发布的一个 tar 包,项目文件夹的最新快照 $ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz 本次发布的一个 zip 包 $ git archive master --prefix='project/' --format=zip > `git describe master`.zip 制作提交简报 使用 git shortlog 命令可以快速生成一份包含从上次发布之后项目新增内容的修改日志（changelog）类文档。 它会对你给定范围内的所有提交进行总结；比如，你的上一次发布名称是 v1.0.1，那么下面的命令可以给出上次发布以来所有提交的总结： $ git shortlog --no-merges master --not v1.0.1 这份整洁的总结包括了自 v1.0.1 以来的所有提交，并且已经按照作者分好组 Git 命令 设置与配置 git config Git 做的很多工作都有一个默认方式。 这些设置涵盖了所有的事，从告诉 Git 你的名字，到指定偏好的终端颜色，以及你使用的编辑器。 此命令会从几个特定的配置文件中读取和写入配置值，以便你可以从全局或者针对特定的仓库来进行设置。 本书的所有章节几乎都有用到 git config 命令。 在 初次运行 Git 前的配置 一节中，在开始使用 Git 之前，我们用它来指定我们的名字，邮箱地址和编辑器偏好。 在 Git 别名 一节中我们展示了如何创建可以展开为长选项序列的短命令，以便你不用每次都输入它们。 在 变基 一节中，执行 git pull 命令时，使用此命令来将 --rebase 作为默认选项。 在 凭证存储 一节中，我们使用它来为你的 HTTP 密码设置一个默认的存储区域。 在 关键字展开 一节中我们展示了如何设置在 Git 的内容添加和减少时使用的 smudge 过滤器 和 clean 过滤器。 最后，基本上 配置 Git 整个章节都是针对此命令的。 git help git help 命令用来显示任何命令的 Git 自带文档。 但是我们仅会在此附录中提到大部分最常用的命令，对于每一个命令的完整的可选项及标志列表，你可以随时运行 git help 命令来了解。 我们在 获取帮助 一节中介绍了 git help 命令，同时在 配置服务器 一节中给你展示了如何使用它来查找更多关于 git shell 的信息。 获取与创建项目 有几种方式获取一个 Git 仓库。 一种是从网络上或者其他地方拷贝一个现有的仓库，另一种就是在一个目录中创建一个新的仓库。 git init 你只需要简单地运行 git init 就可以将一个目录转变成一个 Git 仓库，这样你就可以开始对它进行版本管理了。 我们一开始在 获取 Git 仓库 一节中介绍了如何创建一个新的仓库来开始工作。 在 远程分支 一节中我们简单的讨论了如何改变默认分支。 在 把裸仓库放到服务器上 一节中我们使用此命令来为一个服务器创建一个空的祼仓库。 最后，我们在 底层命令和高层命令 一节中介绍了此命令背后工作的原理的一些细节。 git clone git clone 实际上是一个封装了其他几个命令的命令。 它创建了一个新目录，切换到新的目录，然后 git init 来初始化一个空的 Git 仓库， 然后为你指定的 URL 添加一个（默认名称为 origin 的）远程仓库（git remote add），再针对远程仓库执行 git fetch，最后通过 git checkout 将远程仓库的最新提交检出到本地的工作目录。 git clone 命令在本书中多次用到，这里只列举几个有意思的地方。 在 克隆现有的仓库 一节中我们通过几个示例详细介绍了此命令。 在 在服务器上搭建 Git 一节中，我们使用了 --bare 选项来创建一个没有任何工作目录的 Git 仓库副本。 在 打包 一节中我们使用它来解包一个打包好的 Git 仓库。 最后，在 克隆含有子模块的项目 一节中我们学习了使用 --recursive 选项来让克隆一个带有子模块的仓库变得简单。 快照基础 对于基本的暂存内容及提交到你的历史记录中的工作流，只有少数基本的命令。 git add git add 命令将内容从工作目录添加到暂存区（或称为索引（index）区），以备下次提交。 当 git commit 命令执行时，默认情况下它只会检查暂存区域，因此 git add 是用来确定下一次提交时快照的样子的。 这个命令对于 Git 来说特别的重要，所以在本书中被无数次的提及和使用。 我们将快速的过一遍一些可以看到的独特的用法。 我们在 跟踪新文件 一节中介绍并详细解释了 git add 命令。 然后，我们在 遇到冲突时的分支合并 一节中提到了如何使用它来解决合并冲突。 接下来，我们在 交互式暂存 一章中使用它来交互式的暂存一个已修改文件的特定部分。 最后，在 树对象 一节中我们在一个低层次中模拟了它的用法，以便你可以了解在这背后发生了什么。 git status git status 命令将为你展示工作区及暂存区域中不同状态的文件。 这其中包含了已修改但未暂存，或已经暂存但没有提交的文件。 一般在它显示形式中，会给你展示一些关于如何在这些暂存区域之间移动文件的提示。 首先，我们在 检查当前文件状态 一节中介绍了 status 的基本及简单的形式。 虽然我们在全书中都有用到它，但是绝大部分的你能用 git status 做的事情都在这一章讲到了。 git diff 当需要查看任意两棵树的差异时你可以使用 git diff 命令。 此命令可以查看你工作区与你的暂存区的差异（git diff 默认的做法），你暂存区域与你最后提交之间的差异（git diff --staged），或者比较两个提交记录的差异（git diff master branchB）。 首先，我们在 查看已暂存和未暂存的修改 一章中研究了 git diff 的基本用法，在此节中我们展示了如何查看哪些变化已经暂存了，哪些没有。 在 提交准则 一节中,我们在提交前使用 --check 选项来检查可能存在的空白字符问题。 在 确定引入了哪些东西 一节中,了解了使用 git diff A...B 语法来更有效地比较不同分支之间的差异。 在 高级合并 一节中我们使用 -b 选项来过滤掉空白字符的差异，及通过 --theirs、--ours 和 --base选项来比较不同暂存区冲突文件的差异。 最后，在 开始使用子模块 一节中,我们使用此命令合 --submodule 选项来有效地比较子模块的变化。 git difftool 当你不想使用内置的 git diff 命令时。git difftool 可以用来简单地启动一个外部工具来为你展示两棵树之间的差异。 我们只在 查看已暂存和未暂存的修改 一节中简单的提到了此命令。 git commit git commit 将所有通过 git add 暂存的文件内容在数据库中创建一个持久的快照，然后将当前分支上的分支指针移到其之上。 首先，我们在 提交更新 一节中涉及了此命令的基本用法。 我们演示了如何在日常的工作流程中通过使用 -a 标志来跳过 git add 这一步，及如何使用 -m 标志通过命令行而不启动一个编辑器来传递提交信息。 在 撤消操作 一节中我们介绍了使用 --amend 选项来重做最后的提交。 在 分支简介，我们探讨了 git commit 的更多细节，及工作原理。 在 签署提交 一节中我们探讨了如何使用 -S 标志来为提交签名加密。 最后，在 提交对象 一节中，我们了解了 git commit 在背后做了什么，及它是如何实现的。 git reset git reset 命令主要用来根据你传递给动作的参数来执行撤销操作。 它可以移动 HEAD 指针并且可选的改变 index 或者暂存区，如果你使用 --hard 参数的话你甚至可以改变工作区。 如果错误地为这个命令附加后面的参数，你可能会丢失你的工作，所以在使用前你要确定你已经完全理解了它。 首先，我们在 取消暂存的文件 一节中介绍了 git reset 简单高效的用法，用来对执行过 git add 命令的文件取消暂存。 在 重置揭密 一节中我们详细介绍了此命令，几乎整节都在解释此命令。 在 中断一次合并 一节中，我们使用 git reset --hard 来取消一个合并，同时我们也使用了 git merge --abort 命令，它是 git reset 的一个简单的封装。 git rm git rm 是 Git 用来从工作区，或者暂存区移除文件的命令。 在为下一次提交暂存一个移除操作上，它与 git add 有一点类似。 我们在 移除文件 一节中提到了 git rm 的一些细节， git rm 从暂存区中移除，并从工作目录中删除指定的文件，使用 --cached 选项来只移除暂存区域的文件但是保留工作区的文件。 在本书的 移除对象 一节中，介绍了 git rm 仅有的几种不同用法，如在执行 git filter-branch 中使用和解释了 --ignore-unmatch 选项。 这对脚本来说很有用。 git mv git mv 命令是一个便利命令，用于移到一个文件并且在新文件上执行git add命令及在老文件上执行git rm命令。 我们只是在 移动文件 一节中简单地提到了此命令。 git clean git clean 是一个用来从工作区中移除不想要的文件的命令。 可以是编译的临时文件或者合并冲突的文件。默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除。 在 清理工作目录 一节中我们介绍了你可能会使用 clean 命令的大量选项及场景。 分支与合并 Git 有几个实现大部的分支及合并功能的实用命令。 git branch git branch 命令实际上是某种程度上的分支管理工具。 它可以列出你所有的分支、创建新分支、删除分支及重命名分支。 Git 分支 一节主要是为 branch 命令来设计的，它贯穿了整个章节。 首先，我们在 分支创建 一节中介绍了它，然后我们在 分支管理 一节中介绍了它的其它大部分特性（列举及删除）。 在 跟踪分支 一节中，我们使用 git branch -u 选项来设置一个跟踪分支。 最后，我们在 Git 引用 一节中讲到了它在背后做一什么。 git checkout git checkout 命令用来切换分支，或者检出内容到工作目录。 我们是在 分支切换 一节中第一次认识了命令及 git branch 命令。 在 跟踪分支 一节中我们了解了如何使用 --track 标志来开始跟踪分支。 在 检出冲突 一节中，我们用此命令和 --conflict=diff3 来重新介绍文件冲突。 在 重置揭密 一节中，我们进一步了解了其细节及与 git reset 的关系。 最后，我们在 HEAD 引用 一节中介绍了此命令的一些实现细节。 git merge git merge 工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。 我们首先在 新建分支 一节中介绍了 git merge 命令。 虽然它在本书的各种地方都有用到，但是 merge命令只有几个变种，一般只是 git merge 带上一个你想合并进来的一个分支名称。 我们在 派生的公开项目 的后面介绍了如何做一个 squashed merge （指 Git 合并时将其当作一个新的提交而不是记录你合并时的分支的历史记录。） 在 高级合并 一节中，我们介绍了合并的过程及命令，包含 -Xignore-space-change 命令及 --abort选项来中止一个有问题的提交。 在 签署提交 一节中我们学习了如何在合并前验证签名，如果你项目正在使用 GPG 签名的话。 最后，我们在 子树合并 一节中学习了子树合并。 git mergetool 当你在 Git 的合并中遇到问题时，可以使用 git mergetool 来启动一个外部的合并帮助工具。 我们在 遇到冲突时的分支合并 中快速介绍了一下它，然后在 外部的合并与比较工具 一节中介绍了如何实现你自己的外部合并工具的细节。 git log git log 命令用来展示一个项目的可达历史记录，从最近的提交快照起。 默认情况下，它只显示你当前所在分支的历史记录，但是可以显示不同的甚至多个头记录或分支以供遍历。 此命令通常也用来在提交记录级别显示两个或多个分支之间的差异。 在本书的每一章几乎都有用到此命令来描述一个项目的历史。 在 查看提交历史 一节中我们介绍了此命令，并深入做了研究。 研究了包括 -p 和 --stat 选项来了解每一个提交引入的变更，及使用--pretty 和 --oneline 选项来查看简洁的历史记录。 在 分支创建 一节中我们使用它加 --decorate 选项来简单的可视化我们分支的指针所在，同时我们使用 --graph 选项来查看分叉的历史记录是怎么样的。 在 私有小型团队 和 提交区间 章节中，我们介绍了在使用 git log 命令时用 branchA..branchB 的语法来查看一个分支相对于另一个分支, 哪一些提交是唯一的。 在 提交区间 一节中我们作了更多介绍。 在 > 和 三点 章节中，我们介绍了 branchA...branchB 格式和 --left-right 语法来查看哪些仅其中一个分支。 在 合并日志 一节中我们还研究了如何使用 --merge 选项来帮助合并冲突调试，同样也使用 --cc 选项来查看在你历史记录中的合并提交的冲突。 在 引用日志 一节中我们使用此工具和 -g 选项 而不是遍历分支来查看 Git 的 reflog。 在 搜索 一节中我们研究了-S 及 -L 选项来进行来在代码的历史变更中进行相当优雅地搜索，如一个函数的历史。 在 签署提交 一节中，我们了解了如何使用 --show-signature 来为每一个提交的 git log 输出中，添加一个判断是否已经合法的签名的一个验证。 git stash git stash 命令用来临时地保存一些还没有提交的工作，以便在分支上不需要提交未完成工作就可以清理工作目录。 储藏与清理 一整个章节基本就是在讲这个命令。 git tag git tag 命令用来为代码历史记录中的某一个点指定一个永久的书签。 一般来说它用于发布相关事项。 我们在 打标签 一节中介绍了此命令及相关细节，并在 为发布打标签 一节实践了此命令。 我也在 签署工作 一节中介绍了如何使用 -s 标志创建一个 GPG 签名的标签，然后使用 -v 选项来验证。 项目分享与更新 在 Git 中没有多少访问网络的命令，几乎所以的命令都是在操作本地的数据库。 当你想要分享你的工作，或者从其他地方拉取变更时，这有几个处理远程仓库的命令。 git fetch git fetch 命令与一个远程的仓库交互，并且将远程仓库中有但是在当前仓库的没有的所有信息拉取下来然后存储在你本地数据库中。 我们开始在 从远程仓库中抓取与拉取 一节中介绍了此命令，然后我们在 远程分支 中看到了几个使用示例。 我们在 向一个项目贡献 一节中有几个示例中也都有使用此命令。 在 合并请求引用 我们用它来抓取一个在默认空间之外指定的引用，在 打包 中，我们了解了怎么从一个包中获取内容。 在 引用规格 章节中我们设置了高度自定义的 refspec 以便 git fetch 可以做一些跟默认不同的事情。 git pull git pull 命令基本上就是 git fetch 和 git merge 命令的组合体，Git 从你指定的远程仓库中抓取内容，然后马上尝试将其合并进你所在的分支中。 我们在 从远程仓库中抓取与拉取 一节中快速介绍了此命令，然后在 查看远程仓库 一节中了解了如果你运行此命令的话，什么将会合并。 我们也在 用变基解决变基 一节中了解了如何使用此命令来来处理变基的难题。 在 检出冲突 一节中我们展示了使用此命令如何通过一个 URL 来一次性的拉取变更。 最后，我们在 签署提交 一节中我们快速的介绍了你可以使用 --verify-signatures 选项来验证你正在拉取下来的经过 GPG 签名的提交。 git push git push 命令用来与另一个仓库通信，计算你本地数据库与远程仓库的差异，然后将差异推送到另一个仓库中。 它需要有另一个仓库的写权限，因此这通常是需要验证的。 我们开始在 推送到远程仓库 一节中介绍了 git push 命令。 在这一节中主要介绍了推送一个分支到远程仓库的基本用法。 在 推送 一节中，我们深入了解了如何推送指定分支，在 跟踪分支 一节中我们了解了如何设置一个默认的推送的跟踪分支。 在 删除远程分支 一节中我们使用 --delete 标志和 git push 命令来在删除一个在服务器上的分支。 在 向一个项目贡献 一整节中，我们看到了几个使用 git push 在多个远程仓库分享分支中的工作的示例。 在 共享标签 一节中，我们知道了如何使用此命令加 --tags 选项来分享你打的标签。 在 发布子模块改动 一节中，我们使用 --recurse-submodules 选项来检查是否我们所有的子模块的工作都已经在推送子项目之前已经推送出去了，当使用子模块时这真的很有帮助。 在 其它客户端钩子 中我们简单的提到了 pre-push 挂钩（hook），它是一个可以用来设置成在一个推送完成之前运行的脚本，以检查推送是否被允许。 最后，在 引用规格推送 一节中，我们知道了使用完整的 refspec 来推送，而不是通常使用的简写形式。 这对我们精确的指定要分享出去的工作很有帮助。 git remote git remote 命令是一个是你远程仓库记录的管理工具。 它允许你将一个长的 URL 保存成一个简写的句柄，例如 origin ，这样你就可以不用每次都输入他们了。 你可以有多个这样的句柄，git remote 可以用来添加，修改，及删除它们。 此命令在 远程仓库的使用 一节中做了详细的介绍，包括列举、添加、移除、重命名功能。 几乎在此书的后续章节中都有使用此命令，但是一般是以 git remote add 这样的标准格式。 git archive git archive 命令用来创建项目一个指定快照的归档文件。 我们在 准备一次发布 一节中，使用 git archive 命令来创建一个项目的归档文件用于分享。 git submodule git submodule 命令用来管理一个仓库的其他外部仓库。 它可以被用在库或者其他类型的共享资源上。submodule 命令有几个子命令, 如（add、update、sync 等等）用来管理这些资源。 只在 子模块 章节中提到和详细介绍了此命令。 检查与比较 git show git show 命令可以以一种简单的人类可读的方式来显示一个 Git 对象。 你一般使用此命令来显示一个标签或一个提交的信息。 我们在 附注标签 一节中使用此命令来显示带注解标签的信息。 然后，我们在 选择修订版本 一节中，用了很多次来显示不同的版本选择将解析出来的提交。 我们使用 git show 做的最有意思的事情是在 手动文件再合并 一节中用来在合并冲突的多个暂存区域中提取指定文件的内容。 git shortlog git shortlog 是一个用来归纳 git log 的输出的命令。 它可以接受很多与 git log 相同的选项，但是此命令并不会列出所有的提交，而是展示一个根据作者分组的提交记录的概括性信息 我们在 制作提交简报 一节中展示了如何使用此命令来创建一个漂亮的 changelog 文件。 git describe git describe 命令用来接受任何可以解析成一个提交的东西，然后生成一个人类可读的字符串且不可变。 这是一种获得一个提交的描述的方式，它跟一个提交的 SHA-1 值一样是无歧义，但是更具可读性。 我们在 生成一个构建号 及 准备一次发布 章节中使用 git describe 命令来获得一个字符串来命名我们发布的文件。 调试 Git 有一些命令可以用来帮你调试你代码中的问题。 包括找出是什么时候，是谁引入的变更。 git bisect git bisect 工具是一个非常有用的调试工具，它通过自动进行一个二分查找来找到哪一个特定的提交是导致 bug 或者问题的第一个提交。 仅在 二分查找 一节中完整的介绍了此命令。 git blame git blame 命令标注任何文件的行，指出文件的每一行的最后的变更的提交及谁是那一个提交的作者。 当你要找那个人去询问关于这块特殊代码的信息时这会很有用。 只有 文件标注 一节有中提到此命令。 git grep git grep 命令可以帮助在源代码中，甚至是你项目的老版本中的任意文件中查找任何字符串或者正则表达式。 只有 Git Grep 的章节中与提到此命令。 补丁 Git 中的一些命令是以引入的变更即提交这样的概念为中心的，这样一系列的提交，就是一系列的补丁。 这些命令以这样的方式来管理你的分支。 git cherry-pick git cherry-pick 命令用来获得在单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。 从一个分支单独一个或者两个提交而不是合并整个分支的所有变更是非常有用的。 在 变基与拣选工作流 一节中描述和演示了 Cherry picking git rebase git rebase 命令基本是是一个自动化的 cherry-pick 命令。 它计算出一系列的提交，然后再以它们在其他地方以同样的顺序一个一个的 cherry-picks 出它们。 在 变基 一章中详细提到了此命令，包括与已经公开的分支的变基所涉及的协作问题。 在 替换 中我们在一个分离历史记录到两个单独的仓库的示例中实践了此命令，同时使用了 --onto 选项。 在 Rerere 一节中，我们研究了在变基时遇到的合并冲突的问题。 在 修改多个提交信息 一节中，我们也结合 -i 选项将其用于交互式的脚本模式。 git revert git revert 命令本质上就是一个逆向的 git cherry-pick 操作。 它将你提交中的变更的以完全相反的方式的应用到一个新创建的提交中，本质上就是撤销或者倒转。 我们在 还原提交 一节中使用此命令来撤销一个合并提交。 邮件 很多 Git 项目，包括 Git 本身，基本是通过邮件列表来维护的。 从方便地生成邮件补丁到从一个邮箱中应用这些补丁,Git 都有工具来让这些操作变得简单。 git apply git apply 命令应用一个通过 git diff 或者甚至使用 GNU diff 命令创建的补丁。 它跟补丁命令做了差不多的工作，但还是有一些小小的差别。 我们在 应用来自邮件的补丁 一节中演示了它的使用及什么环境下你可能会用到它。 git am git am 命令用来应用来自邮箱的补丁。特别是那些被 mbox 格式化过的。 这对于通过邮件接受补丁并将他们轻松地应用到你的项目中很有用。 我们在 使用 am 命令应用补丁 命令中提到了它的用法及工作流，包括使用 --resolved、-i 及 -3 选项。 我们在 电子邮件工作流钩子 也提到了几条 hooks，你可以用来辅助与 git am 相关工作流。 在 邮件通知 一节中我们也将用此命令来应用 格式化的 GitHub的推送请求的变更。 git format-patch git format-patch 命令用来以 mbox 的格式来生成一系列的补丁以便你可以发送到一个邮件列表中。 我们在 通过邮件的公开项目 一节中研究了一个使用 git format-patch 工具为一个项目做贡献的示例。 git imap-send git imap-send 将一个由 git format-patch 生成的邮箱上传至 IMAP 草稿文件夹。 我们在 通过邮件的公开项目 一节中见过一个通过使用 git imap-send 工具向一个项目发送补丁进行贡献的例子。 git send-email git send-mail 命令用来通过邮件发送那些使用 git format-patch 生成的补丁。 我们在 通过邮件的公开项目 一节中研究了一个使用 git send-email 工具发送补丁来为一个项目做贡献的示例。 git request-pull git request-pull 命令只是简单的用来生成一个可通过邮件发送给某个人的示例信息体。 如果你在公共服务器上有一个分支，并且想让别人知道如何集成这些变更，而不用通过邮件发送补丁，你就可以执行此命令的输出发送给这个你想拉取变更的人。 我们在 派生的公开项目 一节中演示了如何使用 git request-pull 来生成一个推送消息。 外部系统 Git 有一些可以与其他的版本控制系统集成的命令。 git svn git svn 可以使 Git 作为一个客户端来与 Subversion 版本控制系统通信。 这意味着你可以使用 Git 来检出内容，或者提交到 Subversion 服务器。 Git 与 Subversion 一章深入讲解了此命令。 git fast-import 对于其他版本控制系统或者从其他任何的格式导入，你可以使用 git fast-import 快速地将其他格式映射到 Git 可以轻松记录的格式。 在 一个自定义的导入器 一节中深入讲解了此命令。 管理 如果你正在管理一个 Git 仓库，或者需要通过一个复杂的方法来修复某些东西，Git 提供了一些管理命令来帮助你。 git gc git gc 命令在你的仓库中执行 “garbage collection” ，删除数据库中不需要的文件和将其他文件打包成一种更有效的格式。 此命令一般在背后为你工作，虽然你可以手动执行它-如果你想的话。 我们在维护 一节中研究此命令的几个示例。 git fsck git fsck 命令用来检查内部数据库的问题或者不一致性。 我们只在 数据恢复 这一节中快速使用了一次此命令来搜索所有的悬空对象（dangling object）。 git reflog git reflog 命令分析你所有分支的头指针的日志来查找出你在重写历史上可能丢失的提交。 我们主要在 引用日志 一节中提到了此命令，并在展示了一般用法，及如何使用 git log -g 来通过 git log 的输出来查看同样的信息。 我们同样在 数据恢复 一节中研究了一个恢复丢失的分支的实例。 git filter-branch git filter-branch 命令用来根据某些规则来重写大量的提交记录，例如从任何地方删除文件，或者通过过滤一个仓库中的一个单独的子目录以提取出一个项目。 在 从每一个提交移除一个文件 一节中，我们解释了此命令，并探究了其他几个选项，例如 --commit-filter，--subdirectory-filter 及 --tree-filter 。 在 Git-p4 和 TFS 的章节中我们使用它来修复已经导入的外部仓库。 底层命令 在本书中我们也遇到了不少底层的命令。 我们遇到的第一个底层命令是在 合并请求引用 中的 ls-remote 命令。我们用它来查看服务端的原始引用。 我们在 手动文件再合并、 Rerere 及 索引 章节中使用 ls-files 来查看暂存区的更原始的样子。 我们同样在 分支引用 一节中提到了 rev-parse 命令，它可以接受任意字符串，并将其转成一个对象的 SHA-1 值。 我们在 Git 内部原理 一章中对大部分的底层命令进行了介绍，这差不多正是这一章的重点所在。 我们尽量避免了在本书的其他部分使用这些命令。 Git 图形界面 gitk历史记录查看器 gitk 是一个历史记录的图形化查看器。 $ gitk # 查看历史记录 每个点代表一次提交，线代表父子关系，而彩色的方块则用来标示一个个引用。 黄点表示 HEAD，红点表示尚未提交的本地变动。 下方的窗口用来显示当前选中的提交的具体信息；评论和补丁显示在左侧，摘要显示在右侧。 中间则是一组用来搜索历史的控件。 git-gui 提交工具 $ git gui # 制作提交 左侧是索引区；未暂存的修改显示在上方，已暂存的修改显示在下方。 你可以通过点击文件名左侧的图标来将该文件在暂存状态与未暂存状态之间切换，你也可以通过选中一个文件名来查看它的详情。 右侧窗口的上方以 diff 格式来显示当前选中文件发生了变动的地方。 你可以通过右击某一区块或行从而将这一区块或行放入暂存区。 右侧窗口的下方是写日志和执行操作的地方。 在文本框中键入日志然后点击 “提交” 就和执行 git commit 的效果差不多。 如果你想要修订上一次提交, 可以选中`‘修订’' 按钮，上次一提交的内容就会显示在 “暂存区”。 然后你就可以简单的对修改进行暂存和取消暂存操作，更新提交日志，然后再次点击 “提交” 用这个新的提交来覆盖上一次提交。 GitHub GitHub官方中文帮助 B站教程 Github是全球最大的社交编程及代码托管网站（https://github.com/）。 Github可以托管各种git库，并提供一个web界面。 Github作为开源代码库以及版本控制系统，Github拥有百万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法 GitHub基本概念 Repository 仓库，用于存放项目代码，每个项目对一个仓库，你想在 GitHub 上开源一个项目，那就必须要新建一个 Repository Watch：关注项目，可以接收到项目更新提醒 Star：收藏项目 Fork 复制克隆项目，该fork的项目是独立存在的 Pull request ：发起合并请求，基于fork Issue：事务卡片，发现代码bug，但目前没有成型代码，需要讨论时可用，解决issue后关闭issue 注册账户 GitHub 为免费账户提供了完整功能，限制是你的项目都将被完全公开（每个人都具有读权限）。 配置github SSH 访问 生成 SSH 公钥 默认情况下，ssh-keygen生成用户的 SSH 密钥存储在其 ~/.ssh 目录下,id_dsa.pub是公钥 ssh-keygen # 生成公钥 cat ~/.ssh/id_rsa.pub # 查看公钥 主页设置Settings–SSH and GPGkeys–New SSH keys按钮,给你的公钥起一个名字，将你的cat ~/.ssh/id_rsa.pub公钥文件的内容粘贴到文本区，然后点击Add SSH key。 添加远程SSH git remote add [origin_ssh远程别名] [SSH地址] # 添加远程SSH库别名 测试SSH连接 ssh -T git@github.com 在 Git 中缓存 GitHub 密码 如果使用 HTTPS 克隆 GitHub 仓库，您可以使用凭据小助手告诉 Git 在每次与 GitHub 会话时记住您的 GitHub 用户名和密码。 如果使用 SSH 克隆 GitHub 仓库，则应使用 SSH 密钥进行身份验证，而不是使用用户名和密码。 有关设置 SSH 连接的帮助信息，请参阅生成 SSH 密钥。 开启凭据小助手使 Git 将您的密码在内存中保存一段时间。 默认情况下，Git 会缓存密码 15 分钟。 开启凭据小助手使 # 设置 git 使用凭据内存缓存 git config --global credential.helper cache 更改默认的密码缓存时限 # 设置缓存时限为 1 小时（以秒为单位进行设置） git config --global credential.helper 'cache --timeout=3600' github创建仓库 点击【Start a project】创建一个仓库 github仓储添加文件 直接在github上创建文件 仓库主页，点击【create new file】创建仓库文件（文件名不能为空），文件名以/分隔则创建文件夹 Get started by creating a new file or uploading an existing file. 创建本地仓储再上传到github …or create a new repository on the command line使用命令行添加现有项目到 GitHub 在 GitHub 上创建新仓库 为避免错误，请勿使用自述文件、许可或 gitignore 文件初始化新仓库。 将本地目录初始化为 Git 仓库。 git init 在新的本地仓库中添加文件。 这会暂存它们用于第一次提交。 git add . # Adds the files in the local repository and stages them for commit. 要取消暂存文件，请使用 'git reset HEAD YOUR-FILE'。 提交暂存在本地仓库中的文件。 git commit -m \"First commit\" # Commits the tracked changes and prepares them to be pushed to a remote repository. 要删除此提交并修改文件，请使用 'git reset --soft HEAD~1' 并再次提交和添加文件。 添加远程仓库的 URL（将在该 URL 推送本地仓库） 在 GitHub 仓库的 Quick Setup（快速设置）页面中，单击 复制远程仓库 URL。 # Sets the new remote git remote add origin remote_repository_URL #git remote add origin https://github.com/robotchaoX/robotchaoX.github.io.git # Verifies the new remote URL git remote -v 推送更改（本地仓库中）到 GitHub。 git push origin master # Pushes the changes in your local repository up to the remote repository you specified as the origin 本地仓储上传到github …or push an existing repository from the command line git remote add origin https://github.com/robotchaoX/robotchaoX.github.io.git git push -u origin master 从其他仓储导入code …or import code from another repository You can initialize this repository with code from a Subversion, Mercurial, or TFS project. 对项目做出贡献 如何为开源项目做出贡献 新建issue： 提交使用问题或者建议或者想法 Pull request： fork项目 修改自己仓库的项目代码 新建pull request 等待作者合并 issue 派生（Fork）项目 派生的意思是指，GitHub 将在你的空间中创建一个完全属于你的项目副本，且你对其具有推送权限。 人们可以派生这个项目，将修改推送到派生出的项目副本中，并通过创建合并请求（Pull Request）来让他们的改动进入源版本库。 复刻是仓库的副本。 通过复刻仓库，您可以自由地尝试更改而不会影响原始项目。复刻是您管理的仓库的副本。 复刻用于更改项目而不影响原始仓库。 您可以通过拉取请求从原始仓库提取更新，或者提交更改到原始仓库。删除复刻不会删除原始上游仓库。 事实上，您可以对复刻进行所需的更改--添加协作者、重命名文件、生成 GitHub 页面--而不影响原始仓库。 对复刻的更改没有任何限制，包括： 创建分支：分支允许您在不影响主项目的情况下构建新功能或测试创意。 打开拉取请求：如果您希望回馈原始仓库，您可以通过提交拉取请求请求原作者将您的复刻拉取到他们的仓库。 可以使用拉取请求将更改从复刻提交到原始仓库（也称为上游仓库）。 可以通过同步复刻与上游仓库，将更改从上游仓库提交到本地复刻。 1.为复刻配置远程上游仓库 必须在 Git 中配置指向上游仓库的远程仓库，才能将您在复刻中所做的更改同步到原始仓库。 这也允许您将在原始仓库中所做的更改同步到复刻中。列出当前为复刻配置的远程仓库 git remote -v > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 指定将与复刻同步的新远程上游仓库 git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 验证为复刻指定的新上游仓库 git remote -v > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) > upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch) > upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) 2.同步复刻 同步仓库的复刻以通过上游仓库使其保持最新。 必须在 Git 中配置指向上游仓库的远程仓库，然后才能将您的复刻与上游仓库同步。 cd fork的本地仓库 fetch获取上游分支 从上游仓库获取分支及其各自的提交。 对 master 的提交将存储在本地分支 upstream/master 中。 # fetch获取上游分支 git fetch upstream > remote: Counting objects: 75, done. > remote: Compressing objects: 100% (53/53), done. > remote: Total 62 (delta 27), reused 44 (delta 9) > Unpacking objects: 100% (62/62), done. > From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY > * [new branch] master -> upstream/master 检出fork的本地 master 分支。 git checkout master > Switched to branch 'master' 合并上游分支到本地master 将来自 upstream/master 的更改合并到本地 master 分支中。 这会使复刻的 master 分支与上游仓库同步，而不会丢失本地更改。 git merge upstream/master > Updating a422352..5fdff0f > Fast-forward > README | 9 ------- > README.md | 7 ++++++ > 2 files changed, 7 insertions(+), 9 deletions(-) > delete mode 100644 README > create mode 100644 README.md 将上游仓库合并到复刻 如果您对上游仓库没有推送（写入）权限，便可将提交从该仓库拉入您自己的复刻 检出要合并到其中的分支 git checkout master 从上游仓库拉取所需的分支。 此方法将保留提交历史记录而不做修改 git pull https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git BRANCH_NAME 将合并推送到 GitHub 仓库 git push origin master 维护项目 clone仓储 使用 HTTPS URL 克隆（推荐） git clone https://github.com// 当您在命令行中使用 HTTPS URL 对远程仓库执行 git clone、git fetch、git pull 或 git push 命令时，系统将要求您输入 GitHub 用户名和密码。 如果您启用了双重身份验证，或者正在访问使用[SAML 单点登录]的组织(/articles/about-authentication-with-saml-single-sign-on)， 则必须提供个人访问令牌，而不是输入您的 HTTPS Git 密码。 使用 SSH URL 克隆 使用 SSH URL 对远程仓库执行 git clone、git fetch、git pull 或 git push 命令时，系统将提示您输入密码，并且必须提供您的 SSH 密钥密码。 如果您访问使用 SAML 单点登录的组织，则无法使用 SSH 克隆。 创建新的仓储库 / 命名的新仓库 HTTP ： https://github.com// SSH ： git@github.com:/ 添加合作者 仓储–Settings–Collaborators 管理合并请求 管理组织 除了个人帐户之外，GitHub 还提供被称为组织（Organizations）的帐户。 组织账户和个人账户一样都有一个用于存放所拥有项目的命名空间，但是许多其他的东西都是不同的。 组织帐户代表了一组共同拥有多个项目的人，同时也提供一些工具用于对成员进行分组管理。 脚本 GitHub 如何使用 GitHub 钩子系统与 API 接口，使 GitHub 按照我们的设想来工作。 钩子 GitHub 仓库管理中的钩子与服务区块是 GitHub 与外部系统交互最简单的方式。 服务 GitHub API Github Pages 搭建网站 - 个人站点 搭建步骤 创建个人站点 -> 新建个人站点仓库（注意：仓库名必须是 用户名.github.io） 在仓库下新建index.html的网页文件（仓库下不能有其他文件） 编辑index.html的网页文件 注意：github pages只支持静态网页，仓库里面只能是.html文件 个人站点访问地址 https://用户名.github.io - 项目站点 对于项目页面站点和符合特定条件的其他页面站点，您可以配置 GitHub 页面 以从 master 分支上的 master、gh-pages 或 /docs 文件夹中发布站点的源文件。 搭建步骤 进入项目主页，点击Settings 在Settings页面，GitHub Pages点击Source选择网页源码位置，选master branch主页内容为READM.md内容，选master branch /docs folder主页为/docs 文件夹下的index.html的网页源文件（需新建文件docs/index.html提前手动创建/docs文件夹及index.html网页源码文件） Theme Chooser选择主题页面 编辑index.html的网页文件 项目站点访问地址 https://用户名.github.io/仓库名 REFERENCES git官方文档 GitHub官方中文帮助文档 B站: 【教程】学会Git玩转Github【全】 传智播客: 两小时学会Git玩转Github 尚硅谷: Git&GitHub GitHub: yezhaodan/-Git "},"jetson/":{"url":"jetson/","title":"NVIDIA-jetson","keywords":"","body":"NVIDIA jetson-NotesNVIDIA jetson-Notes NVIDIA Jetson 是NVIDIA为新一代自主机器设计的的嵌入式系统， 是一个AI平台 。 NVIDIA® Jetson™ 系统所提供的性能和能效可提高自主机器软件的运行速度。 每个系统都是一个完备的模块化系统 (SOM)，具备 CPU、GPU、PMIC、DRAM 和闪存。 Jetson 具备可扩展性，选择应用场合的 SOM，即能够以此为基础构建自定义系统，满足应用需求。 Jetson 模块可以支持需要各种性能级别和价格的大量应用场合，例如 AI 网络视频录像机 (NVR)、高精度制造领域中的自动光学检查 (AOI) 以及自主移动机器人 (AMR)。 Jetson 平台由 JetPack SDK 提供支持。JetPack 可提供用于深度学习、计算机视觉、加速计算和多媒体的库，而且支持各类传感器的驱动程序。 Jetson笔记 Jetson TX2刷机 首次开机 Jetpack4.2刷机 图为科技007载板刷机 Jetson TX1刷机 Jetpack刷机TX1 opencv自定义安装 安装PCL 系统配置 系统拓容 软件安装 工作模式 风扇控制 温度控制 上电启动 jetson-stats / jtop 查看系统信息 修改显示器分辨率 网络设置 root 自动登录 启动图形界面 开机启动提示文字 开机动画 守护进程 程序自启动 开机启动项 挂载磁盘 登录shell SSH登录 桌面共享 CLion远程同步及调试 外设IO GPIO python Jetson.GPIO 串口 串口调试 Linux下如何使用USB转串口设备 I2C jetsonTX2 CAN通信 中断 LINUX信号机制 图为007载板 RealSense 相机 Intel® RealSense™ D435 参数 RealSense SDK 安装 更新固件 ZED 相机 "},"jetson/jetson.html":{"url":"jetson/jetson.html","title":"jetson笔记","keywords":"","body":"Jetson笔记Jetson TX2刷机首次开机Jetpack4.2刷机图为科技007载板刷机Jetson TX1刷机Jetpack刷机TX1opencv自定义安装安装PCL系统配置系统拓容软件安装工作模式风扇控制温度控制上电启动jetson-stats / jtop查看系统信息修改显示器分辨率网络设置root 自动登录启动图形界面开机启动提示文字开机动画守护进程程序自启动开机启动项挂载磁盘登录shellSSH登录桌面共享CLion远程同步及调试外设IOGPIOpython Jetson.GPIO串口串口调试Linux下使用USB转串口设备I2CCAN通信中断信号LINUX信号机制图为007载板RealSense 相机RealSense D435 参数RealSense SDK 安装更新固件ZED 相机Jetson笔记 [TOC] Jetson TX2刷机 首次开机 Jetpack4.2刷机 图为科技007载板刷机 Jetson TX1刷机 Jetpack刷机TX1 opencv自定义安装 安装PCL 系统配置 系统拓容 软件安装 工作模式 风扇控制 温度控制 上电启动 jetson-stats / jtop 查看系统信息 修改显示器分辨率 网络设置 root 自动登录 启动图形界面 开机启动提示文字 开机动画 守护进程 程序自启动 开机启动项 挂载磁盘 登录shell SSH登录 桌面共享 CLion远程同步及调试 外设IO GPIO python Jetson.GPIO 串口 串口调试 Linux下使用USB转串口设备 I2C CAN通信 中断信号 LINUX信号机制 图为007载板 RealSense 相机 RealSense D435 参数 RealSense SDK 安装 更新固件 ZED 相机 Jetson TX2刷机 首次开机 Jetson TX2首次开机开不了，按一下开机键电源红灯亮一下就熄灭了，没有其他反应？？ 原因是Jetson TX2开机必须==长按电源键==，等到按键两侧绿灯亮了，再松开电源键即可启动点亮屏幕。 亲测TX2部分屏幕可以使用HDMI转VGA来转接，即使是首次开机时使用转接头也可以正常显示，但是，有的屏幕不可以使用HDMI转VGA来转接，两种情况都遇到过。 插好电源并供电（亚太版默认不带电源插线需要自配，美版带了电源插线似乎插口与国内插座不匹配），接通显示器、键盘、鼠标，然后按下主板上红色的\"POWER BTN\"开机按钮。 Jetson TX2 自带ubuntu 16.04 系统，默认用户名nvidia，密码nvidia。首次开机时，屏幕会显示一些提示信息，按提示步骤输入命令，安装Nvidia Linux driver图形化界面驱动。 ls cd ${HOME}/NVIDIA_INSTALLER sudo ./install.sh sudo reboot Jetpack4.2刷机 官网教程： NVIDIA JetPack SDK官方文档 NVIDIA SDK Manager官方手册 SDK Manager 安装 Jetson 参考教程 NVIDIA JetPack SDK是用于构建AI应用程序的最全面的解决方案。使用JetPack安装程序使用最新的操作系统映像刷新Jetson Developer Kit，为主机PC和Developer Kit安装开发人员工具，并安装快速启动开发环境所需的库和API。JetPack包括操作系统映像，库和API，开发人员工具，示例和文档。预装的Ubuntu没有集成NVIDIA的开发工具，需要先安装JETPACK才能进行开发，也就是俗称的刷机。只有TX2开发板是无法刷机的，Jetpack刷机需要准备一台装有64位Ubuntu16.04系统host主机，可以在虚拟机中安装Ubuntu16.04系统作为host主机。 刷机注意点： 刷机时间大概需要 1~2 小时，会格式化 eMMC host主机Ubuntu16.04系统至少30GB的硬盘空间，因为jetpack需下载的文件比较大 若是虚拟机虚需设置为USB3.0,jetson与主机也使用USB3.0口相连 重装系统后jetson的USB名称会由“NVIDIA Corp”改变为“NVIDIA Linux for Tegra” 刷机准备 VirtualBox 虚拟机设置 没用VirtualBox虚拟机的跳过 设置虚拟机网络连接桥接模式 如果主机主机是在虚拟机中运行的，一定要设置虚拟机网络连接模式桥接模式，并勾选复制物理网路连接状态，桥接模式可以让虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。不然在刷完系统后装软件的时候会卡死在等待获取设备IP地址这个地方 设置共享粘贴板 打开虚拟机设置对话框，在左侧导航栏中点击【常规】，在右侧设置面板中选择【高级】tab页，将【共享粘贴板】和【拖放】都由默认的【已禁止】改为【双向】。 设置共享文件夹 在状态栏Linux桌面菜单中，点击【设备】-【安装增强功能…】菜单项 安装包会被加载到虚拟机中,点击安装即可 遇到没有权限访问共享目录的解决办法 You do not have the permissions necessary to view the contents of “sf_deepin_Downloads” 将用户添加到vboxsf，然后重启 sudo usermod -a -G vboxsf 用户名 必须设置USB 3.0 (xHCI) Controller VM VirtualBox 需设置USB 3.0 (xHCI) Controller，jetson与host主机连接的物理接口也使用电脑的USB3.0口，在进入Recovery模式后需设置虚拟机，菜单栏—-device—-USB—-USB setting—-添加“NVIDIA Corp”的USB设备以便刷机重启后仍能够自动连接jetson的USB设备 host主机ubuntu系统设置 更换成国内的软件源 中科大USTC镜像源prots 安装工具sdkmanager NVIDIA SDK Manager官方手册 SDK Manager 安装 Jetson 下载并安装最新的JetPack安装工具sdkmanager，安装JetPack需要通过NVIDIA SDK Manager安装工具sdkmanager，下载sdkmanager时需要注册一个nvidia的账户，后面也需要用。 JetPack 4.2安装工具sdkmanager下载地址 在host主机上安装下载的JetPack安装工具sdkmanager sudo dpkg -i sdkmanager_0.9.11-3405_amd64.deb # 安装sdkmanager #sudo apt install ./sdkmanager-[version].[build#].deb # 安装sdkmanager sdkmanager # 启动sdkmanager软件 打开安装的sdkmanager软件，登录nvidia的账户。 STEP01 选择开发环境： 在 Product Category 中选择 Jetson 在 Hardware Configuration 中选择 Host Machine 则在host主机上安装NVIDIA全家桶，不选则honst不会安装任何软件；Target Hardware 选择 Jetson TX2 在 Target Operating System 中选择 JetPack 的版本 点击CONTINUE进入下一步 STEP02 选择安装的组件： 选择安装的组件，勾选Jetson OS则会重新刷系统，不勾选则不会；勾选Jetson SDK component 则会给jetson安装CUDA Opencv等 选择存储路径 同意条款 点击CONTINUE进入下一步 Tips：若界面显示不完整，无法勾选接受条款进行下一步，原因是笔记本的屏幕太小了，外接21寸以上拓展屏即可。 STEP03 开始下载安装相关包： 下载的时间比较久 如果下载中途中断了再次打开后error报错无法继续下载，直接覆盖安装一遍sdkmanager即可。 下载完毕之后，会弹出一个提示框，让你用USB连接电脑，然后恢复TX2到Recovery模式，首次刷机可能自动模式会报错usb连接不上设备，建议选择手动进入恢复模式。如果只装Jetson SDK component 不重装系统的话，直接点 Skip 跳过重装系统，进入下一步安装 Jetson SDK components。 主机和Jetson连接usb 只需要将host主机（USB端口）和Jetson TX2（micro USB端口）通过USB连接线（安卓手机数据线）连接起来，不再需要用网线将host主机和jetson连在同一个路由下，直接通过USB刷机。仍然建议联网。 若使用 VM VirtualBox 虚拟机，需设置为USB 3.0 (xHCI) Controller，jetson与host主机连接的物理接口也使用电脑的USB3.0口 自动进入Recovery模式（不推荐） 第二次刷机的话自动模式就可以使用了（可能仍然不能使用），启动jetson运行，通过USB连接host主机和jetson，输入当前能够登录jetson的用户名和密码。 注意：若使用 VM VirtualBox 虚拟机，需设置为USB 3.0 (xHCI) Controller，jetson与host主机连接的物理接口也使用电脑的USB3.0口，在host主机上新打开一个终端，使用 lsusb 命令查看是否有“NVIDIA Corp”的设备，有说明连接成功，成功进入Recovery模式，如果是使用 VM VirtualBox 的话需设置虚拟机，在虚拟机菜单栏—-device—-USB—-勾选带NVIDIA的USB设备，然后在菜单栏—-device—-USB—-USB setting—-添加“NVIDIA Corp”或“NVIDIA Linux for Tegra”的USB设备以便刷机时重启后仍能够自动连接NVIDIA jetson的USB设备 手动进入Recovery模式 手动进入Recovery模式具体步骤如为： 1.断开电源，拔掉JetSon TX2电源线 （断电2分钟） 2.重新接上电源 3.长按一下power键（PWR）等绿灯亮开机再松开，然后立即按住Recovery键(REC)不松开，0.5s后按一下Reset键（RST） 绿灯闪一下，继续保持按住Recovery键2s后松开Recovery键，进入Recovery强制恢复模式 在host主机上新打开一个终端，使用 lsusb 命令查看是否有“NVIDIA Corp”的设备，有说明连接成功，成功进入Recovery模式。如果是使用 VM VirtualBox 的话需设置虚拟机，在虚拟机菜单栏—-device—-USB—-勾选带NVIDIA的USB设备，然后在菜单栏—-device—-USB—-USB setting—-添加“NVIDIA Corp”或“NVIDIA Linux for Tegra”的USB设备，以便刷机时重启后仍能够自动连接NVIDIA jetson的USB设备。 安装 Jetson OS 进入Recovery模式后，点击 Flash 进行刷机重装系统 注：刷机日志中出现错误，问题应该不大，只要能正常启动就行，多次重试都出想相同的错误，原因未知，影响未知。 注：刷到14.4%时报错ERROR : Flash Jetson TX2 : lost connection，刷到99.9%，报错CPU Bootloader is not running on device原因是USB的问题，虚拟机和host都使用USB3.0，重新刷机即可。 安装 Jetson SDK components 安装完TX2镜像系统后，host主机会弹出另一个提示框，这会相当于TX 2上系统已经装好了，是一个纯净系统，下面需要在tx2上安装需要的SDK components。 Jetson安装新的系统镜像后，USB的名称变成了“NVIDIA Linux for Tegra”，如果是使用 VM VirtualBox 的话需要重新设置虚拟机，以便自动连接jetson。在虚拟机菜单栏—-device—-USB—-勾选带NVIDIA的USB设备“NVIDIA Linux for Tegra”，然后在菜单栏—-device—-USB—-USB setting—-添加“NVIDIA Linux for Tegra”的USB设备以便刷机时重启后仍能够自动连接NVIDIA jetson的USB设备。在host主机上新打开一个终端，使用 lsusb 命令查看是否有“NVIDIA Linux for Tegra”的设备，有说明连接成功。 安装完TX2系统镜像后，jetson会重启，按照提示配置系统（设置用户名和密码），设置完成后jetson会重启，在jetson登录界面等待，登入TX2的桌面也可以。 回到host主机，在主机SDK Manager软件上输入你设置的用户名和密码，IP Adress 不用管默认即可，似乎是通过USB连接登录jetson进行软件安装的，点击Install，等待安装完成。安装完成后刷机就完成啦。 Tips：若装Jetson SDK components 时，在TX的登录界面输入用户名和登录密码点install安装后，报错无法连接USB设备，则重启TX，在重启的过程中一直点install，在快要到登录界面时能够连接到USB设备，继续开始安装Jetson SDK components。注意保持网络连接，安装过程中会update更新，保持屏幕常亮，防止休眠。 如果选删除下载文件，下次刷机还要重新下载。如果不删除，下次刷机就会省点时间。 JetPack 自带例程的位置 图为科技007载板刷机 与原装刷机方式基本一致，不同的是在 flash OS 前需替换007载板固件 PS: 007固件包仅用于JetPack4.2 升级 格式化SD卡为ext4 格式化SD卡为linux的ext4格式，插入载板 下载007固件包保存到任意位置 下载安装NVIDIAsdkmanager sudo dpkg -i sdkmanager_0.9.12-4180_amd64.deb JetPack下载sdk所需的文件 JetPack下载完成系统OS及所需部件，且JetsonTX OS is ready 复制固件到系统镜像 在开始连接载板刷机前，运行./007.tw.run.sh脚本复制固件到系统镜像目录~/nvidia/nvidia_sdk/JetPack_4.2_Linux_P3310/Linux_for_Tegra/ 进入 Recovery 模式 可以通过 USB 进行系统更新，更新需要进入 USB Recovery 模式。USB Recovery 模式下可以进行文件系统更 新，内核更新，boot loader 更新，BCT 更新等操作。 请根据软件更新手册步骤进行系统更新操作。 进入 Recovery 模式的步骤: 1）关闭系统电源，请确保使电源关闭而不是进入待机状态。 2）使用 USB Micro B 到 USB Type A 的链接线链接载板和主机。 3）对系统进行加电（系统自动上电启动），（不需要按下电源按键）保持按下 RECOVERY 按键的同时按下并释放复位按键，等待 2 秒释放 RECOVERY按键。 注意：在进入 USB Recovery 模式下，系统不会启动，串口不会有调试信息输出，系统会自动上电启动 Jetson TX1刷机 Jetpack刷机TX1 参考链接 官方Download and Install JetPack JetsonHacker JetPack 2.0 Install on NVIDIA Jetson TX1 https://blog.csdn.net/c406495762/article/details/70786700 https://blog.csdn.net/jesse_mx/article/details/53315886 https://cloud.tencent.com/developer/article/1080272 Jetpack刷机需要准备一台装有64位Ubuntu16.04系统host主机，可以在虚拟机中安装Ubuntu16.04系统作为host主机。 刷机注意点： 刷机时间大概需要 1~2 小时，会格式化 eMMC host主机至少30GB的硬盘空间，因为jetpack需下载的文件比较大。 开发板刷机过程全程联网 host主机和Jetson TX2 必须用网线连接同一个路由（在同一网段内）,建议有线连接 刷机准备 VirtualBox 虚拟机设置 没用VirtualBox虚拟机的跳过 设置虚拟机网络连接桥接模式 设置共享粘贴板 设置共享文件夹 遇到没有权限访问共享目录的解决办法 You do not have the permissions necessary to view the contents of “sf_deepin_Downloads” 将用户添加到vboxsf，然后重启 sudo usermod -a -G vboxsf 用户名 必须设置USB 3.0 (xHCI) Controller VirtualBox 虚拟机刷机卡在tegrabct --bct P2180_A00_LP4_DSC_204Mhz.bct --chip 0x21 --updatebfsinfo flash.xml.bin原因是VirtualBox没有设置USB 3.0，解决办法 VM VirtualBox 需设置USB 3.0 (xHCI) Controller I have the same issue and can confirm that flashing the TX1 with jetpack 3.0 on a VM (virtualbox ubuntu 16.04 on windows 10 host) works fine every time (I've used at least 10 times) and flashing with jetpack 3.2 never works and always hangs at: tegrabct --bct P2180_A00_LP4_DSC_204Mhz.bct --chip 0x21 --updatebfsinfo flash.xml.bin My best guess is that the USB connection to the TX1 is closed/reset/reopened several times during the flash process, but I hadn't correctly configured VirtualBox to automatically reattach the USB connection to the VM. So after each disconnect, I had to reattach manually, which maybe wasn't what the JetPack utility expected to happen. I changed the VM's USB settings, adding a filter with minimal information: Name: NVIDIA Corp. APX Vendor ID: 0955 Remote: No I also updated VirtualBox (to version 5.2.12) and the Oracle VM VirtualBox Extension Pack. Then in the VM's USB settings, I enabled the \"USB 3.0 (xHCI) Controller\". Now the TX1's USB connection automatically attaches to the VM, and flashing JetPack works. Hope this helps. My laptop's OS is Ubuntu 18.04 64-bit; my VM's OS is Ubuntu 16.04 64-bit. I'm using JetPack L4T 3.2. I'm flashing a TX1. host主机 ubuntu系统设置 更换成国内的软件源 下载最新的JetPack安装工具 Jetson TX1只支持JetPack 3.3，不支持最新版的JetPack，往下找到JetPack 3.3 and Jetson TX1下载地址 ，下载时需要注册一个nvidia的账户 虚拟机home路径新建一个Jetson文件夹，拖进下载的Jetpack安装包，赋予权限并执行，直接运行，不需sudo mkdir ~/Jetson cd ~/Jetson sudo chmod +x JetPack-L4T-3.3-linux-x64_b39.run ./JetPack-L4T-3.3-linux-x64_b39.run 运行之后出现提示框，点击okay， 随后，进入安装界面，安装配置安装目录，一路Next，选择开发环境的时候选择TX1，Next进入component manager界面，下载所有的开发包，继续点击next同意各种条款，勾选Accept All，然后点击Accept。进入下载界面了，下载好安装包之后，点击OK按钮开始安装。安装完之后，点击Next，就可以进行刷机了。 主机和Jetson连接 选择第一种通过路由器连接的方式 安装过程首先会将系统镜像通过USB刷写到Jetson，然后通过网线的连接，使用HOST登录Jetson的Ubuntu系统，安装选择的软件包，在这个过程中，由于有另外一些依赖的软件包需要安装，所以才需要Jetson联网。 用网线将host主机和jetson连在同一个路由下 将host主机（USB端口）和Jetson TX2（micro USB端口）通过USB连接线（安卓手机数据线）连接起来 连接完成后，点击next，直到这里，需要让JetSon TX2进入Recovery模式。 进入Recovery模式具体步骤如为： 1.断开电源，拔掉JetSon TX2电源线 （断电2分钟） 2.重新接上电源 3.按一下power键（PWR）开机 ，2s内立即按住Recovery键(REC)不松开，0.5s后按一下Reset键（RST） ，继续保持按住Recovery键2s（或者看到 power键旁边的黄色灯闪一下）后松开Recovery键，进入Recovery强制恢复模式 在host主机上新打开一个终端，使用 lsusb 命令查看是否有“NVIDIA Corpration”的设备,有说明连接成功，成功进入Recovery模式，如果是虚拟机的话需先看下虚拟机设置usb设备是否选择上。 确认成功连接之后，在原来的终端Post installation窗口，按下回车，进行安装，刷机过程需要一些时间 。 完成后安装窗口中会显示：Installation of target components finished, close this window to continue.，关闭提示窗口即可。 最后，刷机成功。 如果选删除下载文件，下次刷机还要重新下载。如果不删除，下次刷机就会省点时间。 如果通过jetpack不刷机只重装cuda opencv等,则不需要进入usb recovery模式,只需连接网线和usb,运行jetpack根据引导,把==Flash OS Image to Tegra== (刷image到emmc)设为no action,其他操作相同. opencv自定义安装 卸载 OpenCV4Tegra sudo apt-get purge libopencv4tegra-dev libopencv4tegra sudo apt-get purge libopencv4tegra-repo sudo apt-get update 安装PCL sudo apt-get install libpcl-dev sudo apt-get install libpcl-dev pcl-tools 系统配置 系统拓容 SSD固态硬盘为/根目录 仍然从eMMC闪存启动，挂载SSD为/根目录 Develop on SSD – NVIDIA Jetson TX1 and Jetson TX2 格式化SSD固态硬盘 挂载SSD固态硬盘 双击状态栏SSD图标，将挂载SSD并打开文件夹 将内部eMMC闪存的/根目录的所有内容复制到SSD硬盘中 sudo cp -ax / /media/nvidia/jetsonSSD250 && sync 修改内部==eMMC闪存==上的启动文件extlinux.conf，以便根目录指向/dev/sda1 cd /boot/extlinux sudo cp extlinux.conf extlinux.conf.original # 备份 sudo gedit /boot/extlinux/extlinux.conf 修改示例如下， 默认启动LABEL DEFAULT ssd Linux内核镜像LINUX /boot/Image 初始RAM磁盘 INITRD /boot/initrd 启动挂载点 root=/dev/sda1 TIMEOUT 30 DEFAULT ssd MENU TITLE p2371-2180 eMMC boot options LABEL ssd MENU LABEL ssd kernel LINUX /boot/Image INITRD /boot/initrd APPEND ${cbootargs} root=/dev/sda1 rw rootwait LABEL emmc MENU LABEL emmc kernel LINUX /boot/Image INITRD /boot/initrd APPEND ${cbootargs} root=/dev/mmcblk0p1 rw rootwait 修改后reboot重启 从SD卡启动 https://www.jetsonhacks.com/2017/01/26/run-jetson-tx1-sd-card/ https://www.ncnynl.com/archives/201705/1662.html 格式化SD卡 格式化为ext4格式 记下SD卡Device /dev/mmcblk1p1所在位置，后面要用 挂载SD卡 双击SD卡图标将安装SD卡并打开文件浏览器 将内部闪存的根目录的内容复制到SD卡 sudo cp -ax / '/media/ubuntu/SDRoot' 修改SD卡上的文件extlinux.conf文件 cd '/media/ubuntu/SDRoot' 备份SD卡上的extlinux.conf文件，然后编辑它： cd /boot/extlinux sudo cp extlinux.conf extlinux.conf.original sudo gedit /boot/extlinux/extlinux.conf DEFAULT sdcard LABEL sdcard MENU LABEL SD Card root=/dev/mmcblk1p1 Sample extlinux.conf File TIMEOUT 30 DEFAULT sdcard MENU TITLE p2771-0000 eMMC boot options LABEL sdcard MENU LABEL SD Card LINUX /boot/Image APPEND ${cbootargs} root=/dev/mmcblk1p1 rw rootwait rootfstype=ext4 LABEL emmc MENU LABEL Internal eMMC LINUX /boot/Image APPEND ${cbootargs} root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 Run Jetson TX1 from USB Drive https://www.jetsonhacks.com/2017/01/27/run-jetson-tx1-from-usb-drive/ 软件安装 qt安装 依赖，不然报错 无法链接 Qt5::Widgets sudo apt install libvtk6-dev libvtk6-qt-dev sudo apt-get install qt5-default qtcreator -y # 安装QT Creator # 文档和例子(可选) # sudo apt-get install qt5-doc qt5-doc-html qtbase5-doc-html qtbase5-examples -y # 文档和例子 配置 打开qt creator,依次选择Tools->Options->Build & Run->Compilers 点击Add按钮选择GCC。 在Compiler path:’中选择加入路径/usr/bin/gcc。并依次设置ABI的选项如下图所示:（custom – arm – linux – generic – elf – 64 bit）： 然后点击Apply按钮保存，然后点击Kits: 继续点击Add按钮，按下图填写Name，Qt version, CMake Tool等信息，填好如下图所示： 点击Apply,然后点击OK，设置完毕。 https://blog.csdn.net/u013468614/article/details/88383558 https://blog.csdn.net/we1583004we/article/details/80353798 clion安装 先安装jdk再安装clion sudo apt install default-jdk # 安装默认最新openjdk java -version # 测试jdk是否安装成功 javac -version chromium安装 Jetson TX2 无法安装一般的64位chrome。 使用以下命令安装chromium sudo add-apt-repository ppa:a-v-shkop/chromium sudo apt-get update sudo apt-get install chromium-browser 工作模式 Jetson TX2 有5工作模式及相应的CPU和GPU频率： Mode Mode Name Denver 2 Frequency ARM A57 Frequency GPU Frequency 0 Max-N 2 2.0 GHz 4 2.0 GHz 1.30 Ghz 1 Max-Q 0 4 1.2 GHz 0.85 Ghz 2 Max-P Core-All 2 1.4 GHz 4 1.4 GHz 1.12 Ghz 3 Max-P ARM 0 4 2.0 GHz 1.12 Ghz 4 Max-P Denver 1 2.0 GHz 1 2.0 GHz 1.12 Ghz 查看CPU情况 cat /proc/cpuinfo # 详细信息 lscpu 上电的时候，默认低功耗模式3，风扇不转 开启最大频率 jetson_clock将CPU，GPU，EMC时钟值设置为当前模式的最大值，并设置风扇转速，为当前的 nvpmodel 模式提供了最佳的性能，并打开散热风扇。 sudo jetson_clocks # TX2 不改变工作模式 sudo jetson_clock --show # 显示CPU、GPU和EMC的当前设置 sudo ~/jetson_clocks.sh # TX1 在JetPack4.2之前的版本上，在/home文件下会有一个 jetson_clocks.sh，如果想要开启高功率模式，直接使用命令行，在最新的JetPack4.2版本中，这个文件消失了，在/usr/bin/jetson_clocks 目录下，已经集成成为了一个软件，直接执行就可以启动小风扇了，瞬间温度就下来了。 查询当前工作模式 sudo nvpmodel -q sudo nvpmodel -q –-verbose # 详细信息 修改工作模式 sudo nvpmodel -m 0 # 0,6核全开最大频率模式 sudo nvpmodel -m 1 # 1,4核最小频率 sudo nvpmodel -m 2 # 2,6核全开均衡模式 The file /etc/nvpmodel.conf holds the different models. Developers can add their own models to add different modes suitable to their application. nvpmodel模式更改后，重启后数值会保持。 风扇控制 风扇转速文件/sys/devices/pwm-fan/target-pwm 查看风扇转速 cat /sys/devices/pwm-fan/target-pwm 修改风扇转速 修改风扇转速文件即可改变转速 sudo sh -c 'echo 255 > /sys/devices/pwm-fan/target_pwm' #sudo echo 255 > /sys/devices/pwm-fan/target-pwm #bash: /sys/devices/pwm-fan/target_pwm: Permission denied 值（0~255）来修改风扇的风速 //#sudo echo 200 > /sys/devices/pwm-fan/target-pwm bash: /sys/devices/pwm-fan/target_pwm: Permission denied 可以看到 bash 拒绝这么做，说是权限不够。这是因为重定向符号 “>” 也是 bash 的命令。我们使用 sudo 只是让 echo 命令具有了 root 权限，但是没有让 “>” 命令也具有 root 权限，所以 bash 会认为这两个命令都没有的权限。解决这一问题需要利用 \"sh -c\" 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：sudo sh -c 'echo 255 > /sys/devices/pwm-fan/target_pwm 设置风扇开机一直转 设置开机运行，创建并编辑rc.local文档 sudo vi /etc/rc.local 将以下内容添加到文档中 #!/bin/bash sleep 10 sudo sh -c 'echo 80 > /sys/devices/pwm-fan/target_pwm' 保存文档，然后添加权限 sudo chmod u+x rc.local 温度控制 硬件温度检测工具sensors(不推荐) sudo apt-get install lm-sensors # 安装硬件温度检测工具sensors sensors # 显示当前温度 温度文件 温度文件位置 查看硬件类型 cat /sys/devices/virtual/thermal/thermal_zone*/type cat /sys/devices/virtual/thermal/thermal_zone4/type # Tboard_tegra 8个温度类型 BCPU-therm MCPU-therm GPU-therm PLL-therm Tboard_tegra Tdiode_tegra PMIC-Die # 第七个温度明显偏高 thermal-fan-est \"Tboard_tegra\" measures the temperature of the Jetson TK1 board (though I'm not sure of the exact location). \"Tdiode_tegra\" measures the temperature at the edge of the Jetson TK1 board. The zones with \"-therm\" in their name are for sensors inside the Tegra SOC. 第七个温度明显偏高 查看硬件温度 cat /sys/devices/virtual/thermal/thermal_zone*/temp cat /sys/devices/virtual/thermal/thermal_zone4/temp # 35000 38000 38000 36500 38000 36000 35000 100000 # 第七个温度明显偏高 37600 以下数字分别对应以上硬件，将数字除以1000得出实际温度（摄氏度） 上电启动 电压电流 The Jetson TX2 module has 3-channel INA3221 monitors at I2C Addresses 0x40 and 0x41. The sysfs nodes to read rail name, voltage, current, and power can be found under the INA3221 driver’s directory: /sys/bus/i2c/drivers/ina3221x Among the listed addresses under the mentioned sysfs directory, 0-0040 and 0-0041 are the power monitors for supply rails on Jetson TX2 module: The following data can be obtained from the Sysfs: Rail Name: ..//iiodevice/rail_name Current (mA): ..//iio_device/in_current_input Voltage (mV):..//iio_device/in_voltage_input Power (mW):..//iio_device/in_power_input The address and channel allocations are given in Table 6-1. To display the name of the GPU rail: cat /sys/bus/i2c/drivers/ina3221x/0-0040/iio_device/rail_name_0 # VDD_SYS_GPU To display the current (in mA) of the GPU rail: cat /sys/bus/i2c/drivers/ina3221x/0-0040/iio_device/in_current0_input # 180 To display the voltage (in mV) of the GPU rail: cat /sys/bus/i2c/drivers/ina3221x/0-0040/iio_device/in_voltage0_input # 730 To display the power (in mW) of the GPU rail: cat /sys/bus/i2c/drivers/ina3221x/0-0040/iio_device/in_power0_input # 1159 jetson-stats / jtop jtop GitHub jtop pypi 安装pip3 sudo apt-get install python3-pip 安装 jetson-stats sudo -H pip3 install jetson-stats sudo -H pip install -U jetson-stats # 更新jtop jtop It is a system monitoring utility that runs on the terminal and see and control realtime the status of your NVIDIA Jetson. CPU, RAM, GPU status and frequency and other... sudo jtop Controls To control the your NVIDIA Jetson are available this keyboard commands: a Start/Stop jetson_clocks service (Note: jetson_clocks start only after 60s from up time) e Enable/==Disable== jetson_clocks on board boot + and - Increase and decrease the NVPmodel p and m Increase and decrease the Fan speed Pages jtop have four different pages to control your NVIDIA Jetson: ALL Are collected all information about your board: CPUs status, Memory, GPU, disk, fan and all status about jetson_clocks, NVPmodel and other GPU A real time GPU history about your NVIDIA Jetson CTRL You can control the status of you INFO Are collected all information about libraries, CUDA, Serial Number, interfaces, ... nvidia@jetson-nano:~/$ sudo jtop -h usage: jtop [-h] [-r REFRESH] [--debug] [--page PAGE] [--version] jtop is a system monitoring utility and control. Runs on terminal optional arguments: -h, --help show this help message and exit -r REFRESH refresh interval --debug Run with debug logger --page PAGE Open fix page --version show program's version number and exit jetson-release The command show the status and all information about your NVIDIA Jetson jetson_variables This script generate the easy environment variables to know which is your Hardware version of the Jetson and which Jetpack you have already installed 查看系统信息 sudo jetson-release 查看Jetson TX2 L4T版本 head -n 1 /etc/nv_tegra_release ``#R32 (release), REVISION: 1.0, GCID: 14531094, BOARD: t186ref, EABI: aarch64, DATE: Wed Mar 13 07:41:08 UTC 2019 修改显示器分辨率 https://blog.csdn.net/cugxyy6/article/details/78368934 查看当前的分辨率，带*号的为当前分辨率 xrandr # xrandr -q Screen 0: minimum 320 x 200, current 1440 x 900, maximum 8192 x 8192 VGA1 connected 1440x900+0+0 (normal left inverted right x axis y axis) 0mm x 0mm 1360x768 59.8 1024x768 60.0 800x600 60.3 56.2 848x480 60.0 640x480 59.9 59.9 其中VGA1为显示器名称。可以看到当前使用的显卡是 VGA1（后续显示模式在此显卡上添加），列表中并无 1440x900 的分别率可用。这时可以使用 xrandr 命令新增显示模式，由于显示模式有一定的格式，如果不知道如何配置，可以通过cvt 命令来获得。 查询配置格式 cvt 使用方法：cvt X Y，X 表示分辨率宽度，Y 表示分辨率高度。如生成 1280x800 的分辨率，可使用命令： cvt 1440 900 1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz Modeline \"1440x900_60.00\" 106.50 1440 1528 1672 1904 900 903 909 934 -hsync +vsync 将 cvt 得到的显示模式使用 xrandr 命令添加： # 设置新的分辨率模式 xrandr --newmode \"1440x900\" 106.50 1440 1528 1672 1904 900 903 909 934 -hsync +vsync # 删除添加的分辨率模式 # xrandr --rmmode 1440x900 # 添加新的模式 xrandr --addmode VGA1 1440x900 # 指定输出设备 xrandr --output VGA1 --mode 1440x900 立马启用修改后的配置： source /etc/profile 这时就可以在显示器分辨率设置里使用 1440x900 的分辨率了。 可能在每次开机时，又不能使用设定好的分辨率了，使用如下命令： sudo gedit ~/.profile 在 ~/.profile 最末尾添加修改分辨率的命令： cvt 1440 900 xrandr --newmode 1440x900 106.50 1440 1528 1672 1904 900 903 909 934 -hsync +vsync xrandr --addmode VGA1 1440x900 重启系统后再登录即可，此时再用 xrandr 命令，即可看到新添加的分辨率。 网络设置 wifi 优先级 网络设置中 Connection priority for auto-activation 数值越大优先级越高，可正可负，默认0 Ubuntu 设置静态ip 查看ip所处网段 ifconfig eth0: flags=4099 mtu 1500 ether 00:04:4b:dd:50:80 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 41 l4tbr0: flags=4099 mtu 1500 inet 192.168.55.1 netmask 255.255.255.0 broadcast 192.168.55.255 inet6 fe80::1 prefixlen 128 scopeid 0x20 inet6 fe80::a81b:2eff:fe2d:98dc prefixlen 64 scopeid 0x20 ether 96:8d:f0:0a:81:05 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 8 bytes 736 (736.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1 (Local Loopback) RX packets 2977 bytes 218595 (218.5 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2977 bytes 218595 (218.5 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 rndis0: flags=4099 mtu 1500 ether 96:8d:f0:0a:81:05 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 usb0: flags=4099 mtu 1500 ether 96:8d:f0:0a:81:07 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 wlan0: flags=4163 mtu 1500 inet 192.168.1.102 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::eb92:e8b3:8b74:50e2 prefixlen 64 scopeid 0x20 ether 00:04:4b:dd:50:7e txqueuelen 1000 (Ethernet) RX packets 25980 bytes 22830716 (22.8 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 19052 bytes 3072476 (3.0 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 查到当前wifi的ip为192.168.1.102 查看网关 ip rout show default via 192.168.1.1 dev wlan0 proto dhcp metric 600 default via 192.168.55.100 dev l4tbr0 metric 32766 linkdown 169.254.0.0/16 dev l4tbr0 scope link metric 1000 linkdown 172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 192.168.1.0/24 dev wlan0 proto kernel scope link src 192.168.1.102 metric 600 192.168.55.0/24 dev l4tbr0 proto kernel scope link src 192.168.55.1 linkdown 第一行 default为默认网关，192.168.1.1为无线网关，wlan0无线网卡 第二行 为有线/桥接网关？？ 查到当前的无线网关为192.168.1.1 方法一 为每个网络设置ip 网络 – edit connection – 535wifi – IPV4 Setting – Method – Manual – 添加网络配置 Adress（静态 ip192.168.1.35）， Netmask（子网掩码 255.255.255.0），Geteway（网关 192.168.1.1），DNS servera（DNS解析 8.8.8.8），Search domains空着 按照上面查询的信息填写，静态ip地址要与当前ip/网关处于同一网段 断开网络重新连接，查看新的ip地址 方法二 修改配置文件（不推荐） sudo gedit /etc/n 修改内容如下： auto lo iface lo inet loopback auto wlan0 # 设置自动启动eth0接口 iface wlan0 inet static # 配置静态IP address 192.168.1.35 # 静态IP地址 netmask 255.255.255.0 # 子网掩码 gateway 192.168.1.1 # 默认网关 dns-nameserver 8.8.8.8 # DNS解析地址 重启网卡 sudo /etc/init.d/networking restart root 自动登录 https://www.jianshu.com/p/51f3653d87ad https://blog.csdn.net/qq_38196234/article/details/89558855 启动图形界面 Ubuntu 的系统运行级别： Runlevel 0 : 关机级别 Runlevel 1 : 单用户运行级别，运行rc.sysinit和rc1.d目录下的脚本，维护模式 Runlevel 2 : 多用户，无图形系统，但系统不会启动NFS，没有网络服务 Runlevel 3 : 多用户，无图形系统，系统启动具有网络功能 Runlevel 4 : 用户自定义级别，多用户，无图形系统 Runlevel 5 : 多用户，图形界面模式 Runlevel 6 : 重启级别 开机进入命令行模式 sudo systemctl set-default multi-user.target # sudo systemctl set-default runlevel3.target # 或者 sudo reboot 临时使用一次图形界面进入 startx # sudo systemctl start lightdm # 或者 从图形界面切换回命令行：ctrl+alt+F7?? 开机进入图形用户界面 sudo systemctl set-default graphical.target # sudo systemctl set-default runlevel5.target # 或者 sudo reboot 从命令行切换到图形界面：ctrl+alt+F7?? 开机启动提示文字 https://ubuntuqa.com/article/1131.html sudo gedit /etc/default/grub 修改两行 GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\" GRUB_CMDLINE_LINUX=\"“ //#桌面的默认设置(即仅限启动画面)： GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\" # Hide text and show splash GRUB_CMDLINE_LINUX=\"“ //#什么都不显示直接从黑屏到进入登录界面 GRUB_CMDLINE_LINUX_DEFAULT=“quiet” # Don't show Ubuntu bootup text GRUB_CMDLINE_LINUX=\"console=tty12\" # Don't show kernel text # Redirect the kernel output to another tty //#显示详细的开机信息文字 GRUB_CMDLINE_LINUX_DEFAULT=\"\" # Show text but not the splash GRUB_CMDLINE_LINUX=\"“ quiet 内核启动时候简化提示信息 splash 启动的时候使用图形化的进度条代替init的字符输出过程 \"quiet splash\" 简化提示信息 ，且显示五个点的图形化的进度条等待界面 “quiet” 简化提示信息 ，没有五个点的图形化的进度条等待界面 “splash” 显示详细的开机信息，且显示五个点的图形化的进度条等待界面 “” 显示详细的开机信息，代码刷屏开机，没有五个点的图形化的进度条等待界面 sudo update-grub # 更新grub sudo reboot 开机动画 守护进程 开机自启动服务管理 sudo apt-get install sysv-rc-conf sudo sysv-rc-conf 打X的即表示开机启动项，可以把光标移到打叉的地方，输入空格来反选。 # 列出程序开机占用时间排行 systemd-analyze blame # 开机自动启动ssh命令 sudo systemctl enable ssh # 关闭ssh开机自动启动命令 sudo systemctl disable ssh # 单次开启ssh sudo systemctl start ssh # 单次关闭ssh sudo systemctl stop ssh 程序自启动 systemd systemd ubuntu-server-18.04 设置开机启动脚本 比如以前启动 mysql 服务用: sudo service mysql start 现在用： sudo systemctl start mysqld.service systemd 默认读取 /etc/systemd/system 下的配置文件，该目录下的文件会链接/lib/systemd/system/下的文件。 执行 ls /lib/systemd/system 你可以看到有很多启动脚本，其中就有我们需要的 rc.local.service # 查看service配置文件 systemctl cat sshd.service # 查看Systemd默认的启动 Target systemctl get-default # 查看 multi-user.target 包含的所有服务 $ systemctl list-dependencies multi-user.target # 切换到另一个 target # shutdown.target 就是关机状态 $ sudo systemctl isolate shutdown.target 修改开机默认等待时间 sudo gedit /boot/grub/grub.cfg 默认等待时间是10秒 set timeout=3 #默认3秒 显示开机启动项的时间 systemd-analyze # 显示总时间 systemd-analyze blame # 显示详细 chao@deepin:~$ systemd-analyze blame 21.755s apt-daily-upgrade.service 8.214s NetworkManager-wait-online.service 6.929s systemd-networkd-wait-online.service 3.194s plymouth-quit-wait.service 开机启动项 禁用慢的开机启动项 sudo systemctl disable NetworkManager-wait-online.service mask 这个 systemctl 命令的选项参数是比 disable 更强力，彻底禁用。 sudo systemctl mask plymouth-quit-wait.service 挂载磁盘 sudo vim /etc/fstab #/dev/sda1 UUID=686ad259-fad4-4e68-9237-e375e0d0ea32 / ext4 rw,relatime,data=ordered 0 1 #/dev/sda4 UUID=21017bab-45da-48c8-8376-62fa5746e0dc /home ext4 rw,relatime,data=ordered 0 2 #/dev/sdb1 LABEL=EFI040system040partition UUID=1892-5B3E /boot/efi vfat rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro 0 2 #/dev/sda2 UUID=f2df352f-4e45-459d-8238-da663753209f none swap defaults,pri=-2 0 0 登录shell 系统可用的shell环境 cat /etc/shells 查看系统当前shell ls -l /bin/sh # lrwxrwxrwx 1 root root 4 Jan 2 12:55 /bin/sh -> dash 配置dash让bash为默认shell sudo dpkg-reconfigure dash # 选择 取消默认配置dash，自动配置为bash # lrwxrwxrwx 1 root root 4 May 17 21:59 /bin/sh -> bash 修改用户登录 Shell sudo usermod -s /bin/bash 用户名 # 修改用户登录 Shell SSH登录 将网络设置为与其他用户共享，才能在开机后不登录就自动连接网络。 桌面共享 https://blog.csdn.net/u014337397/article/details/81140692 Ubuntu 16.04使用root 帐号开启 SSH 登录 https://blog.csdn.net/wy_97/article/details/78294562 CLion远程同步及调试 远程端依赖rsync sudo apt-get install rsync # jetson安装同步工具 仅需设置本地CLion即可实现远程编辑和调试，设置Deployment通过SSH登录远程jetson即可实现代码同步编程，通过设置远程toolchain工具链可直接使用jetson的工具链进行编译调试。 设置本地CLion 设置Deployment File | Settings | Build, Execution, Deployment | Deployment | +号 SFPT 填写远程登录jensonTX2的帐号密码，点对号set as default 设为默认 删除编译文件夹cmake-build-debug 删除当前项目的编译文件夹cmake-build-debugcmake-build-debug 设置远程Toolchains 设置远程的jetsonTX2自己的编译工具链 添加远程工具链后 Deployment 中会自动新增一个临时连接，保留不做任何修改即可。 编译 直接编译运行 Reload CMake Project？？ 删除编译文件夹cmake-build-debug，右键Reload CMake Project 可能报错Cannot read /home/chao/Documents/Harvest/can_ddb/cmake-build-debug/CMakeCache.txt 解决：将 Toolchains 换成默认的本机编译器（同时会自动删除Deployment的临时连接），删除编译文件夹cmake-build-debug，重启Clion，删除编译文件夹cmake-build-debug，重新设置 Toolchains 为远程 Remote Host，删除添加远程工具链后 Deployment 中会自动新增一个临时连接，删除编译文件夹cmake-build-debug，Reload CMake Project 可能报错Cannot generate into /home/chao/Documents/Harvest/can_ddb/cmake-build-debug Cannot create directory Please either delete it manually or select another generation directory 解决：删除添加远程工具链后 Deployment 中会自动新增一个临时连接，删除编译文件夹cmake-build-debug，重启Clion，不需要删除编译文件夹cmake-build-debug，重新设置 Toolchains 为远程 Remote Host，ok会自动编译 调用窗口工具栏 Tool – Deployment – Browse remote host – 浏览远程文件夹 Tool – Srart ssh session – 终端远程登录jetsonTX2 外设IO GPIO Linux GPIO简介 Linux内核中gpio是最简单，最常用的资源(和 interrupt ,dma,timer一样)驱动程序，应用程序都能够通过相应的接口使用gpio，gpio使用0～MAX_INT之间的整数标识，不能使用负数,gpio与硬件体系密切相关的 应用程序空间GPIO支持 Linux GPIO支持导出GPIO控件和状态的功能，以便与使用sysfs的应用程序一起使用。没有其他驱动程序可以这样使用感兴趣的GPIO。像cat和echo这样的简单工具可用于快速读取GPIO输入的当前状态值或设置GPIO输出的电平。 在sysfs中配置内核以支持GPIO 在从应用程序空间访问GPIO之前，您可能需要在sysfs中启用GPIO支持。 Symbol: GPIO_SYSFS [=y] Prompt: /sys/class/gpio/... (sysfs interface) Defined at drivers/gpio/Kconfig:51 Depends on: GPIOLIB && SYSFS && EXPERIMENTAL Location: -> Kernel configuration -> Device Drivers -> GPIO Support (GPIOLIB [=y]) 从应用程序空间启用GPIO 在此示例中，GPIO 22 导出到应用程序空间。 打开shell终端 首先要直接使用来自Jetson的GPIO引脚，需要“导出”。这告诉Tegra的GPIO驱动程序该引脚将用作GPIO。 GPIO参考表将gpio引脚映射到sysfs引脚号。 echo 186 > /sys/class/gpio/export # 导出注册gpio 引脚可以设置为输入或输出 echo out > /sys/class/gpio/gpio186/direction # 设置gpio方向输出out echo in > /sys/class/gpio/gpio186/direction # 设置gpio方向输入in 引脚默认为“高电平有效”（当引脚保持高电平时读为1），也可以设置低电平有效（引脚保持低电平时读为1） echo 1 > /sys/class/gpio/gpio186/active_low # 设置低电平有效 echo 0 > /sys/class/gpio/gpio186/active_low # 保持默认高电平有效 读取引脚的当前值，返回1或0 cat /sys/class/gpio/gpio186/value 引脚赋值（需引脚配置为输出） echo 1 > /sys/class/gpio/gpio186/value # gpio赋值1 echo 0 > /sys/class/gpio/gpio186/value # gpio赋值0 查看当前正在使用的GPIO引脚及其状态 sudo cat /sys/kernel/debug/gpio shell脚本示例 GPIO=22 # 定义变量 ls /sys/class/gpio/ # 有export unexport两个只写文件 echo $GPIO > /sys/class/gpio/export # 导出注册gpio # export导出到用户空间后，出现gpio$GPIO文件夹 ls /sys/class/gpio$GPIO/ # 出现direction value文件 echo out > /sys/class/gpio/gpio$GPIO/direction # 设置gpio方向输出out echo 1 > /sys/class/gpio/gpio$GPIO/value # 赋值1 echo 0 > /sys/class/gpio/gpio$GPIO/value # 赋值0 echo in > /sys/class/gpio/gpio$GPIO/direction # 设置gpio方向输入in cat /sys/class/gpio/gpio$GPIO/value # 读取gpio状态值 echo 1 > /sys/class/gpio/gpio186/active_low # 设置低电平有效 echo 0 > /sys/class/gpio/gpio186/active_low # 保持默认高电平有效 echo $GPIO > /sys/class/gpio/unexport # 导出注销gpio GPIO从用户空间中断 使用poll()直到GPIO0上的输入级别发生变化 内核中gpio的使用 ​ 1 测试gpio端口是否合法 int gpio_is_valid(int number); ​ 2 申请某个gpio端口当然在申请之前需要显示的配置该gpio端口的pinmux ​ int gpio_request(unsigned gpio, const char *label) ​ 3 标记gpio的使用方向包括输入还是输出 ​ /成功返回零失败返回负的错误值/ ​ int gpio_direction_input(unsigned gpio); ​ int gpio_direction_output(unsigned gpio, int value); ​ 4 获得gpio引脚的值和设置gpio引脚的值(对于输出) ​ int gpio_get_value(unsigned gpio); ​ void gpio_set_value(unsigned gpio, int value); ​ 5 gpio当作中断口使用 ​ int gpio_to_irq(unsigned gpio); ​ 返回的值即中断编号可以传给request_irq()和free_irq() ​ 内核通过调用该函数将gpio端口转换为中断，在用户空间也有类似方法 ​ 6 导出gpio端口到用户空间 ​ int gpio_export(unsigned gpio, bool direction_may_change); ​ 内核可以对已经被gpio_request()申请的gpio端口的导出进行明确的管理， ​ 参数direction_may_change表示用户程序是否允许修改gpio的方向，假如可以 ​ 则参数direction_may_change为真 ​ / 撤销GPIO的导出 / ​ void gpio_unexport(); 用户空间gpio的调用 用户空间访问gpio，即通过sysfs接口访问gpio，下面是/sys/class/gpio目录下的三种文件： ​ --export/unexport文件接口 ​ --gpioN指代具体的gpio引脚 ​ --gpio_chipN指代gpio控制器 ​ 必须知道以上接口没有标准device文件和它们的链接。 (1) export/unexport文件接口： /sys/class/gpio/export，该接口只能写不能读 用户程序通过写入gpio的编号来向内核申请将某个gpio的控制权导出到用户空间当然前提是没有内核代码申请这个gpio端口 ​ 比如 echo 19 > export ​ 上述操作会为19号gpio创建一个节点gpio19，此时/sys/class/gpio目录下边生成一个gpio19的目录 ​ /sys/class/gpio/unexport和导出的效果相反。 ​ 比如 echo 19 > unexport ​ 上述操作将会移除gpio19这个节点。 (2) /sys/class/gpio/gpioN ​ 指代某个具体的gpio端口,里边有如下属性文件 ​ direction 表示gpio端口的方向，读取结果是in或out。该文件也可以写，写入out 时该gpio设为输出同时电平默认为低。 写入in时， 设置gpio方向为输入，==设为输入引脚初始化电平不确定（浮空）==!!!，为上一次输入电平（开机时为0）！！,作为输入引脚必须上拉或下拉。 写入out 时， 设置gpio方向为==输出==，同时设为输出引脚初始化电平为==默认为低==0。 写入low或high则不仅可以设置为输出 还可以设置输出的电平。 当然如果内核不支持或者内核代码不愿意，将不会存在这个属性,比如内核调用了gpio_export(N,0)就表示内核不愿意修改gpio端口方向属性 ​ value 表示gpio引脚的电平,0(低电平)1（高电平）,如果gpio被配置为输出，这个值是可写的，记住任何非零的值都将输出高电平, 如果某个引脚能并且已经被配置为中断，则可以调用poll(2)函数监听该中断，中断触发后poll(2)函数就会返回。 ​ edge 表示中断的触发方式，edge文件有如下四个值：\"none\", \"rising\", \"falling\"，\"both\"。 ​ none表示引脚为输入，不是中断引脚 ​ rising表示引脚为中断输入，上升沿触发 ​ falling表示引脚为中断输入，下降沿触发 ​ both表示引脚为中断输入，边沿触发 这个文件节点只有在引脚被配置为输入引脚的时候才存在。 当值是none时可以通过如下方法将变为中断引脚 echo \"both\" > edge;对于是both,falling还是rising依赖具体硬件的中断的触发方式。此方法即用户态gpio转换为中断引脚的方式 ​ active_low 不怎么明白，也木有用过 (3)/sys/class/gpio/gpiochipN ​ gpiochipN表示的就是一个gpio_chip,用来管理和控制一组gpio端口的控制器，该目录下存在一下属性文件： ​ base 和N相同，表示控制器管理的最小的端口编号。 ​ lable 诊断使用的标志（并不总是唯一的） ​ ngpio 表示控制器管理的gpio端口数量（端口范围是：N ~ N+ngpio-1） 用户态使用gpio监听中断 首先需要将该gpio配置为中断 echo \"rising\" > /sys/class/gpio/gpio12/edge 以下是伪代码 int gpio_id; struct pollfd fds[1]; gpio_fd = open(\"/sys/class/gpio/gpio12/value\",O_RDONLY); if( gpio_fd == -1 ) err_print(\"gpio open\"); fds[0].fd = gpio_fd; fds[0].events = POLLPRI; ret = read(gpio_fd,buff,10); if( ret == -1 ) ​ err_print(\"read\"); while(1){ ​ ret = poll(fds,1,-1); ​ if( ret == -1 ) ​ err_print(\"poll\"); ​ if( fds[0].revents & POLLPRI){ ​ ret = lseek(gpio_fd,0,SEEK_SET); ​ if( ret == -1 ) ​ err_print(\"lseek\"); ​ ret = read(gpio_fd,buff,10); ​ if( ret == -1 ) ​ err_print(\"read\"); ​ /此时表示已经监听到中断触发了，该干事了/ ​ ............... ​ } } 记住使用poll()函数，设置事件监听类型为POLLPRI和POLLERR在poll()返回后，使用lseek()移动到文件开头读取新的值或者关闭它再重新打开读取新值。必须这样做否则poll函数会总是返回。 python Jetson.GPIO NVIDIA官方库jetson-gpio Jetson.GPIO 项目描述 Jetson.GPIO - 适用于Tegra的Linux Jetson TX1，TX2，AGX Xavier和Nano开发板包含一个40引脚GPIO接头，类似于Raspberry Pi中的40引脚接头。可以使用Jetson GPIO Library包中提供的Python库来控制这些GPIO的数字输入和输出。该库与Raspberry Pi的RPi.GPIO库具有相同的API，以便提供一种将Raspberry Pi上运行的应用程序移动到Jetson板的简便方法。 本文档将介绍Jetson GPIO库包中包含的内容，如何配置系统以及运行提供的示例应用程序和库API。 串口 Jetson TX2——串口的使用（TTL-RS485） 在jetson tx2上使用串口通信 Serial Console – NVIDIA Jetson TX2 串口调试 串口调试 USB转串口的适配器，按芯片来分，有以下几种：CP2104, PL2303, CH340 注意：RK3399默认的波特率是1500000，有些USB转串口芯片波特率无法达到1500000，同一芯片的不同系列也可能会有差异，所以在选购之前一定要确认是否支持。 硬件连接 串口转 USB 适配器，有四根不同颜色的连接线： J21接口–ttyTHS1–控制台串口(serial console) Jetson TX2 J21 Pin 8 (UART 1 TXD) → Cable RXD (White Wire) Jetson TX2 J21 Pin 10 (UART 1 RXD) → Cable TXD (Green Wire) Jetson TX2 J21 Pin 9 (GND) → Cable GND (Black Wire) J17接口–ttyTHS2–空闲 Pin 1: GND Pin 2 : UART_RTS Pin 3 : NULL Pin 4 : UART_RXD Pin 5 : UART_TXD Pin 6 : UART_CTS 开发板与串口调试助手对应依次连接 3.3V 电源，不需要连接 注：如使用其它串口适配器遇到TX和RX不能输入和输出的问题，可以尝试对调TX和RX的连接。 确保Jetson关闭并接线 然后将USB连接器插入主机。 连接参数 jetsonTX2 使用以下串口参数： 波特率：115200 数据位：8 停止位：1 奇偶校验：无 流控：无 主机端Ubuntu上使用串口调试 安装 minicom 串口调试助手 sudo apt-get install minicom 查看串口设备 lsusb # 查看usb设备 ls /dev/ttyUSB* # 示例是 /dev/ttyUSB0 运行配置minicom sudo minicom # 启动minicom # sudo minicom -s # 或者直接进入minicom设置界面 Welcome to minicom 2.7OPTIONS: I18nCompiled on Jan 1 2014, 17:13:19.Port /dev/ttyUSB0, 15:57:00Press CTRL-A Z for help on special keys 按 Ctrl-a 松开然后再按 Z 就可以调出帮助菜单。 +-------------------------------------------------------------------+ Minicom Command Summary | | Commands can be called by CTRL-A | | Main Functions Other Functions | | | | Dialing directory..D run script (Go)....G | Clear Screen.......C | | Send files.........S Receive files......R | cOnfigure Minicom..O | | comm Parameters....P Add linefeed.......A | Suspend minicom....J | | Capture on/off.....L Hangup.............H | eXit and reset.....X | | send break.........F initialize Modem...M | Quit with no reset.Q | | Terminal settings..T run Kermit.........K | Cursor key mode....I | | lineWrap on/off....W local Echo on/off..E | Help screen........Z | | Paste file.........Y Timestamp toggle...N | scroll Back........B | | Add Carriage Ret...U | | | | Select function or press Enter for none. | +--------------------------------------------------------------------+ 根据提示按O进入设置界面，如下： +-----[configuration]------+ | Filenames and paths | | File transfer protocols | | Serial port setup | | Modem and dialing | | Screen and keyboard | | Save setup as dfl | | Save setup as.. | | Exit | +--------------------------+ 把光标移动到“Serial port setup”，按enter进入串口设置界面，再输入前面提示的字母，选择对应的选项，设置成如下： +-----------------------------------------------------------------------+ | A - Serial Device : /dev/ttyUSB0 | | B - Lockfile Location : /var/lock | | C - Callin Program : | | D - Callout Program : | | E - Bps/Par/Bits : 115200 8N1 | | F - Hardware Flow Control : No | | G - Software Flow Control : No | | Change which setting? | +-----------------------------------------------------------------------+ 注意：Hardware Flow Control和Software Flow Control都要设成No，否则可能导致无法输入。 设置完成后回到上一菜单，选择“Save setup as dfl”即可保存为默认配置，以后将默认使用该配置。 报错解决: minicom: cannot open /dev/modem: No such file or directory sudo ln -s /dev/ttyS0 /dev/modem # 做一个软链接到/dev/ttyS0 # minicom -s # 或者设置一下 然后，您可以启动Jetson，此时您将看到内核日志开始在主机上的Minicom窗口上滚动 jetsonTX2端 在Jetson TX2上共有5路UART接口，通过使用命令可以查看在设备上已经启用的串口， TX2的底板上默认启用的有三个串口，分别是位于J21的ttyTHS1控制台串口(serial console)启动时会通过它打印一系列消息，位于J17的ttyTHS2串口，以及蓝牙模块的ttyTHS3串口，ttyTHS1和ttyTHS2有外接扩展口，由于ttyTHS1为控制台串口会打印一系列调试信息，因此串口通讯测试选择位于J17的ttyTHS2串口 ls -l /dev/ttyTHS* # 查看设备上已经启用的串口 ttyTHS1 —- 控制台串口(serial console) —- J21接口 ttyTHS2 —- 空闲 —- J17接口 ttyTHS3 —- 蓝牙模块 —- 蓝牙（无外接口） Linux下使用USB转串口设备 默认情况下ubuntu已经安装了USB转串口驱动(pl2303或者cp210x的) 查看USB转串口驱动 lsmod | grep usbserial usbserial 45056 1 pl2303 插上USB转串口 ls /dev/ttyUSB* dmesg | grep ttyUSB0 如果出现连接成功信息，则说明ubuntu系统已经识别该设备了。 I2C I2C Tools 工具 sudo apt-get install libi2c-dev i2c-tools I2C总线扫描 i2cdetect -l i2c-0 代表 I2C0 i2c-0 代表 I2C0 I2C设备查询 sudo i2cdetect -y -r 1 若总线上挂载I2C从设备，可通过i2cdetect扫描某个I2C总线上的所有设备 寄存器内容写入 i2cset -y 1 0x50 0x00 0x13 -y 代表曲线用户交互过程，直接执行指令 1 代表I2C总线编号 0x50 代表I2C设备地址，此处选择AT24C04的低256字节内容 0x00 代表存储器地址 0x13 代表存储器地址中的具体内容 寄存器内容读出 i2cget -y 1 0x50 0x00 -y 代表曲线用户交互过程，直接执行指令 1 代表I2C总线编号 0x50 代表I2C设备地址，此处选择AT24C04的低256字节内容 0x00 代表存储器地址 寄存器所有内容导出 i2cdump -y 1 0x51 -y 代表取消用户交互过程，直接执行指令； 1 代表I2C总线编号； 0x51 代表I2C设备从机地址，此处选择AT24C04的高256字节内容。 CAN通信 Jetson TX2——CAN口的使用 socketcan包是CAN协议的实现（控制器区域网络）适用于Linux。CAN是一种网络技术它广泛用于自动化，嵌入式设备和汽车领域。 TX2硬件连接 TX2的J26模块下的CAN0及CAN1控制器接口通过canbus收发器的CTX和CRX相接进行实测。 TX2的J26模块下的CAN0的CAN0_RX，CAN0_TX分别接CAN收发器的RX，TX CAN口 -> Signal J26接口 CAN收发器 ----------->---------------------------------- CAN0 -> CAN0_RX -> Pin5 -> RX CAN0 -> CAN0_TX -> Pin7 -> TX -> VDD_3V3 -> Pin2 -> VCC -> GND -> Pin10 -> GND CAN1 -> CAN1_RX -> Pin15 -> RX CAN1 -> CAN1_TX -> Pin17 -> TX CAN0 J26接口 CAN1 J26接口 CAN0_RX Pin5 CAN1_RX Pin15 CAN0_TX Pin7 CAN1_TX Pin17 不需要重新编译内核 TX2已经写好了canbus的驱动并集成到了SDK中，已经支持canbus无需多做处理。 安装canbus模块（Linux将不常用的模块做成.ko文件，在需要使用时可以将其进行载入内核，降低系统的开销） 直接通过运行Shell脚本can.sh加载所需的.ko文件，脚本文件如下所示。需要管理员权限 #！/bin/bash sudo modprobe can # 插入can总线子系统(Insert CAN BUS subsystem support module) sudo modprobe can_dev # 插入can_dev模块(can driver with netlink support) sudo modprobe can-raw # 插入can原始协议模块(Insert Raw CAN protocol module) #sudo modprobe can-bcm # the broadcast manager (BCM) #sudo modprobe can-gw # ？？filtering options？？ sudo modprobe mttcan # 真正的can口支持(Real CAN interface support) 虚拟can设备？？用于测试 $ modprobe can $ modprobe can_raw $ modprobe vcan # 加载虚拟can设备 $ sudo ip link add dev vcan0 type vcan # 添加 $ sudo ip link set up vcan0 # 启用 $ ip link show vcan0 $ ip link del vcan0 # 删除 通过lsmod 命令检查是否安装成功 lsmod # 检查canbus模块是否安装成功 通过lsmod 命令检查是否安装成功，如果成功则如下所示。 Module Size Used by can_gw 10919 0 can_bcm 16471 0 mttcan 64903 0 can_dev 13306 1 mttcan can_raw 10388 0 can 46600 3 can_raw,can_bcm,can_gw 安装第三方开源工具 can-utils 测试canbus sudo apt-get install can-utils can-utils工具常用命令？？有问题 使用canconfig、canecho、cansend、candump、cansequence五个工具，检测和监控Socket CAN接口 配置CAN的总线通讯波特率： canconfig can0 bitrate 500000 # 配置can0波特率500k 开启 / 重启 / 关闭CAN总线 canconfig canX start # 开启 canconfig canX stop canconfig canX restart 查看CAN总线状态 canecho can0 # 查看can0状态 发送信息 cansend canX –-identifier=ID + 数据 cansend canX –-identifier=0x123 1A2B3C4D5E6F7788 # 发送数据，=0x123,=1A2B3C4D5E6F7788 接收数据 candump can0 # 接收数据 使用滤波器接收ID匹配的数据 candump canX –-filter=ID:mask candump canX –-filter=0x123:0x7ff # ？？ 配置canbus属性 #常用ip配置命令 ip link set can0 type can help # 获取帮助信息 ip link set can0 type can bitrate 500000 #设置can0波特率500k sudo ip link set can0 up # 挂载can0 #ifconfig can0 up # 挂载can0 #ip link set canX type can restart-ms 100 # 启用自动总线关闭恢复？？ ip link set canX type can restart # 直接重启can ip -details link show can0 # 查看can总线状态 ip -details -statistics link show can0 # 查看can口工作状态 ip link set can0 down # 关闭can0口 #ifconfig can0 down # 关闭can0 Usage: ip link set DEVICE type can ​ [ bitrate BITRATE [ sample-point SAMPLE-POINT] ] | ​ [ tq TQ prop-seg PROP_SEG phase-seg1 PHASE-SEG1 ​ phase-seg2 PHASE-SEG2 [ sjw SJW ] ] ​ [ dbitrate BITRATE [ dsample-point SAMPLE-POINT] ] | ​ [ dtq TQ dprop-seg PROP_SEG dphase-seg1 PHASE-SEG1 ​ dphase-seg2 PHASE-SEG2 [ dsjw SJW ] ] ​ [ loopback { on | off } ] # 回环 ​ [ listen-only { on | off } ] ​ [ triple-sampling { on | off } ] ​ [ one-shot { on | off } ] ​ [ berr-reporting { on | off } ] ​ [ fd { on | off } ] ​ [ fd-non-iso { on | off } ] ​ [ presume-ack { on | off } ] ​ [ restart-ms TIME-MS ] ​ [ restart ] ​ [ termination { 0..65535 } ] ​ Where: BITRATE := { 1..1000000 } ​ SAMPLE-POINT := { 0.000..0.999 } ​ TQ := { NUMBER } ​ PROP-SEG := { 1..8 } ​ PHASE-SEG1 := { 1..8 } ​ PHASE-SEG2 := { 1..8 } ​ SJW := { 1..4 } ​ RESTART-MS := { 0 | NUMBER } 环回模式（自测） sudo ip link set can0 type can bitrate 500000 loopback on # 设置can0波特率500k，回环模式 sudo ip link set can0 up # 挂载can0 #sudo ifconfig can0 up # 挂载can0 sudo ip link set can1 type can bitrate 500000 loopback on # 设置can1 sudo ip link set can1 up # 挂载can1 ifconfig # 检查can是否挂载成功 ip -details -statistics link show can0 # 检查can口状态 ip -details link show can1 收发数据测试can是否启用 # 终端1 # cansend can口号 优先级（3位或8位16进制数）#数据位（16位） # 发送CAN数据 cansend can0 5A1#1122334455667788 # 为3位十六进制数 cansend can1 123#1A2B3C4D5E6F7788 # 最多16个数据位，十六进制数据 # 终端2 # candump can口号 # 接收CAN数据，处于阻塞状态 candump can0 # 等待接收CAN数据 candump can1 sudo ip link set can0 down # 关闭can0口 #sudo ifconfig can0 down # 关闭can0 sudo ip link set can1 down # 关闭can1口 使用can收发器实测 实测下配置canbus属性 # 实测下canbus属性配置 sudo ip link set can0 type can bitrate 500000 #设置can0波特率500k sudo ip link set can0 up # 挂载can0 #sudo ifconfig can0 up # 挂载can0 CAN_Mode_Silent:静默模式，简单理解收到数据不发送应答信号。?? ip link set can0 type can bitrate 500000 dbitrate 2000000 berr-reporting on fd on 检查can是否挂载成功 ifconfig # 检查can是否挂载成功 查看can口状态 ip -details -statistics link show can0 # 检查can口状态 ip -details link show can1 Usage: ip [ OPTIONS ] OBJECT { COMMAND | help } ip [ -force ] -batch filename where OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | fou | macsec | tcp_metrics | token | netconf | ila | vrf | sr } OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] { inet | inet6 | ipx | dnet | mpls | bridge | link } | -4 | -6 | -I | -D | -B | -0 | -l[oops] { maximum-addr-flush-attempts } | -br[ief] | -o[neline] | -t[imestamp] | -ts[hort] | -b[atch][filename] | -rc[vbuf][size] | -n[etns] name | -a[ll] | -c[olor]} 在一个终端通过cansend can0(can1) ×××命令来发送数据×××, 另一个终端通过candump can0(can1)进行回环发送 发送数据 broadcasting a can data packet: cansend # 终端1 # cansend can口号 优先级（3位或8位16进制数）#数据位（16位） # 发送CAN数据 cansend can0 5A1#1122334455667788 # 为3位十六进制数 cansend can0 5A1#11.2233.44556677.88 # . 可作为分隔符 cansend can0 123#1A2B3C4D5E6F7788 # 最多16个数据位，十六进制数据 cansend can0 123#123456ABCDEF # 数据位也为十六进制数据 cansend can1 5A1#1122334455667788 ：3位或8位16进制数，3位标准数据帧，8位扩展帧 {data}： 0..8字节，最多16位数据，16进制数， (可以使用.作为分隔符) #标准数据帧 cansend can0 5A1#1122334455667788 # 为0x5A1，data数据内容为0x1122334455667788 #扩展帧 cansend can0 12345678#aabbccdd # 为0x12345678，内容为0xaabbccdd #远程帧 cansend can0 123#R7 # 为0x123，长度为7 Usage: cansend - simple command line tool to send CAN-frames via CAN_RAW sockets. Usage: cansend : #{R|data} for CAN 2.0 frames ##{data} for CAN FD frames : can have 3 (SFF) or 8 (EFF) hex chars {data}: has 0..8 (0..64 CAN FD) ASCII hex-values (optionally separated by '.') : a single ASCII Hex value (0 .. F) which defines canfd_frame.flags Examples: 5A1#11.2233.44556677.88 / 123#DEADBEEF / 5AA# / 123##1 / 213##311 1F334455#1122334455667788 / 123#R for remote transmission request. 接收数据 Receiving a can data packet: candump # 终端2 # candump can口号 # 接收CAN数据，处于阻塞状态 candump can0 # 等待接收CAN数据 candump can1 进程为阻塞型，can设备将一直会接收发来的can消息，直到用户终止。 接收的数据 can0 5A1 [8] 11 22 33 44 55 66 77 88 can0 5A1 [8] 11 22 33 44 55 66 77 88 关闭can口 sudo ip link set can0 down # 关闭can0口 #sudo ifconfig can0 down # 关闭can0 sudo ip link set can1 down # 关闭can1口 使用应用程序进行测试 中断信号 kill -l # 查看所有中断 chao@deepin:~$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX linux中sleep函数的使用和总结 在linux编程中，有时候会用到定时功能，常见的是用sleep(time)函数来睡眠time秒；但是这个函数是可以被中断的，也就是说当进程在睡眠的过程中，如果被中断，那么当中断结束回来再执行该进程的时候，该进程会从sleep函数的下一条语句执行；这样的话就不会睡眠time秒了； #include #include #include #include void sig_handler(int num){ printf(\"\\nrecvive the signal is %d\\n\", num); } int main(){ int time = 20; signal(SIGINT, sig_handler); printf(\"enter to the sleep.\\n\"); sleep(time); // 睡眠过程中被中断，当中断结束回来再执行的时候，从sleep函数的下一条语句执行 printf(\"sleep is over, main over.\\n\"); exit(0); } enter to the sleep. ^C recvive the signal is 2 sleep is over, main over. 从运行结果可以看出，当我按下Ctrl+c发出中断的时候，被该函数捕获，当处理完该信号之后，函数直接执行sleep下面的语句； 下面的例子是真正的睡眠time时间(不被中断影响)： #include #include #include #include void sig_handler(int num){ printf(\"\\nrecvive the signal is %d\\n\", num); } int main(){ int time = 20; signal(SIGINT, sig_handler); printf(\"enter to the sleep.\\n\"); //sleep(time); do{ time = sleep(time); }while(time > 0); printf(\"sleep is over, main over.\\n\"); exit(0); } enter to the sleep. ^C recvive the signal is 2 ^C recvive the signal is 2 ^C recvive the signal is 2 sleep is over, main over. 备注：sleep(time)返回值是睡眠剩下的时间； 备注：可以使用sleep来实现定时发送机制，例如server和client通信，定时发送数据或者定时接受数据（设置避免打扰时间内不接收数据），当然定时接受数据可能会造成数据丢失（超过缓存） LINUX信号机制 图为007载板 主要资源 1 个千兆以太网（10/100/1000 BASE-T） 1 个 HDMI 2.0 接口(最大 6Gbps，24bpp，4096x2160@60Hz) 2 个 USB3.0 端口（5Gbps，1A 最大供电电流） 1 个 USB2.0（w/OTG） 1 个 SD 卡接口 4 路 3.3V 位可编程 GPIO 2 个 3.3V UART 2 路 I2C 接口 2 个 CAN 1 个风扇控制接口 电源要求：+7V~+19V 工作温度： -40~+85℃ 板卡尺寸：87mm×50mm 重量：50g 外设接口 注： UART0 = /dev/ttyS0 within Linux for Tegra(调试口) UART0 经过载板电平转换电路转换为 3.3V 逻辑电平 UART1 = /dev/ttyTHS2 within Linux for Tegra UART1 经过载板电平转换电路转换为 3.3V 逻辑电平 GPIO8 = sysfs GPIO # 187（TX2==#388） GPIO9 = sysfs GPIO # 186（TX2==#298） GPIO_EXP0_INT = sysfs GPIO # 89(TX2==#480) GPIO_EXP1_INT = sysfs GPIO # 202(TX2==#486) I2C 总线对应于 Linux 内的 Tegra 总线 1 按钮 007 提供 4 个按钮分别为： 1) S1----（POWER）电源开关; 2) S2----（RESET）复位开关; 3) S3---- (RECOVERY)程序下载 4) S4----(VOL-)系统音量减 S1 电源按钮，当载板处于 ATX 模式时，按下按钮系统启动，当系统启动后，按下按钮，系统进入待机模式， 当系统启动后，按下按钮，保持 5s，系统硬关机；S2 重启按钮，按下按钮系统重启；S3 Recovery 按钮按下按 钮进入 recovery 模式通过 USB OTG 端口烧写系统镜像到 TX1/TX2 模块 RealSense 相机 RealSense D435 参数 Features Use Environment: Indoor/OutdoorImage Sensor Technology: Global Shutter, 3μm x 3μm pixel size Maximum Range: Approx. 10 meters. Accuracy varies depending on calibration, scene, and lighting condition. Depth Depth Technology: Active IR Stereo Depth Field of View (FOV): 87°±3° x 58°±1° x 95°±3° Minimum Depth Distance (Min-Z): 0.105 m Depth Output Resolution & Frame Rate: Up to 1280 x 720 active stereo depth resolution. Up to 90 fps. RGB RGB Sensor Resolution & Frame Rate: 1920 x 1080 RGB Frame Rate: 30 fps RGB Sensor FOV (H x V x D): 69.4° x 42.5° x 77° (+/- 3°) Major Components Camera Module: Intel RealSense Module D430 + RGB Camera Vision Processor Board: Intel RealSense Vision Processor D4 Physical Form Factor: Camera PeripheralLength x Depth x Height: 99 mm x 25 mm x 25 mm Connectors: USB‑C 3.1 Gen 1 Mounting Mechanism: One 1/4‑20 UNC thread mounting point. Two M3 thread mounting points. RealSense SDK 安装 官方NVIDIA Jetson TX2 installation Check out www.jetsonhacks.com for more great content regarding RealSense on the Jetson To install librealsense on the Jetson TX2 Developer Kit, follow the regular instructions for Ubuntu 16.04. A couple of things to note: Make sure you are running the latest L4T release as published by NVIDIA. The ./scripts/patch-realsense-ubuntu-xenial.sh script will NOT work as is. The following are the minimal changes necessary to make the script run: Change line #26 to kernel_name=\"kernel-4.4\" Replace line #29 with: [ ! -d ${kernel_name} ] && git clone https://github.com/jetsonhacks/buildJetsonTX2Kernel.git && cd buildJetsonTX2Kernel && ./getKernelSources.sh && ./scripts/fixMakeFiles.sh && cd .. && cp /usr/src/kernel/${kernel_name} ./${kernel_name} Comment out lines #33-53. This is necessary because the original script grabs the kernel sources from a git repository, which NVIDIA does not provide for L4T, and this segment was written with that assumption in mind. QtCreator won't work out of the box on the Jetson. JetsonHacks has posted a helpful tutorial explaining how to properly configure it. Ubuntu apt安装 安装依赖 sudo apt-get update && sudo apt-get upgrade && sudo apt-get dist-upgrade sudo apt-get install git libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-dev sudo apt-get install libglfw3-dev Register the server's public key: sudo apt-key adv --keyserver keys.gnupg.net --recv-key C8B3A55A6F3EFCDE || sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C8B3A55A6F3EFCDE In case the public key still cannot be retrieved, check and specify proxy settings: export http_proxy=\"http://:\" , and rerun the command. See additional methods in the following link. Add the server to the list of repositories: Ubuntu 16 LTS:(deepin不报错) sudo add-apt-repository \"deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main\" -u Ubuntu 18 LTS:(deepin报错) sudo add-apt-repository \"deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo bionic main\" -u Install the libraries (see section below if upgrading packages): sudo apt-get install librealsense2-dkms sudo apt-get install librealsense2-utils The above two lines will deploy librealsense2 udev rules, build and activate kernel modules, runtime library and executable demos and tools. Optionally install the developer and debug packages: sudo apt-get install librealsense2-dev sudo apt-get install librealsense2-dbg With dev package installed, you can compile an application with librealsense using g++ -std=c++11 filename.cpp -lrealsense2 or an IDE of your choice. Reconnect the Intel RealSense depth camera and run: realsense-viewer to verify the installation. Verify that the kernel is updated : modinfo uvcvideo | grep \"version:\" should include realsense string Ubuntu 源码安装 断开相机连接 安装依赖 sudo apt-get update && sudo apt-get upgrade && sudo apt-get dist-upgrade sudo apt-get install git libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-dev Distribution-specific packages: Ubuntu 16: sudo apt-get install libglfw3-dev Ubuntu 18: sudo apt-get install libglfw3-dev libgl1-mesa-dev libglu1-mesa-dev 下载源码 Download and unzip the latest stable version from master branch: Run Intel Realsense permissions script located from librealsense root directory: cd librealsense-master ./scripts/setup_udev_rules.sh Build and apply patched kernel modules for: Ubuntu 14/16/18 with LTS kernel script will download, patch and build realsense-affected kernel modules (drivers). Then it will attempt to insert the patched module instead of the active one. If failed the original uvc modules will be restored. ./scripts/patch-realsense-ubuntu-lts.sh Building librealsense2 SDK mkdir build && cd build cmake ../ -DBUILD_EXAMPLES=true # Builds librealsense 同时编译 demos and tutorials Recompile and install librealsense binaries: sudo make uninstall && make clean && make && sudo make install TIPS：The shared object will be installed in /usr/local/lib, header files in /usr/local/include. The binary demos, tutorials and test files will be copied into /usr/local/bin Tip: Use make -jX for parallel compilation, where X stands for the number of CPU cores available: sudo make uninstall && make clean && make **-j8** && sudo make install This enhancement may significantly improve the build time. The side-effect, however, is that it may cause a low-end platform to hang randomly. Note: Linux build configuration is presently configured to use the V4L2 backend by default. Note: If you encounter the following error during compilation gcc: internal compiler error it might indicate that you do not have enough memory or swap space on your machine. Try closing memory consuming applications, and if you are running inside a VM increase available RAM to at least 2 GB. Note: You can find more information about the available configuration options on this wiki page. 运行例程检验 插入相机 lsusb # 查看usb设备 # Bus 002 Device 014: ID 8086:0b07 Intel Corp. cd librealsense/build/examples rs-capture 看到彩图和深度图即安装成功。 启动SDK realsense-viewer 仍然回传不了图像？firmware版本的问题 更新固件 realsense升级固件Firmware Add Intel server to list of repositories: echo 'deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main' | sudo tee /etc/apt/sources.list.d/realsense-public.list Register the servers public key: sudo apt-key adv --keyserverkeys.gnupg.net --recv-key 6F3EFCDE Install the intel-realsense-dfupackage sudo apt-get update sudo apt-get install intel-realsense-dfu* Download latest D400 series firmware .bin file (Signed Binary)仅需二进制文件 下载最新固件firmware下载地址 Plug in D400 Series camera to host USB3.1 port. Check serial # and bus# lsusb # 查看usb设备 lsusb | grep 8086 # 使用8086端口 # Bus 002 Device 014: ID 8086:0b07 Intel Corp. Notice “Intel Corp.” bus and device numbers; DFU tool uses these values to identify Intel® RealSense™ D400 series camera. 此处Bus 002 ，Device 014 Upgrade D400 Series Camera Firmware with Linux DFU Tool intel-realsense-dfu -b 002 -d 014 -f -i /home/chao/Downloads/v5_10_13/Signed_Image_UVC_5_11_6_250.bin -b -d后接的分别是上面查询对应的Bus和Device号，注意修改对应的-b 和 -d 后面的数字，以及bin的版本号 Tool will begin upgrade process, and notify whenupgrade is complete. Firmware Check intel-realsense-dfu -p Intel Realsense D435/D415 基于 Ubuntu 16.04 安装教程 Ubuntu 16.04 安装RealSense D435教程 ZED 相机 "},"opencv/":{"url":"opencv/","title":"OpenCV","keywords":"","body":"OpenCVOpenCV OpenCV的全称是Open Source Computer Vision Library，是一个开源的跨平台的计算机视觉库，它提供了很多函数，这些函数非常高效地实现了计算机视觉算法（最基本的滤波到高级的物体检测皆有涵盖）。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，可以在商业和研究领域中免费使用。 OpenCV 使用 C/C++ 开发，同时也提供了 Python、Java、MATLAB 等其他语言的接口。 OpenCV 是跨平台的，可以在 Windows、Linux、Mac OS、Android、iOS 等操作系统上运行。 OpenCV 的应用领域非常广泛，包括图像拼接、图像降噪、产品质检、人机交互、人脸识别、动作识别、动作跟踪、无人驾驶等。 OpenCV 还提供了机器学习模块，你可以使用正态贝叶斯、K最近邻、支持向量机、决策树、随机森林、人工神经网络等机器学习算法。 "},"opencv/opencv.html":{"url":"opencv/opencv.html","title":"OpenCV笔记","keywords":"","body":"OpenCV教程OpenCV教程 CLion+OpenCV 开发环境搭建 参考链接 参考 OpenCV安装好后只需CLion里编写CMakeList.txt文件指定opencv路径即可,不需要特殊设置 CMakeList.txt #设置最低版本的cmake要求 cmake_minimum_required(VERSION 3.14) #设置项目信息 project(cvtest00) #set(PROJECT_NAME cvtest00) #project(${PROJECT_NAME}) #设置编译器版本 set(CMAKE_CXX_STANDARD 14) #设置源文件（主文件名） #set(SOURCE_FILES main.cpp) #设置要生成可执行程序的文件名 #add_executable(cvtest00 ${SOURCE_FILES}) #主函数生成可执行文件 add_executable(cvtest00 main.cpp) #寻找opencv库 find_package(OpenCV REQUIRED) #添加头文件 include_directories(${OpenCV_INCLUDE_DIRS}) #打印调试信息 MESSAGE(STATUS \"Project:cvtest00\") MESSAGE(STATUS \"Project Dirrectory: ${PROJECT_SOURCE_DIR}\") #设置调试模式，debug会输出调试信息 SET(CMAKE_BUILD_TYPE DEBUG) #添加自己写的其他函数文件，注意这个名字不能和工程名冲突 #ADD_LIBRARY( STATIC imgfeatures.cpp imgfeatures.h kdtree.h kdtree.cpp minpq.h minpq.cpp sift.h sift.cpp utils.cpp utils.h xform.h xform.cpp) #设置链接库 target_link_libraries(cvtest00 ${OpenCV_LIBS}) main.cpp测试代码 #include #include #include using namespace cv; using namespace std; int main(int argc,char **argv) { Mat img = imread(\"/home/chao/Desktop/test.jpg\"); // 绝对路径 Mat img = imread(\"../test.jpg\"); // 按照编译后可执行程序路径开始算??? cout 报错: Gtk-WARNING **: 22:16:16.681: Unable to locate theme engine in module_path: 原因是缺少gnome组件 sudo apt install gnome-themes-standard 报错: terminate called after throwing an instance of 'cv::Exception' what(): OpenCV(3.4.5) /home/chao/opencv/opencv-3.4.5/modules/highgui/src/window_gtk.cpp:1257: error: (-215:Assertion failed) found && \"Can't destroy non-registered window\" in function 'cvDestroyWindow' 原因是图片没有正确读取,请先测试图片是否正确加载,(文件相对路径似乎是按照编译后的可执行文件的相对路径算??) 报错: CMake throws Error: could not load cache 原因是 CLion自动创建的CMake的 cmake-build-debug 编译文件受损不完整,直接 File---\"Reload CMake Project\" Mat类分为了两个部分:矩阵头和指向矩阵数据部分的指针，data就是指向矩阵数据的指针 depth数值 具体类型 取值范围 CV_8U 8 位无符号整数 （0……255） CV_8S 8 位符号整数 （-128……127） CV_16U 16 位无符号整数 （0……65535） CV_16S 16 位符号整数 （-32768……32767） CV_32S 32 位符号整数 （-2147483648……2147483647） CV_32F 32 位浮点数 （-FLT_MAX ………FLT_MAX，INF，NAN) CV_64F 64 位浮点数 （-DBL_MAX ……….DBL_MAX，INF，NAN) type类型 CV_8UC1 CV_8UC2 CV_8UC3 CV_8UC4 CV_8SC1 CV_8SC2 CV_8SC3 CV_8SC4 CV_16UC1 CV_16UC2 CV_16UC3 CV_16UC4 CV_16SC1 CV_16SC2 CV_16SC3 CV_16SC4 CV_32SC1 CV_32SC2 CV_32SC3 CV_32SC4 CV_32FC1 CV_32FC2 CV_32FC3 CV_32FC4 CV_64FC1 CV_64FC2 CV_64FC3 CV_64FC4 Mat类 Mat类用于表示一个多维的单通道或者多通道的稠密数组。能够用来保存实数或复数的向量、矩阵，灰度或彩色图像，立体元素，点云，张量以及直方图（高维的直方图使用SparseMat保存比较好）。简而言之，Mat就是用来保存多维的矩阵的。Mat对象OpenCV2.0之后引进的图像数据结构、自动分配内存、不存在内存泄漏的问题，是面向对象的数据结构。 Mat类可以分为两个部分：矩阵头和指向像素数据的矩阵指针 矩阵头: 包括数字图像的矩阵尺寸、存储方法、存储地址和引用次数等，矩阵头固定格式，不会随着图像的大小而改变 数据指针: 指向像素数据的矩阵指针 OpenCV行图像复制和传递时，不再复制整个Mat数据，而只是复制矩阵头和指向像素矩阵的指针 构造函数 cv::Mat::Mat(int rows, int cols, int type) # 矩阵的rows行数,cols 列数,存储类型type cv::Mat::Mat(int rows, int cols,i nt type, const Scalar &s) # 矩阵的rows行数,cols 列数,存储类型type,Scalar &s 通过Scalar数据类来初始化每个通道元素值,向量长度对应通道数目一致 ​ Mat M(2,2,CV_8UC3) # 表示M是一个3,4的矩阵，每个通道是8位Unsigned Char类型,3通道, [ 0, 0, 0, 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0, 0, 0, 0] ​ Mat M(2,2,CV_8UC3, Scalar(0,0,255)) [ 0, 100, 255, 0, 100, 255, 0, 100, 255; 0, 100, 255, 0, 100, 255, 0, 100, 255] cv::Mat::Mat(Size size, int type) # 矩阵的大小(Size),以及存储类型(type) cv::Mat::Mat(Size size, int type, const Scalar &s) # 矩阵的大小(Size),存储类型(type) ,Scalar &s Mat src2(Size(30, 40), CV_32FC3) # 表示src是一个Size(30,40)的矩阵，且矩阵元素以32位float型存储 cv::Mat::Mat(int ndims, const int * sizes, int type) # 矩阵的维数(ndims),指定维数组形状的整数数组(sizes)??,数组的类型(type) cv::Mat::Mat(int ndims, const int * sizes,int type, const Scalar& s) # Mat src1(300, 400, CV_8UC3,Scalar(255,255,255)) # Scalar(255,255,255)以8位无符号数存储，对应RGB通道值。 cv::Mat::create 创建Mat对象 矩阵 Mat M; M.create(4, 3, CV_8UC3); M = Scalar(1,125,255); cout firstRow = M.ptr(0); printf(\"%d\", firstRow); cv::Mat::Mat(const Mat & m) # 引用m矩阵 定义小数组 // Mat(,) (3, 3) int sz[3] = {2,2,2};?? Mat L(3,sz, CV_8UC1, Scalar::all(0)); ?? cout Mat属性 rows 矩阵的行数 cols 矩阵的列数 size 矩阵的大小 size(cols,rows),如果矩阵的维数大于2，则是size(-1,-1) dims 矩阵的维度 例如5*6矩阵是二维矩阵，则dims=2，三维矩阵dims=3 channels 通道数 矩阵元素拥有的通道数，例如常见的彩色图像，每一个像素由RGB三部分组成，则channels = 3 data 数据指针 uchar型的指针，指向矩阵数据的指针 type 图像类型 表示矩阵中元素的数据类型以及矩阵的通道数，如CV8UC3，它是一系列的预定义的常量，其命名规则为CV(位数）+（数据类型）+（通道数） CV_8UC1 CV_8UC2 CV_8UC3 CV_8UC4 CV_8SC1 CV_8SC2 CV_8SC3 CV_8SC4 CV_16UC1 CV_16UC2 CV_16UC3 CV_16UC4 CV_16SC1 CV_16SC2 CV_16SC3 CV_16SC4 CV_32SC1 CV_32SC2 CV_32SC3 CV_32SC4 CV_32FC1 CV_32FC2 CV_32FC3 CV_32FC4 CV_64FC1 CV_64FC2 CV_64FC3 CV_64FC4 U（unsigned integer）无符号整数，S（signed integer）有符号整数，F（float）浮点数，C（channels）通道数 depth 图像深度(精度) 矩阵中元素的一个通道的数据类型，用来度量每一个像素中每一个通道的精度，如CV_8U、CV_8S、CV_16U、CV_16S、CV_32S、CV_32F、CV_64F depth和type是相关的,将type的预定义值去掉通道信息就是depth值,例如 type为 CV_16SC2，一个2通道的16位的有符号整数,那么depth则是CV_16S elemSize 矩阵一个元素占用的字节数，例如：type是CV_16SC3，那么elemSize = 3 * 16 / 8 = 6 bytes elemSize1 矩阵元素一个通道占用的字节数，例如：type是CV_16CS3，那么elemSize1 = 16 / 8 = 2 bytes = elemSize / channe step step1 规整化的step，值为step / elemSize1 Mat 方法 create 创建Mat对象 (创建矩阵) Mat M; M.create(4, 3, CV_8UC3); M = Scalar(1,125,255); total 返回矩阵的元素总个数 cvtColor 颜色空间转换 convertTo 矩阵存储类型转换 Mat src = imread(\"test.png\",IMREAD_COLOR); src.convertTo(dst, CV_32FC3); # src转换为32位浮点型,存到dst at(i,j) 访问矩阵元素 读写单通道灰度GRAY像素点的像素值 Mat src = imread(\"test.jpg\"); // （CV_8UC1） int pixel = src.at(y, x); # 访问test.jpg图像的(y, x)元素 读写三通道彩色BGR像素点的像素值 Mat img = imread(\"test.jpg\"); Vec3f pixel = img.at(y, x); // 三个通道像素值存到pixel数组 float blue = pixel.val[0]; // pixel.val[0/1/2] 对应bgr像素值 float green = pixel.val[1]; float red = pixel.val[2]; img.at(y,x)[index]=value 给每个像素点每个通道赋值 at 各种类型的图像对应表?? ---------CV_8U -----------CV_8S ---------CV_16S --------CV_16U -----------CV_32S ----------CV_32F --------CV_64F --------CV_8UC3 --------CV_32FC3 ptr ?? empty() ?? clone 矩阵完全复制 “深拷贝”，把Mat对象的头部和数据部分一起复制 Mat image1 = imread(\"test.png\",IMREAD_COLOR); Mat image2 = image1.clone(); “”浅拷贝“”赋值，只会复制Mat对象的头和指针部分，不会复制数据部分,即image2实际上指向的是image1的内存单元。当image1提前被释放掉，image2访问无效。 Mat image1 = imread(\"test.png\",IMREAD_COLOR); Mat image2 = image1; copyTo 矩阵完全复制 与clone作用类似，使用形式不用 Mat image3; image1.copyTo(image3); mul 矩阵的乘法 inv 矩阵求逆 t 矩阵转置 zeros() 零矩阵 Mat image = Mat::zeros( image.size(), image.type() ); 创建一张跟原图像大小和类型一致的空白图像 ones 全一阵 eye 对角阵 imread() 读取图像 Mat img = imread(\"../test.jpg\"); // 按照编译后可执行程序路径开始算??? Mat img1 = imread(\"../test.jpg\", IMREAD_UNCHANGED); // 加载原图不做任何改变 Mat img2 = imread(\"../test.jpg\", IMREAD_GRAYSCALE); // 把原图作为灰度图像加载进来 Mat img3 = imread(\"../test.jpg\", IMREAD_COLOR); // 把原图作为RGB图像加载进来 namedWindos() 创建窗口 namedWindow(\"Window WINDOW_AUTOSIZE\", WINDOW_AUTOSIZE); // 不可改变大小 namedWindow(\"Window WINDOW_NORMAL\", WINDOW_NORMAL); // 可拖动改变大小 destroyWindow() 销毁窗口 destroyWindow(\"My Test\"); imshow() 输出图像 imshow(\"image01\", img); imshow(image01, img); imwrite() 保存图像 imwrite(\"../newimage.png\",img); // 路径按照可执行文件的路径算 waitKey() 等待键盘触发 waitKey(); // 等待键盘触发ms,默认0,一直等待 waitKey(3000); // 等待3000ms getTickCount() 获取时间 CV_Assert() 断言 若括号中的表达式值为false，则返回一个错误信息。 CV_Assert(testImage.depth() == CV_8U); // 若括号中的表达式值为false，则返回一个错误信息。 filter2D() 二维滤波 saturate_cast 截断,防止溢出(0~255) bitwise_not 像素按位取反 addWeighted 图像混合 两张图像的Size大小和type类型必须一致才可以混合 RNG 随机数生成器类 RNG 可以产生3种随机数, RNG(int seed) 使用种子seed产生一个64位int随机整数，默认种子-1 RNG::uniform 产生一个指定范围的均匀分布随机数, RNG::gaussian 产生一个高斯随分布机数, RNG::uniform(a, b ) 返回一个[a,b)范围的均匀分布的随机数，a,b的数据类型要一致，而且必须是int、float、double中的一种，默认是int。 RNG::gaussian( σ) 返回一个均值为0，标准差为σ的随机数。 //创建RNG对象，使用默认种子“-1”RNG rng; // rng既是一个RNG对象，也是一个随机整数 //产生64位整数int N1 = rng; //注意: 总是得到double类型数据0.00，因为会调用uniform(int,int),只会取整数，所以只产生0double N1a = rng.uniform(0,1); // 输入为int型参数,会调用uniform（int，int），只能产生0 //产生[0,1)范围内均匀分布的double类型数据double N1b = rng.uniform((double)0,(double)1); //产生[0,1)范围内均匀分布的double类型数据。double N1d = rng.uniform(0.,1.); //产生符合均值为0，标准差为2的高斯分布的随机数double N1g = rng.gaussian(2); RNG::next 取出下一个64位随机整数, RNG rng;int N2 = rng.next(); //返回下一个随机整数，即N1.next(); RNG:: operator 返回下一个指定类型的随机数 int N2a = rng.operator uchar(); //返回下一个无符号字符数int N2g = rng.operator float(); //返回下一个浮点数int N2h = rng.operator double(); /返回下一个double型数int N2i = rng.operator ()(); /和rng.next( )等价int N2j = rng.operator ()(100); //返回[0,100)范围内的随机数 RNG::fill 用随机数填充矩 //产生[1,1000)均匀分布的int随机数填充 ff 矩阵 Mat ff(3,3);rng.fill(ff,RNG::UNIFORM,1,1000);cout Size 图像大小类 Size类成员为width 和 height，分別表示寬和長 Size类操作 默认构造 Size sz;Size2i sz; Size2f p2; 拷贝构造 Size sz2(sz1); 数值初始化 Size sz(w,h); 成员访问 sz.width; sz.height; 计算区域面积 sz.area(); Size size1 = Size(200,100); //Size size1(200, 100); // 或者 Size size2; size2.width = 150; size2.height = 50; int myArea = size2.area(); cout // 输出Size结果数据格式 Size size1 = [200 x 100] Scalar 标量??长度为4的向量 用来存放4个double型的数组,一般像素各个通道的颜色值，最多可以存放4个通道，默认是0 // OpenCV中 Scalar 的定义 typedef struct Scalar { double val[4]; }Scalar; Scalar类的操作: 1 默认构造 Scalar s; 2 拷贝构造 Scalar s2(s1); 3 数值初始化 Scalar s(x0); Scalar s(x0,x1,x2,s3); 4 数组元素相乘 s1.mul(s2); 5 共轭 s1.conj(); Scalar color = Scalar(11, 22, 255); // 颜色 //Scalar color(11, 22, 255); // 或者cout // 输出Scalar结果数据格式 Scalar color = [11, 22, 255, 0] Point 点类 成員有x和y,位置坐标,要是輸入浮點數的話，則四捨五入取整數 Point类的操作： 默认构造 Point2i p1;Point3f p2; 拷贝构造 Point3f p2(p1); 数值初始化 Point2i p1(x0,x1);Point3f p2(x0,x1,x2); 转换到Vector类型 (Vec3f) p; 成员访问 p.x; p.y; 点积运算 float x = p1.dot(p2); 双精度点积 double x = p1.ddot(p2); 向量积(仅适用三维) p1.cross(p2); 查询是否在某区域(rectangle)内(仅适用二维) p.inside(r); Point(int x, int y) // 建構式 Point p1 = Point(20, 30); // 定义点 //Point p1(20, 30); // 或者 Point p2; // 定义点 p2.x = 200; p2.y = 300; Rect 矩形类 成員有x、y、width、height，分別表示左上角頂點的x座標，左上角頂點的y座標，矩形寬、矩形高，可用area()函式得到面積 Rect类操作 1 默认构造 Rect r; 2 拷贝构造 Rect r2(r1); 3 数值初始化 Rect r(x, y, w , h); 4 点坐标及大小初始化构造 Rect r(p,sz); 5 两点初始化构造 Rect r(p1, p2); 6 成员访问 r.x; r.y; r.width; r.height; 7 计算区域面积 r.area(); 8 提取左上角点 r.tl(); 9 提取右下角点 r.br(); 10 判断点是否在某区域内 r.contains(p); 11 12 重载操作符对象间的运算： 13 矩形1与矩形2的交集 Rect r3 = r1 & r2; 14 包含矩形1与矩形2的最小矩形 Rect r3 = r1 | r2; 15 平移左上角坐标矩形大小不变 Rect r2 = r1 + p; 16 放大或缩小矩形大小，左上角点不变 Rect r2 = r1 + sz; 17 判断两个矩形是否相等 bool eq = ( r1 == r2);bool ne = ( r1 != r2); Rect(int x, int y, int width, int height) //建構式 Rect rect1 = Rect(100, 40, 150, 300); // 定义矩形位置和长宽 Rect rect2; rect2.x = 20; rect2.y = 30; rect2.width = 250; rect2.height = 100; int myRectArea = rect2.area(); Scalar color = Scalar(255, 0, 0); // 颜色 rectangle(bgImage, rect1, color, 2, LINE_8); // 在bgImage上画矩形 RotatedRec 斜矩形类 成員有矩形的質心center(Point2f類別)，四周長size(Size2f類別)、旋轉角度angle(float類別)，可用points()函式得到四個頂點 RotatedRect类操作 1 默认构造 RotatedRect rr(); 2 拷贝构造 RotatedRect rr2(rr1); 3 数值初始化 RotatedRect rr(p,sz,theta); 4 两点初始化 RotatedRect rr(p1，p2); 5 成员访问 rr.center; rr.size; rr.angle; 6 返回4角点坐标 rr.points(pts[4]); RotatedRect(const Point2f &center, const Size2f &size, float angle) //建構式 RotatedRect rRect1(Point2f(150,150), Size2f(100,50), 30.0); RotatedRect rRect2; rRect2.center = Point2f(150,150); rRect2.size = Size2f(100,50); rRect2.angle = 30.0; Point2f vertices[4]; rRect2.points(vertices); line 画直线 line(bgImage, p1, p2, color, 1, LINE_AA); // 在bgImage上画直线 rectangle 画矩形 Rect rect1 = Rect(100, 40, 150, 300); // 定义矩形位置和长宽 Scalar color = Scalar(255, 0, 0); // 颜色 rectangle(bgImage, rect1, color, 2, LINE_8); // 在bgImage上画矩形 circle() 画圆 Scalar color = Scalar(0, 255, 255); // 颜色 Point center = Point(bgImage.cols / 2, bgImage.rows / 2); // 圆心 circle(bgImage, center, 150, color, 2, 8); // 在bgImage上画圆 ellipse() 画椭圆 Scalar color = Scalar(0, 255, 0); // 颜色 Point center = Point(bgImage.cols / 2, bgImage.rows / 2); // 椭圆中心 ellipse(bgImage, center, Size(200,100), 90, 0, 360,color, 2, LINE_8); polylines fillPoly 填充多边形?? Point pts[1][5]; pts[0][0] = Point(100, 100); pts[0][1] = Point(100, 200); pts[0][2] = Point(200, 200); pts[0][3] = Point(200, 100); pts[0][4] = Point(150, 150); const Point *ppts[] = {pts[0]}; int npt[] = {5}; Scalar color = Scalar(255, 12, 255); fillPoly(bgImage, ppts, npt, 1, color, 8); putText() 图片添加文字 putText(image, \"OpenCV Tutorial\", Point( 200, 100),CV_FONT_HERSHEY_PLAIN, 2.0, Scalar(0, 255, 0), 3, LINE_8); blur() 均值滤波模糊 blur(Mat src, Mat dst, Size(xradius, yradius), Point(-1,-1)); blur(src, dst, Size(11, 11), Point(-1, -1)); // 均值滤波模糊 GaussianBlur() 高斯模糊 GaussianBlur(Mat src, Mat dst, Size(11, 11), sigmax, sigmay); // 其中Size（x, y）, x, y 必须是正数而且是奇数 GaussianBlur(src, gblur, Size(11, 11), 11, 11); // 高斯模糊 medianBlur() 中值模糊 medianBlur（Mat src, Mat dest, ksize） bilateralFilter() 双边模糊 bilateralFilter(src, dest, d=15, 150, 3); getStructuringElement() 获取结构化元素 getStructuringElement(int shape, Size ksize, Point anchor) 形状 (MORPH_RECT 矩形 / MORPH_CROSS 交叉形 / MORPH_ELLIPSE 椭圆形) 大小 锚点 默认是Point(-1, -1)意思就是中心像素 Mat structureElement = getStructuringElement(MORPH_RECT, Size(s, s), Point(-1, -1)); dilate() 膨胀 dilate(src, dst, structureElement, Point(-1, -1), 1); erode() 腐蚀 erode(src, dst, structureElement); createTrackbar() 创建滑动条 createTrackbar(const String & trackbarname, const String winName, int value, int count, Trackbarcallback func, void userdata=0) namedWindow(\"窗体名\", CV_WINDOW_AUTOSIZE); // 创建窗体 createTrackbar(\"标签:\", \"窗体名\", &滑动后的值, 滑动条的最大值, 回调函数 ); // 在创建的窗体中创建一个滑动条控件,每当滑动条的值改变, 就会调用回调函数 morphologyEx morphologyEx( InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor = Point(-1,-1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar& borderValue = morphologyDefaultBorderValue() ); src – 输入图像 dest – 输出结果 op – 形态学操作类型 kernel – 结构元素 anchor 锚的位置，默认值（-1，-1），锚位于中心 iteration 迭代次数，默认是1 borderType 用于推断图像外部像素的某种边界模式。有默认值BORDER_CONSTANT borderValue 当边界为常数时的边界值，有默认值morphologyDefaultBorderValue() MORPH_DILATE 膨胀 亮色部分被腐蚀,分割独立的图像元素 MORPH_ERODE 腐蚀 亮色部分膨胀,连接相邻的元素 MORPH_OPEN 开运算 先腐蚀后膨胀,可以去掉小的亮对象 MORPH_CLOSE 闭运算 先膨胀后腐蚀,可以去掉小的黑点 MORPH_GRADIENT 形态学梯度 形态学梯度=膨胀图-腐蚀图,保留图像边缘 MORPH_TOPHAT 顶帽 顶帽=原图-开运算,分离邻近点亮一些的斑块，进行背景提取 MORPH_BLACKHAT 黑帽 黑帽=闭运算-原图,分离比邻近点暗一些的斑块 adaptiveThreshold 转换为二值图像 提取直线: 开运算(用直线结构元素) 去除背景直线: 开运算(用矩形结构元素) pyrUp 上采样 pyrUp(Mat src, Mat dst, Size(src.cols2, src.rows2)) // 生成的图像是原图在宽与高各放大两倍 降采样pyrDown pyrDown(Mat src, Mat dst, Size(src.cols/2, src.rows/2)) // 生成的图像是原图在宽与高各缩小1/2 高斯不同(Difference of Gaussian-DOG) 把同一张图像在不同的参数下做高斯模糊之后的结果相减，得到的输出图像。 "},"shu-ju-ku/":{"url":"shu-ju-ku/","title":"数据库","keywords":"","body":"数据库数据库 MySQL简介 mysql的基本操作 登录Mysql 数据库CURD 表的CURD 表数据的CURD mysql内置函数 数据类型 日期时间函数 字符串相关函数 数学相关函数 多表查询 交叉连接 满外联接 内连接 左外连接 右外连接 自连接 表的约束 MongoDB简介 数据库 use创建/切换数据库 show显示所有数据库名 db查看当前数据库的名称 dropDatabase删除当前的数据库 集合 show查看所有的collection 文档 insert插入文档 find查询文档 remove删除文档 update修改文档 索引 聚合 副本集 MongoDB关于C++的API简介 "},"shu-ju-ku/mysql.html":{"url":"shu-ju-ku/mysql.html","title":"MySQL","keywords":"","body":"数据库简介数据库SQLMySQL简介mysql数据类型mysql表的约束mysql安装配置mysql安装mysql配置登录Mysqlmysql的基本操作数据库CURD表的CURD表数据的CURD备份与恢复综合案例mysql查询基本表数据查询where条件查询order-by排序统计聚合函数group by分组limit分页子查询多表查询交叉连接满外联接连接查询自连接mysql进阶mysql内置函数视图事务索引账户管理MySQL主从同步python操作MySQL数据库引入模块Connection对象Cursor对象数据库设计常见问题解决sudo登陆问题mysql中文乱码问题MySQL 数据库简介 数据库 SQL MySQL简介 mysql数据类型 mysql表的约束 mysql安装配置 mysql安装 mysql配置 登录Mysql mysql的基本操作 数据库CURD 表的CURD 表数据的CURD 备份与恢复 综合案例 mysql查询 基本表数据查询 where条件查询 order-by排序 统计聚合函数 group by分组 limit分页 子查询 多表查询 交叉连接 满外联接 连接查询 自连接 mysql进阶 mysql内置函数 视图 事务 索引 账户管理 MySQL主从同步 python操作MySQL数据库 引入模块 Connection对象 Cursor对象 数据库设计 常见问题 解决sudo登陆问题 mysql中文乱码问题 [TOC] 数据库简介 数据库 数据库的类型：关系型数据库、非关系型数据库 所谓的关系型数据库RDBMS（Relational Database Management System），是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据 SQL SQL（Structured Query Language）是结构化查询语言，是一门特殊的语言,专门用来操作关系数据库，不区分大小写。也就是说可以通过 SQL 操作 oracle,sql server,mysql,sqlite 等等所有的关系型的数据库。 SQL语句主要分为： DQL：数据查询语言，用于对数据进行查询，如select DML：数据操作语言，对数据进行增加、修改、删除，如insert、udpate、delete DDL：数据定义语言，进行数据库、表的管理等，如create、drop DCL：数据控制语言，进行授权与权限回收，如grant、revoke TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback CCL：指针控制语言，通过控制指针完成表的操作，如declare cursor MySQL简介 瑞典MySQL AB公司开发，后来被Sun公司收购，Sun公司后来又被Oracle公司收购，目前属于Oracle旗下产品。 mysql是一种关联数据库管理系统 由于其体积小、速度快、总体拥有成本低。 mysql数据库版本有：Community社区版、Enterprise企业版。 mysql特点 使用C和C++编写，并使用了多种编译器进行测试，保证源代码的可移植性 支持多种操作系统，如Linux、Windows、FreeBSD、MacOS等 为多种编程语言提供了API，如C、C++、Python、Java、Perl、PHP、Eiffel、Ruby等 支持多线程，充分利用CPU资源 优化的SQL查询算法，有效地提高查询速度 提供多语言支持，常见的编码如GB2312、BIG5、UTF8 提供TCP/IP、ODBC和JDBC等多种数据库连接途径 提供用于管理、检查、优化数据库操作的管理工具 可以处理拥有上千万条记录的大型数据库 支持多种存储引擎 mysql使用标准的SQL数据语言形式 Mysql是开源的，采用了GPL协议 在线DDL更改功能 复制全局事务标识 复制无崩溃从机 复制多线程从机 mysql数据类型 MYSQL中数据类型介绍 使用数据类型的原则是：够用就行，尽量使用取值范围小的，节省存储空间 mysql数据类型： 数值类型（int，bit，float，decimal） 字符串类型（varchar，char） 时间日期类型 （date，time，datetime） 枚举类型(enum) 数值类型 数值类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 整型 整型类型 字节大小 含义（有符号） tinyint 1个字节 范围(-128~127) smallint 2个字节 范围(-32768~32767) mediumint 3个字节 范围(-8388608~8388607) int 4个字节 范围(-2147483648~2147483647) bigint 8个字节 范围(+-9.22*10的18次方) 浮点型 浮点型类型 大小byte 含义 float(m,d) 8位精度(4字节) 单精度浮点型 m总个数，d小数位 double(m,d) 16位精度(8字节) 双精度浮点型 m总个数，d小数位 设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200. 定点数 浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 整型类型 大小byte 含义（有符号） decimal(m,d) M+1或M+2 小数值 decimal(m,d) 参数m bit 1位　 可以指定位数，如：bit(3) int 2字节 可以指定最大位数，如：int　最大为4位的整数 float 2个字节　可以指定最大的位数和最大的小数位数，如：float 最大为一个5位的数，小数位最多2位 double　4个字节　可以指定最大的位数和最大的小数位数，如：float 最大为一个6位的数，小数位最多4位 decimal(5,2) 表示共存5位数，小数占2位 字符串类型 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 类型 大小 用途 char 0-255 bytes 定长字符串 varchar 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 char(n) 和 varchar(n) 中括号中 n 代表字符的个数，比如 CHAR(30) 就可以存储 30 个字符。 char 必须指定字符数，如char(3) 为不可变字符，即使存储的内容为'ab',也是用3个字符的空间存储这个数据'ab '， char(3) 输入 'ab', 实际存储为'ab ', 输入'abcd' 实际存储为 'abc' varchar 必须指定字符数，如varchar(5) 为可变字符，如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间 varchar(3) 输 'ab',实际存储为'ab', 输入'abcd',实际存储为'abc' text: 大文本(大字符串) blob：二进制大数据　如图片，音频文件，视频文件 时间日期类型 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 类型 大小 ( bytes) 范围 格式 用途 date 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 time 3 '-838:59:59' 至 '838:59:59' HH:MM:SS 时间值或持续时间 year 1 1901 至 2155 YYYY 年份值 datetime 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 timestamp 4 '1970-01-01 00:00:01' UTC 至 '2038-01-01 00:00:01' UTC YYYYMMDD HHMMSS 混合日期和时间值，时间戳 date: 日期　如：'1921-01-02' datetime: 日期+时间　如：'1921-01-02 12:23:43' timeStamp: 时间戳，自动赋值为当前日期时间 数据类型的长度和范围 各数据类型及字节长度一览表： 数据类型 字节长度 范围或用法 Bit 1 无符号[0,255]，有符号[-128,127]，天缘博客备注：BIT和BOOL布尔型都占用1字节 TinyInt 1 整数[0,255] SmallInt 2 无符号[0,65535]，有符号[-32768,32767] MediumInt 3 无符号[0,2^24-1]，有符号[-2^23,2^23-1]] Int 4 无符号[0,2^32-1]，有符号[-2^31,2^31-1] BigInt 8 无符号[0,2^64-1]，有符号[-2^63 ,2^63 -1] Float(M,D) 4 单精度浮点数。天缘博客提醒这里的D是精度，如果D24则会自动被转换为DOUBLE型。 Double(M,D) 8 双精度浮点。 Decimal(M,D) M+1或M+2 未打包的浮点数，用法类似于FLOAT和DOUBLE，天缘博客提醒您如果在ASP中使用到Decimal数据类型，直接从数据库读出来的Decimal可能需要先转换成Float或Double类型后再进行运算。 Date 3 以YYYY-MM-DD的格式显示，比如：2009-07-19 Date Time 8 以YYYY-MM-DD HH:MM:SS的格式显示，比如：2009-07-19 11：22：30 TimeStamp 4 以YYYY-MM-DD的格式显示，比如：2009-07-19 Time 3 以HH:MM:SS的格式显示。比如：11：22：30 Year 1 以YYYY的格式显示。比如：2009 Char(M) M 定长字符串。 VarChar(M) M 变长字符串，要求M Binary(M) M 类似Char的二进制存储，特点是插入定长不足补0 VarBinary(M) M 类似VarChar的变长二进制存储，特点是定长不补0 Tiny Text Max:255 大小写不敏感 Text Max:64K 大小写不敏感 Medium Text Max:16M 大小写不敏感 Long Text Max:4G 大小写不敏感 TinyBlob Max:255 大小写敏感 Blob Max:64K 大小写敏感 MediumBlob Max:16M 大小写敏感 LongBlob Max:4G 大小写敏感 Enum 1或2 最大可达65535个不同的枚举值 Set 可达8 最大可达64个不同的值 Geometry Point LineString Polygon MultiPoint MultiLineString MultiPolygon GeometryCollection mysql表的约束 mysql关键字 含义 null 数据列可包含NULL值 not null 数据列不允许包含NULL值 unique 惟一，此字段的值不允许重复 default 默认值，当不填写此值时会使用默认值，如果填写时以填写为准 primary key 主键，(不允许为空，不允许重复) foreign key 外键，对关系字段进行约束，当为关系字段填写值时，会到关联的表中查询此值是否存在，如果存在则填写成功，如果不存在则填写失败并抛出异常 auto_increment 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 说明：虽然外键约束可以保证数据的有效性，但是在进行数据的crud（增加、修改、删除、查询）时，都会降低数据库的性能，所以不推荐使用，那么数据的有效性怎么保证呢？答：可以在逻辑层进行控制 mysql中约束举例： create table myclass ( id INT(11) primary key auto_increment, name varchar(20) unique ); -- create table student ( id INT(11) primary key auto_increment, name varchar(20) unique, passwd varchar(15) not null, classid INT(11), constraint stu_classid_FK foreign key(classid) references myclass(id) ); 定义外键约束： ... constraint stu_classid_FK foreign key(classid) references myclass(id) 删除主键： alter table 表名 drop primary key ; 查看所有数据库的表的约束 SELECT * FROM information_schema.`TABLE_CONSTRAINTS`; mysql安装配置 mysql安装 安装服务器端 sudo apt-get install mysql-server 安装客户端 sudo apt-get install mysql-client mariadb是mysql的一个分支，debian已经删掉mysql了，替换成了mariadb。 sudo apt-get install mariadb-server sudo apt-get install mariadb-client 服务启动和关闭 sudo service mysql start # 启动服务 sudo service mysql stop # 停止服务 sudo service mysql restart # 重启服务 查看进程中是否存在mysql服务 ps ajx|grep mysql 设为开机自启动 sudo systemctl enable mariadb #设为开机自启动 mariadb初始化 安装完成后需进行初始化设置： $ sudo mysql_secure_installation #直接执行初始化命令，会弹出交互配置信息 Enter current password for root (enter for none):#初次进入密码为空，直接回车 New password: #输入要为root用户设置的数据库密码。 Re-enter new password: #重复再输入一次密码。 Remove anonymous users? [Y/n] y #删除匿名帐号 Disallow root login remotely? [Y/n] n #是否禁止root用户从远程登录，安全起见应禁止，这里为做实验方便这里不禁止。 Remove test database and access to it? [Y/n] y #是否删除test数据库，想留着也随意 Reload privilege tables now? [Y/n] y #刷新授权表，让初始化后的设定立即生效 修改mysql默认密码? oracle收购Mysql后，新版的mysql刚安装完mysql后不能直接输入mysql登录数据库， 而是设置了默认free password密码，默认密码放在了/root/.mysql_secret文件中，登陆后需要修改密码。 查看文件寻找默认密码 cat /root/.mysql_secret 以root用户身份登陆mysql服务器： mysql -u root -p查询的登录密码 修改登录密码 mysql> set password=password('123456'); 将密码设置为：123456 密码修改成后，再次登录 mysql配置 配置文件目录为/etc/mysql/mysql.cnf 主要配置项 bind-address表示服务器绑定的ip，默认为127.0.0.1 port表示端口，默认为3306 datadir表示数据库目录，默认为/var/lib/mysql general_log_file表示普通日志，默认为/var/log/mysql/mysql.log log_error表示错误日志，默认为/var/log/mysql/error.log 登录Mysql 登录mysql sudo mysql -uroot -p123456 sudo mysql -uroot -p u: user ，p: password chao@deepin:~$ sudo mysql -uroot -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 36 Server version: 10.3.23-MariaDB-0+deb10u1 Debian 20 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. 退出登录 quit 或者 exit 或者 ctrl+d MariaDB [(none)]> quit mysql的基本操作 数据库CURD 对数据库进行增(create)、删(drop)、改(update)、查(Retrieve)操作。 create创建数据库 创建一个名称为mydb1的数据库，默认字符集 create database mydb1; MariaDB [(none)]> create database mydb1; Query OK, 1 row affected (0.000 sec) 创建一个使用utf-8字符集的mydb2数据库 create database 数据库名 charset=utf8; create database mydb2 charset=utf8; create database mydb3 character set utf8; MariaDB [(none)]> create database mydb2 charset=utf8; Query OK, 1 row affected (0.000 sec) 创建一个使用utf-8字符集，并带校对规则的mydb3数据库，会对存入的数据进行检查 create database mydb3 character=utf8 collate utf8_general_ci; show显示数据库信息 显示所有数据库 show databases; MariaDB [(none)]> show databases; +----------------------------+ | Database | +----------------------------+ | information_schema | | mydb1 | | mydb2 | | mysql | | performance_schema | +------------------------------+ 5 rows in set (0.000 sec) 查看创建数据库的方式 show create database mydb1; MariaDB [(none)]> show create database mydb1; +----------+-------------------------------------------------------------------+ | Database | Create Database | +----------+-------------------------------------------------------------------+ | mydb1 | CREATE DATABASE mydb1 /!40100 DEFAULT CHARACTER SET utf8mb4 / | +----------+-------------------------------------------------------------------+ 1 row in set (0.000 sec) 默认情况下，反引号“ ` ”括起来的字符串，区分大小写。 注意 ：mysql默认语言集是latin1，每次在创建数据库的时候应指定字符集。 select查看当前使用的数据库 查看当前使用的数据库 select database(); MariaDB [mydb1]> select database(); +------------+ | database() | +------------+ | mydb1 | +------------+ 1 row in set (0.000 sec) use使用数据库 use 数据库名; use mydb1; MariaDB [(none)]> use mydb1; Database changed MariaDB [mydb1]> alter修改数据库 修改mydb1的字符集为utf8(不能修改数据库名) alter database mydb1 character set utf8; MariaDB [mydb2]> alter database mydb1 character set utf8; Query OK, 1 row affected (0.000 sec) MariaDB [mydb2]> show create database mydb1; +----------+----------------------------------------------------------------+ | Database | Create Database | +----------+----------------------------------------------------------------+ | mydb1 | CREATE DATABASE mydb1 /!40100 DEFAULT CHARACTER SET utf8 / | +----------+----------------------------------------------------------------+ 1 row in set (0.000 sec) 修改数据库的名字？？ drop删除数据库 删除数据库mydb3 drop database 数据库名; drop database mydb3; drop database `mydb-03`; MariaDB [mydb1]> drop database mydb3; Query OK, 0 rows affected (0.001 sec) 表的CURD 对表本身进行操作：创建，查看，修改，删除。 create创建表 创建表时没有约束 create table 表名 ( 列名 数据类型 ); create table mytb1 ( tid int, tname varchar(20) ); MariaDB [mydb2]> create table employee1( empno int, ename varchar(20), sal double ); Query OK, 0 rows affected (0.010 sec) 换行创建一个表 create table employee( id int, name varchar(20), sex int, birthday date, salary double, entry_date date, resume text ); 但此时会报错误：ERROR 1046 (3D000): No database selected。注意，在mysql中对表操作前，必须先选择所使用的数据库。 use mydb2; 创建表时添加约束 auto_increment表示自动增长 not null 表示不能为空 primary key 表示主键 default 默认值 create table 数据表名字 (字段 类型 约束[, 字段 类型 约束]); create table LimtTable_student( id int unsigned primary key auto_increment not null, name varchar(20) default '', age tinyint unsigned default 0, height decimal(5,2), gender enum('男','女','人妖','保密'), cls_id int unsigned default 0 ); MariaDB [mydb2]> create table LimtTable_student( -> id int unsigned primary key auto_increment not null, -> name varchar(20) default '', -> age tinyint unsigned default 0, -> height decimal(5,2), -> gender enum('男','女','人妖','保密'), -> cls_id int unsigned default 0 -> ) ; Query OK, 0 rows affected (0.011 sec) show显示当前库中所有的表 查看当前使用数据库中所有表： show tables; MariaDB [mydb2]> show tables; +-----------------+ | Tables_in_mydb2 | +-----------------+ | employee | | LimtTable_xxxx | | mytb1 | +-----------------+ 6 rows in set (0.000 sec) show显示表的创建方式 show create table 表名; show create table LimtTable_xxxx; MariaDB [mydb2]> show create table LimtTable_xxxx; +-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | LimtTable_xxxx | CREATE TABLE LimtTable_xxxx ( t_id int(11) NOT NULL AUTO_INCREMENT, t_name varchar(30) DEFAULT NULL, PRIMARY KEY (t_id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 | +-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.001 sec) ENGINE=InnoDB 默认指定的存储引擎 innoDB。 注意，表名称区分大小写 desc显示指定表的结构 desc 表名; desc LimtTable_xxxx; MariaDB [mydb2]> desc LimtTable_xxxx; +--------+-------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+----------------+ | t_id | int(11) | NO | PRI | NULL | auto_increment | | t_name | varchar(30) | YES | | NULL | | +--------+-------------+------+-----+---------+----------------+ 2 rows in set (0.001 sec) 在Mysql中显示多行数据应该在查询语句结尾处添加 \\G来替换结束标记“；” rename更改表名 rename table 旧表名 to 新表名; rename table employee to worker; MariaDB [mydb2]> rename table employee to worker; Query OK, 0 rows affected (0.009 sec) alter修改表 （alter修改表中，column可省，column关键字在Oracle中，添加则语法错误） alter-add增加一个字段 alter table 表名 add 列名 类型; alter table employee add height double; alter table employee add column height double; MariaDB [mydb2]> alter table employee add column height double; Query OK, 0 rows affected (0.003 sec) Records: 0 Duplicates: 0 Warnings: 0 alter-modify修改一个字段类型 alter table 表名 modify 列名 类型及约束; alter table employee modify column height float not null; MariaDB [mydb2]> alter table employee modify column height float not null; Query OK, 0 rows affected (0.001 sec) Records: 0 Duplicates: 0 Warnings: 0 alter-change改变一个字段名 alter table 表名 change 原名 新名 类型及约束; alter table employee change column height height_1 float not null; MariaDB [mydb2]> alter table employee change column height height_1 float; Query OK, 0 rows affected (0.047 sec)Records: 0 Duplicates: 0 Warnings: 0 MariaDB [mydb2]> desc employee; +------------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +------------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | sex | int(11) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double | YES | | NULL | | | entry_date | date | YES | | NULL | | | resume | text | YES | | NULL | | | height_1 | float | NO | | NULL | | +------------+-------------+------+-----+---------+-------+ 8 rows in set (0.001 sec) alter-drop删除一个字段 alter table 表名 drop 列名; alter table employee drop column height_1; MariaDB [mydb2]> alter table employee drop column height_1; Query OK, 0 rows affected (0.019 sec) Records: 0 Duplicates: 0 Warnings: 0 alter-charset修改表的字符集 alter table employee charset=gbk; alter table employee character set utf8; MariaDB [mydb2]> alter table employee charset=gbk; Query OK, 0 rows affected (0.001 sec) Records: 0 Duplicates: 0 Warnings: 0 MariaDB [mydb2]> show create table employee; +----------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +----------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | employee | CREATE TABLE employee ( id int(11) DEFAULT NULL, name varchar(20) CHARACTER SET utf8 DEFAULT NULL, sex int(11) DEFAULT NULL, birthday date DEFAULT NULL, salary double DEFAULT NULL, entry_date date DEFAULT NULL, resume text CHARACTER SET utf8 DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=gbk | +----------+--------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.000 sec) drop删除表 drop删除employee表 drop table 表名; drop table employee; MariaDB [mydb2]> drop table employee; Query OK, 0 rows affected (0.008 sec) 表数据的CURD 创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete） insert插入数据 全列插入 值的顺序与表中字段的顺序对应 一次向表中插入一行数据 insert into 表名 values(记录值,记录值); insert into 表名(记录名,记录名) values(记录值,记录值); insert into employee values(1,'张三',1,'1983-04-27',15000,'2012-06-24','一个大牛'); insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(2,'李四',1,'1984-02-22',10000,'2012-07-24','一个中牛'); MariaDB [mydb2]> insert into employee values(1,'张三',1,'1983-04-27',15000,'2012-06-24','一个大牛'); Query OK, 1 row affected (0.002 sec) 部分列插入 值的顺序与给出的列顺序对应 insert into 表名(列1,...) values(值1,...) insert into employee(name,birthday) values('小明','1994-03-23'); 多行插入 值的顺序与给出的列顺序对应 一次性插入多行数据 insert into 表名 values(...),(...)...; insert into 表名(列1,...) values(值1,...),(值1,...)...; 全列插入 insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(3,'王五',0,'1985-08-28',7000,'2012-08-24','一个小虾'),(3,'赵六',0,'1985-08-28',7000,'2012-08-24','一个小虾'); 部分列插入 insert into employee(name,salary) values('杨康',111),('杨过',222),('小龙女',333); MariaDB [mydb2]> insert into employee(name,salary) values('杨康',111),('杨过',222),('小龙女',333); Query OK, 3 rows affected (0.002 sec) Records: 3 Duplicates: 0 Warnings: 0 update修改数据 update 表名 set 列1=值1,列2=值2... where 条件 将王五的员工薪水修改为10000元，resume改为也是一个中牛 update employee set salary=10000, resume='也是一个中牛' where name='王五'; 将所有员工薪水都增加500元 update employee set salary=salary+500; select查询表数据 查询整个表所有列 select * from 表名; select * from employee; MariaDB [mydb2]> select * from employee; +------+--------+------+------------+--------+------------+--------------+ | id | name | sex | birthday | salary | entry_date | resume | +------+--------+------+------------+--------+------------+--------------+ | 2 | 李四 | 1 | 1984-02-22 | 10000 | 2012-07-24 | 一个中牛 | | 3 | 王五 | 0 | 1985-08-28 | 7000 | 2012-08-24 | 一个小虾 | | 1 | 张三 | 1 | 1983-04-27 | 15000 | 2012-06-24 | 一个大牛 | +------+--------+------+------------+--------+------------+--------------+ 3 rows in set (0.000 sec) 查询指定列 可以使用as为列或表指定别名 select 列1,列2,... from 表名; select id, name; select id, name as \"名字\", salary \"月薪\", salary*12 年薪 from employee where id >=2; MariaDB [mydb2]> select id, name as \"名字\", salary \"月薪\", salary*12 年薪 from employee where id >=2; +------+--------+--------+--------+ | id | 名字 | 月薪 | 年薪 | +------+--------+--------+--------+ | 2 | 李四 | 10000 | 120000 | | 3 | 王五 | 7000 | 84000 | +------+--------+--------+--------+ 2 rows in set (0.000 sec) delete数据 delete from 表名 where 条件 删除表中部分记录 删除表中姓名为王五的记录 delete from employee where name='王五'; 删除表中所有记录 delete from employee; truncate删除表中所有记录 无条件 效率高 truncate employee; 逻辑删除，本质就是修改操作 update students set isdelete=1 where id=1; 备份与恢复 备份 退出数据库连接，执行如下命令 mysqldump备份数据 全库备份 mysqldump -uroot -p -A >bak_full.sql 单库备份 mysqldump -uroot -p mydb2 >bak_mydb2.sql 不加 -B 后面恢复时，要先创库 use库 mysqldump -uroot -p -B ysl >bak_mydb3.sql -B 增加建库（create）及（use库）的语句 后面恢复时，不需要手动创建库和use 另外 -B 选项可以实现， 同时备份多个库，备份到一个文件中 mysqldump -uroot -p -B mydb2 mydb3 >bak_mydb2_mydb3.sql 如果不加 -B 就是备份 ysl库下 test表 mysqldump 库1 表1 表2 表3 > 库1.sql mysqldump mydb2 employee1 employee2 employee3 > 库1.sql mysqldump -uroot -p 数据库名 > bak.sql; chao@deepin:~$ sudo mysqldump -uroot -p mydb2 > bak.sql; [sudo] password for chao: Enter password: 恢复 连接mysql，创建新的数据库 退出数据库连接，执行如下命令 恢复备份的数据 mysql -uroot -p ?? mysql -uroot -p 新数据库名 综合案例 创建一个学生表 create table student( id int, name varchar(20), chinese int, english int, math int ); 插入数据 insert into student(id,name,chinese,english,math) values(1, '范建',80,85,90); insert into student(id,name,chinese,english,math) values(2,'罗况',90,95,95); insert into student(id,name,chinese,english,math) values(3,'杜子腾',80,96,96); insert into student(id,name,chinese,english,math) values(4,'范冰',81,97,85); insert into student(id,name,chinese,english,math) values(5,'申晶冰',85,84,90); insert into student(id,name,chinese,english,math) values(6,'郝丽海',92,85,87); insert into student(id,name,chinese,english,math) values(7,'郭迪辉',75,81,80); insert into student(id,name,chinese,english,math) values(8,'拎壶冲',77,80,79); insert into student(id,name,chinese,english,math) values(9,'任我行',95,85,85); insert into student(id,name,chinese,english,math) values(10,'史泰香',94,85,84); 基础SQL 查询表中所有学生的信息 select * from student; 查询表中所有学生的姓名和对应的英语成绩 select name,english from student; 过滤表中重复数据 select english from student; select DISTINCT english from student; select DISTINCT english,name from student; 在所有学生英语分数上加10分特长分 select name,english+10 from student; 统计每个学生的总分 select english+chinese+math from student; select english+chinese+math as 总分 from student; select name,english+chinese+math as 总分 from student; 使用别名表示学生分数 select name,english+chinese+math as 总分 from student; select name,english+chinese+math 总分 from student; 查询姓名为何东的学生成绩 select * from student where name='何东'; 查询英语成绩大于90分的同学 select * from student where english>90; 查询总分大于250分的所有同学 select * from student where english+chinese+math>250; 查询英语分数在 85－95之间的同学 select * from student where english>=85 and english select * from student where english between 85 and 95; 查询数学分数为84,90,91的同学 select * from student where math=84 or math=90 or math=91; select * from student where math in(84,90,91); 查询所有姓何的学生成绩 select * from student where name like '何%'; 查询数学分>85，语文分>90的同学 select * from student where math>85 and chinese>90; 对数学成绩排序后输出 select * from student order by math; 对总分排序后输出，然后再按从高到低的顺序输出 select * from student order by math+chinese+english desc; 对姓何的学生成绩排序输出 select * from student where name like '何%' order by math+chinese+english desc; select name, math+chinese+english from student where name like '何%' order by math+chinese+english desc; 统计一个班级共有多少学生？ select count(*) from student; 统计数学成绩大于90的学生有多少个？ select count(*) from student where math>90; 统计总分大于250的人数有多少？ select count(*) from student where math+chinese+english>250; 统计一个班级数学总成绩？ select sum(math) from student; 统计一个班级语文、英语、数学各科的总成绩 select sum(math), sum(chinese), sum(english) from student; 统计一个班级语文、英语、数学的成绩总和 select sum(math+chinese+english)from student; select sum(math)+sum(chinese)+sum(english) from student; 求一个班级数学平均分？ select avg(math) from student; 求一个班级总分平均分 select avg(math+chinese+english)from student; select avg(math)+avg(chinese)+avg(english) from student; 求班级最高分和最低分 select max(math+chinese+english),min(math+chinese+english) from student; 分组数据 为学生表，增加一个班级列，练习分组查询。 alter table student add column class_id int; 更新表： update student set class_id=1 where id update student set class_id=2 where id>5; (update student set class_id=2 where id between 6 and 10;) 查出各个班的总分，最高分。 求各个班级 英语的平均分： select class_id, avg(english) from student group by class_id 如根据组函数的语法要求，将select后增加name列，而不加至group by 之后： select name, class_id, avg(english) from student group by class_id; 会发现mysql检查不出错误。相比Oracle数据库，mysql分组检查不严格。 select sum(math+chinese+english),max(math+chinese+english) from student group by class_id; 查询出班级总分大于1300分的班级ID select class_id from student group by class_id having sum(math+chinese+english)>1300; select class_id from student where sum(math+chinese+english)>1300 group by class_id ; 对于组函数的应用与Oracle类似，可以应用于Having中，但不能用于where子句中。 mysql查询 select查询的完整格式 SELECT select_expr [,select_expr,...] [ FROM tb_name [WHERE 条件判断] [GROUP BY {col_name | postion} [ASC | DESC], ...] [HAVING WHERE 条件判断] [ORDER BY {col_name|expr|postion} [ASC | DESC], ...] [LIMIT {[offset,]rowcount | row_count OFFSET offset}] ] 完整的select语句 select distinct * from 表名 where .... group by ... having ... order by ... limit start,count 执行顺序为： from 表名 where .... group by ... select distinct * having ... order by ... limit start,count 基本表数据查询 准备数据 创建数据库 -- 创建数据库 create database python_test_1 charset=utf8; -- 使用数据库 use python_test_1; 创建数据表 -- 创建students表 create table students( id int unsigned primary key auto_increment not null, name varchar(20) default '', age tinyint unsigned default 0, height decimal(5,2), gender enum('男','女','中性','保密') default '保密', cls_id int unsigned default 0, is_delete bit default 0 ); -- 创建classes表 create table classes ( id int unsigned auto_increment primary key not null, name varchar(30) not null ); 表中插入数据 -- 向students表中插入数据 insert into students values (0,'小明',18,180.00,2,1,0), (0,'小月月',18,180.00,2,2,1), (0,'彭于晏',29,185.00,1,1,0), (0,'刘德华',59,175.00,1,2,1), (0,'黄蓉',38,160.00,2,1,0), (0,'凤姐',28,150.00,4,2,1), (0,'王祖贤',18,172.00,2,1,1), (0,'周杰伦',36,NULL,1,1,0), (0,'程坤',27,181.00,1,2,0), (0,'刘亦菲',25,166.00,2,2,0), (0,'金星',33,162.00,3,3,1), (0,'静香',12,180.00,2,4,0), (0,'郭靖',12,170.00,1,4,0), (0,'周杰',34,176.00,2,5,0); -- 向classes表中插入数据 insert into classes values (0, \"python_01期\"), (0, \"python_02期\"); 查询所有字段 查询所有字段 select * from 表名; 例： select * from students; 查询指定字段 查询指定字段 select 列1,列2,... from 表名; 例: select name from students; as给字段起别名 使用 as 给字段起别名 select 列1 as 别名1, 列2 as 别名2, ... from 表名; 例: select id as 序号, name as 名字, gender as 性别 from students; as给表起别名 使用 as 给表起别名 -- 如果是单表查询 可以省略表名，直接字段名 select id, name, gender from students; -- 不省略表名形式，表名.字段名 select students.id,students.name,students.gender from students; -- 使用 as 给表起别名 select s.id,s.name,s.gender from students as s; distinct消除重复行 在select后面列前使用distinct可以消除重复的行 select distinct 列1,... from 表名; 例： select distinct gender from students; MariaDB [python_test_1]> select distinct gender from students; +--------+ | gender | +--------+ | 女 | | 男 | | 保密 | | 中性 | +--------+ 4 rows in set (0.001 sec) where条件查询 使用where子句对表中的数据筛选，结果为true的行会出现在结果集中 select * from 表名 where 条件; 例： select * from students where id=1; where后面支持多种运算符，进行条件的处理 比较运算符 逻辑运算符 模糊查询 范围查询 空判断 比较运算符(=,!=,>,>=) 等于: = 大于: > 大于等于: >= 小于: 小于等于: 不等于: != 或 <> 例1：查询编号大于3的学生 select * from students where id > 3; 例2：查询编号不大于4的学生 select * from students where id 例3：查询姓名不是“黄蓉”的学生 select * from students where name != '黄蓉'; 例4：查询没被删除的学生 select * from students where is_delete=0; 逻辑运算符(and,or,not) and or not 例5：查询编号大于3的女同学 select * from students where id > 3 and gender='女'; 例6：查询编号小于4或没被删除的学生 select * from students where id like模糊查询 like %表示任意多个任意字符 _表示一个任意字符 例7：查询姓周的学生 select * from students where name like '周%'; 例8：查询姓周并且“名”是一个字的学生 select * from students where name like '周_'; 例9：查询姓周或叫靖的学生 select * from students where name like '周%' or name like '%靖'; in/between-and范围查询 in非连续的范围内 in(…)表示在一个非连续的范围内 例10：查询编号是1或3或8的学生 select * from students where id in(1,3,8); between .. and连续的范围内 between ... and ...表示在一个连续的范围内 例11：查询编号为3至8的学生 select * from students where id between 3 and 8; 例12：查询编号是3至8的男生 select * from students where (id between 3 and 8) and gender=1; is null空判断 注意：null与''是不同的 判空is null 判空 is null 例13：查询没有填写身高的学生 select * from students where height is null; 判非空is not null 判非空 is not null 例14：查询填写了身高的学生 select * from students where height is not null; 例15：查询填写了身高的男生 select * from students where height is not null and gender=1; 条件优先级 优先级由高到低的顺序为： 小括号 > not > 比较运算符 > 逻辑运算符(and比or先运算) order-by排序 为了方便查看数据，可以对数据进行排序 语法： select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...] 将行数据按照 列1 进行排序，如果某些行列1的值相同时，则按照 列2 排序，以此类推 asc从小到大排列，即升序（默认） desc从大到小排序，即降序 例1：查询未删除男生信息，按学号降序 select * from students where gender=1 and is_delete=0 order by id desc; 例2：查询未删除学生信息，按名称升序 select * from students where is_delete=0 order by name; 例3：显示所有的学生信息，先按照年龄从大-->小排序，当年龄相同时 按照身高从高-->矮排序 select * from students order by age desc,height desc; MariaDB [python_test_1]> select * from students order by age desc,height desc; +----+-----------+------+--------+--------+--------+-----------+ | id | name | age | height | gender | cls_id | is_delete | +----+-----------+------+--------+--------+--------+-----------+ | 4 | 刘德华 | 59 | 175.00 | 男 | 2 | | | 5 | 黄蓉 | 38 | 160.00 | 女 | 1 | | | 8 | 周杰伦 | 36 | NULL | 男 | 1 | | | 14 | 周杰 | 34 | 176.00 | 女 | 5 | | | 11 | 金星 | 33 | 162.00 | 中性 | 3 | | | 3 | 彭于晏 | 29 | 185.00 | 男 | 1 | | | 6 | 凤姐 | 28 | 150.00 | 保密 | 2 | | | 9 | 程坤 | 27 | 181.00 | 男 | 2 | | | 10 | 刘亦菲 | 25 | 166.00 | 女 | 2 | | | 2 | 小月月 | 18 | 180.00 | 女 | 2 | | | 1 | 小明 | 18 | 180.00 | 女 | 1 | | | 7 | 王祖贤 | 18 | 172.00 | 女 | 1 | | | 12 | 静香 | 12 | 180.00 | 女 | 4 | | | 13 | 郭靖 | 12 | 170.00 | 男 | 4 | | +----+-----------+------+--------+--------+--------+-----------+ 14 rows in set (0.000 sec) 统计聚合函数 为了快速得到统计数据，经常会用到如下5个聚合函数 count总数 count(*)表示计算总行数，括号中写星与列名，结果是相同的 例1：查询学生总数 select count(*) from students; select count(id) from students; MariaDB [python_test_1]> select count() from students; +----------+ | count() | +----------+ | 14 | +----------+ 1 row in set (0.000 sec) max最大值 max(列)表示求此列的最大值 例2：查询女生的编号最大值 select max(id) from students where gender=2; min最小值 min(列)表示求此列的最小值 例3：查询未删除的学生最小编号 select min(id) from students where is_delete=0; sum求和 sum(列)表示求此列的和 例4：查询男生的总年龄 select sum(age) from students where gender=1; -- 平均年龄 select sum(age)/count(*) from students where gender=1; avg平均值 avg(列)表示求此列的平均值 例5：查询未删除女生的编号平均值 select avg(id) from students where is_delete=0 and gender=2; group by分组 group by的含义：将查询结果按照1个或多个字段进行分组，字段值相同的为一组 group by可用于单个字段分组，也可用于多个字段分组 select gender from students group by gender; -- 未分组 MariaDB [python_test_1]> select gender from students; +--------+ | gender | +--------+ | 女 | | 女 | | 男 | | 男 | | 女 | | 保密 | | 女 | | 男 | | 男 | | 女 | | 中性 | | 女 | | 男 | | 女 | +--------+ 14 rows in set (0.000 sec) -- 分组 MariaDB [python_test_1]> select gender from students group by gender; +--------+ | gender | +--------+ | 男 | | 女 | | 中性 | | 保密 | +--------+ 4 rows in set (0.000 sec) 根据gender字段来分组，gender字段的全部值有4个'男','女','中性','保密'，所以分为了4组。 当group by单独使用时，只显示出每组的第一条记录, 所以group by单独使用时的实际意义不大 group by + group_concat() group_concat(字段名)可以作为一个输出字段来使用，表示分组之后，根据分组结果，使用group_concat()来放置每一组的某字段的值的集合 select gender,group_concat(name) from students group by gender; --- group_concat()输出列集合内容 MariaDB [python_test_1]> select gender,group_concat(name) from students group by gender; +--------+--------------------------------------------------------+ | gender | group_concat(name) | +--------+--------------------------------------------------------+ | 男 | 周杰伦,郭靖,彭于晏,刘德华,程坤 | | 女 | 静香,刘亦菲,小明,王祖贤,黄蓉,小月月,周杰 | | 中性 | 金星 | | 保密 | 凤姐 | +--------+--------------------------------------------------------+ 4 rows in set (0.000 sec) group by + 聚合统计函数 通过group_concat()的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们也可以通过聚合统计函数来对这个值的集合做一些操作 -- 分组显示 select gender,group_concat(age) from students group by gender; +--------+----------------------+ | gender | group_concat(age) | +--------+----------------------+ | 男 | 29,59,36,27,12 | | 女 | 18,18,38,18,25,12,34 | | 中性 | 33 | | 保密 | 28 | +--------+----------------------+ -- 分别统计性别为男/女的人年龄平均值 select gender,avg(age) from students group by gender; +--------+----------+ | gender | avg(age) | +--------+----------+ | 男 | 32.6000 | | 女 | 23.2857 | | 中性 | 33.0000 | | 保密 | 28.0000 | +--------+----------+ -- 分别统计性别为男/女的人的个数 select gender,count(*) from students group by gender; select gender,count(id) from students group by gender; +--------+----------+ | gender | count(*) | +--------+----------+ | 男 | 5 | | 女 | 7 | | 中性 | 1 | | 保密 | 1 | +--------+----------+ group by + having条件 having 条件表达式：用来分组查询后指定一些条件来输出查询结果 having作用和where一样，但having只能用于group by -- 分别统计性别为男/女的人的个数，且个数>2的 select gender,count(*) from students group by gender having count(*)>2; select gender,count(id) from students group by gender having count(id)>2; +--------+----------+ | gender | count(*) | +--------+----------+ | 男 | 5 | | 女 | 7 | +--------+----------+ group by + with rollup with rollup的作用是：在最后新增一行，来记录当前列里所有记录的总和 select gender,count(*) from students group by gender with rollup; +--------+----------+ | gender | count(*) | +--------+----------+ | 男 | 5 | | 女 | 7 | | 中性 | 1 | | 保密 | 1 | | NULL | 14 | +--------+----------+ select gender,group_concat(age) from students group by gender with rollup; +--------+-------------------------------------------+ | gender | group_concat(age) | +--------+-------------------------------------------+ | 男 | 29,59,36,27,12 | | 女 | 18,18,38,18,25,12,34 | | 中性 | 33 | | 保密 | 28 | | NULL | 29,59,36,27,12,18,18,38,18,25,12,34,33,28 | +--------+-------------------------------------------+ limit分页 获取部分行 当数据量过大时，在一页中查看数据是一件非常麻烦的事情 select * from 表名 limit start,count 说明 从start开始，获取count条数据 例1：查询前3行男生信息 select * from students where gender=1 limit 0,3; MariaDB [python_test_1]> select * from students where gender=1 limit 0,3; +----+-----------+------+--------+--------+--------+-----------+ | id | name | age | height | gender | cls_id | is_delete | +----+-----------+------+--------+--------+--------+-----------+ | 3 | 彭于晏 | 29 | 185.00 | 男 | 1 | | | 4 | 刘德华 | 59 | 175.00 | 男 | 2 | | | 8 | 周杰伦 | 36 | NULL | 男 | 1 | | +----+-----------+------+--------+--------+--------+-----------+ 3 rows in set (0.000 sec) 子查询 主查询：主要查询的对象,第一条 select 语句 子查询：在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句 主查询和子查询的关系 子查询是嵌入到主查询中 子查询是辅助主查询的,要么充当条件,要么充当数据源 子查询是可以独立存在的语句,是一条完整的 select 语句 子查询分类 标量子查询: 子查询返回的结果是一个数据(一行一列) 列子查询: 返回的结果是一列(一列多行) 行子查询: 返回的结果是一行(一行多列) 标量子查询？？ 标量子查询: 子查询返回的结果是一个数据(一行一列) 需求: 查询大于平均年龄的学生 先查询班级学生平均年龄，再查询大于平均年龄的学生 select * from students where age > (select avg(age) from students); MariaDB [python_test_1]> select * from students where age > (select avg(age) from students); +----+-----------+------+--------+--------+--------+-----------+ | id | name | age | height | gender | cls_id | is_delete | +----+-----------+------+--------+--------+--------+-----------+ | 3 | 彭于晏 | 29 | 185.00 | 男 | 1 | | | 4 | 刘德华 | 59 | 175.00 | 男 | 2 | | | 5 | 黄蓉 | 38 | 160.00 | 女 | 1 | | | 6 | 凤姐 | 28 | 150.00 | 保密 | 2 | | | 8 | 周杰伦 | 36 | NULL | 男 | 1 | | | 11 | 金星 | 33 | 162.00 | 中性 | 3 | | | 14 | 周杰 | 34 | 176.00 | 女 | 5 | | +----+-----------+------+--------+--------+--------+-----------+ 7 rows in set (0.001 sec) 列级子查询？？ 列子查询: 返回的结果是一列(一列多行) 需求: 查询还有学生在班的所有班级名字 先找出学生表中所有的班级 id，再找出班级表中对应的名字 select name from classes where id in (select cls_id from students); MariaDB [python_test_1]> select name from classes where id in (select cls_id from students); +--------------+ | name | +--------------+ | python_01期 | | python_02期 | +--------------+ 2 rows in set (0.000 sec) 行级子查询?? 行子查询: 返回的结果是一行(一行多列) 需求: 查找班级年龄最大,身高最高的学生 行元素: 将多个字段合成一个行元素,在行级子查询中会使用到行元素 select * from students where (height,age) = (select max(height),max(age) from students); 子查询中特定关键字使用 in 范围 格式: 主查询 where 条件 in (列子查询) 多表查询 mysql 使用SQL99标准的连接查询（JOIN..ON..） 交叉连接 叉集，即笛卡尔集 select e.*, d.* from emp e cross join dept d 无连接条件 满外联接 任一边有值就会显示 select e.*, d.* from emp e full outer join dept d on e.deptno=d.deptno 也可以省略outer关键字 连接查询 当查询结果的列来源于多张表时，需要将多张表连接成一个大的数据集，再选择合适的列返回 mysql支持三种类型的连接查询，分别为：内连接查询，右连接查询，左连接查询 inner内连接 内连接查询：查询的结果为两个表匹配到的数据 只返回满足连接条件的数据（两边都有的才显示）。 对应等值连接 使用内连接查询班级表与学生表 select * from students inner join classes on students.cls_id = classes.id; MariaDB [python_test_1]> select * from students inner join classes on students.cls_id = classes.id; +----+----------+------+-------+--------+----------+------+--------+------+ | id | name | age | height | gender | cls_id | is_delete | id | name | +----+----------+------+--------+-------+--------+----+----+--------------+ | 1 | 小明 | 18 | 180.00 | 女 | 1 | | 1 | python_01期 | | 2 | 小月月 | 18 | 180.00 | 女 | 2 | | 2 | python_02期 | | 3 | 彭于晏 | 29 | 185.00 | 男 | 1 | | 1 | python_01期 | | 4 | 刘德华 | 59 | 175.00 | 男 | 2 | | 2 | python_02期 | | 5 | 黄蓉 | 38 | 160.00 | 女 | 1 | | 1 | python_01期 | | 6 | 凤姐 | 28 | 150.00 | 保密 | 2 | | 2 | python_02期 | | 7 | 王祖贤 | 18 | 172.00 | 女 | 1 | | 1 | python_01期 | | 8 | 周杰伦 | 36 | NULL | 男 | 1 | | 1 | python_01期 | | 9 | 程坤 | 27 | 181.00 | 男 | 2 | | 2 | python_02期 | | 10 | 刘亦菲 | 25 | 166.00 | 女 | 2 | | 2 | python_02期 | +----+----------+------+--------+--------+-------+----+----+--------------+ 10 rows in set (0.001 sec) select e.*, d.* from emp e inner join dept d on e.deptno=d.deptno 也可以省略inner关键字 左外连接 左连接查询：查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用null填充 左边有值才显示 使用左连接查询班级表与学生表 select * from students as s left join classes as c on s.cls_id = c.id; MariaDB [python_test_1]> select * from students as s left join classes as c on s.cls_id = c.id; +----+-----------+------+--------+--------+--------+-----------+------+--------------+ | id | name | age | height | gender | cls_id | is_delete | id | name | +----+-----------+------+--------+--------+--------+-----------+------+--------------+ | 1 | 小明 | 18 | 180.00 | 女 | 1 | | 1 | python_01期 | | 2 | 小月月 | 18 | 180.00 | 女 | 2 | | 2 | python_02期 | | 3 | 彭于晏 | 29 | 185.00 | 男 | 1 | | 1 | python_01期 | | 4 | 刘德华 | 59 | 175.00 | 男 | 2 | | 2 | python_02期 | | 5 | 黄蓉 | 38 | 160.00 | 女 | 1 | | 1 | python_01期 | | 6 | 凤姐 | 28 | 150.00 | 保密 | 2 | | 2 | python_02期 | | 7 | 王祖贤 | 18 | 172.00 | 女 | 1 | | 1 | python_01期 | | 8 | 周杰伦 | 36 | NULL | 男 | 1 | | 1 | python_01期 | | 9 | 程坤 | 27 | 181.00 | 男 | 2 | | 2 | python_02期 | | 10 | 刘亦菲 | 25 | 166.00 | 女 | 2 | | 2 | python_02期 | | 11 | 金星 | 33 | 162.00 | 中性 | 3 | | NULL | NULL | | 12 | 静香 | 12 | 180.00 | 女 | 4 | | NULL | NULL | | 13 | 郭靖 | 12 | 170.00 | 男 | 4 | | NULL | NULL | | 14 | 周杰 | 34 | 176.00 | 女 | 5 | | NULL | NULL | +----+-----------+------+--------+--------+--------+-----------+------+--------------+ 14 rows in set (0.002 sec) 此处使用了as为表起别名，目的是编写简单 select e.*, d.* from emp e left outer join dept d on e.deptno=d.deptno 也可以省略outer关键字 右外连接 右连接查询：查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用null填充 右边边有值才显示。 使用右连接查询班级表与学生表 select * from students as s right join classes as c on s.cls_id = c.id; MariaDB [python_test_1]> select * from students as s right join classes as c on s.cls_id = c.id; +------+-----------+------+--------+--------+--------+-----------+----+--------------+ | id | name | age | height | gender | cls_id | is_delete | id | name | +------+-----------+------+--------+--------+--------+-----------+----+--------------+ | 1 | 小明 | 18 | 180.00 | 女 | 1 | | 1 | python_01期 | | 2 | 小月月 | 18 | 180.00 | 女 | 2 | | 2 | python_02期 | | 3 | 彭于晏 | 29 | 185.00 | 男 | 1 | | 1 | python_01期 | | 4 | 刘德华 | 59 | 175.00 | 男 | 2 | | 2 | python_02期 | | 5 | 黄蓉 | 38 | 160.00 | 女 | 1 | | 1 | python_01期 | | 6 | 凤姐 | 28 | 150.00 | 保密 | 2 | | 2 | python_02期 | | 7 | 王祖贤 | 18 | 172.00 | 女 | 1 | | 1 | python_01期 | | 8 | 周杰伦 | 36 | NULL | 男 | 1 | | 1 | python_01期 | | 9 | 程坤 | 27 | 181.00 | 男 | 2 | | 2 | python_02期 | | 10 | 刘亦菲 | 25 | 166.00 | 女 | 2 | | 2 | python_02期 | +------+-----------+------+--------+--------+--------+-----------+----+--------------+ 10 rows in set (0.000 sec) select e.*, d.* from emp e right outer join dept d on e.deptno=d.deptno 也可以省略outer关键字 【注意】SQL99中，外链接取值与关系表达式=号左右位置无关。取值跟from后表的书写顺序有关。 “xxx left outer join yyy” 则为取出xxx的内容。 “xxx right outer join yyy”则为取出yyy的内容 自连接 查询员工、老板信息，显示: xxx的老板是xxx 分析：将一张emp表当成两张表看待：员工表、老板表（员工表的老板 是 老板表的员工） select concat( e.ename, ' 的老板是 ', b.ename ) from emp e left outer join emp b on e.mgr = b.empno ; 滤空修正 ifnull select concat( e.ename, ' 的老板是 ', ifnull(b.ename, '他自己' ) ) from emp e left outer join emp b on e.mgr = b.empno ; mysql进阶 mysql内置函数 显示数据库版本 select version(); +---------------------------+ | version() | +---------------------------+ | 10.3.23-MariaDB-0+deb10u1 | +---------------------------+ 1 row in set (0.000 sec) 日期时间函数 mysql里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)。 现在时间日期： MariaDB [(none)]> select now(); +---------------------+ | now() | +---------------------+ | 2020-09-17 22:43:37 | +---------------------+ 1 row in set (0.000 sec) 年，月，日，日期： MariaDB [(none)]> select now(), year(now()) 年, month(now()) 月, day(now()) 日, date(now()) 日期; +---------------------+------+------+------+------------+ | now() | 年 | 月 | 日 | 日期 | +---------------------+------+------+------+------------+ | 2020-09-17 22:47:30 | 2020 | 9 | 17 | 2020-09-17 | +---------------------+------+------+------+------------+ 1 row in set (0.000 sec) 当前日期，当前时间，当前时间戳： MariaDB [(none)]> select CURRENT_DATE() , CURRENT_TIME(), CURRENT_TIMESTAMP() from dual; +----------------+----------------+---------------------+ | CURRENT_DATE() | CURRENT_TIME() | CURRENT_TIMESTAMP() | +----------------+----------------+---------------------+ | 2020-09-17 | 22:48:00 | 2020-09-17 22:48:00 | +----------------+----------------+---------------------+ 1 row in set (0.000 sec) 昨天、今天、明天： MariaDB [(none)]> select now()-1 昨天, now() 今天, now()+1 明天; +----------------+---------------------+----------------+ | 昨天 | 今天 | 明天 | +----------------+---------------------+----------------+ | 20200917225108 | 2020-09-17 22:51:09 | 20200917225110 | +----------------+---------------------+----------------+ 1 row in set (0.000 sec) 与Oracle中的日期加减操作有所不同。 select date_add(now(), INTERVAL 2 year) from dual; //增加两年 select date_add(now(), INTERVAL -1 day) 昨天, now() 今天, date_add(now(), INTERVAL +1 day) 明天; 字符串相关函数 字符串拼接 select concat('hello ', 'mysql ', 'haha ', 'hehe ') from dual; 日期转字符串： select date_format(now(), '%Y-%m-%d') from dual; y和Y不一样。 select date_format(now(), '%Y-%c-%d %h:%i:%s') from dual; c和m、M不一样 所以yyyy-mm-dd hh24:mi:ss格式在mysql中对应'%Y-%c-%d %h:%i:%s' 字符串转日期： select str_to_date('2013-6-04 05:14:15' , '%Y-%c-%d %h:%i:%s') from dual; 数学相关函数 视图 视图是什么 视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）； 通俗的讲，视图就是一条SELECT查询语句执行后返回的结果，只作为一个虚拟的表。 方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性； 定义视图 建议以v_开头 create view 视图名称 as select语句; 查看视图 查看表会将所有的视图也列出来 show tables; 使用视图 视图的用途就是查询 select * from v_stu_score; 删除视图 drop view 视图名称; 例： drop view v_stu_sco; 视图的作用 提高了重用性，就像一个函数 对数据库重构，却不影响程序的运行 提高了安全性能，可以对不同的用户 让数据更加清晰 事务 所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。 事务广泛的运用于订单系统、银行系统等多种场景。例如，银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。所以，应该把他们看成一个事务。 事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。 事务四大特性 原子性（atomicity） 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性 一致性（consistency） 数据库总是从一个一致性的状态转换到另一个一致性的状态。 隔离性（isolation） 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。 持久性（durability） 一旦事务提交，则其所做的修改会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。） 表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎 查看表的创建语句，可以看到engine=innodb -- 选择数据库 use jing_dong; -- 查看goods表 show create table goods; begin开启事务 开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中 begin; 或者 start transaction; commit提交事务 将缓存中的数据变更维护到物理表中 commit; rollback回滚事务 放弃缓存中变更的数据 rollback; 注意 修改数据的命令会自动的触发事务，包括insert、update、delete 而在SQL语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据 索引 当数据库中数据量很大时，查找数据会变得很慢 优化方案：索引，索引的目的在于提高查询效率 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度 索引原理 除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。 数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(>、 创建索引 create index 创建索引 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致 字段类型如果不是字符串，可以不填写长度部分 create index 索引名称 on 表名(字段名称(长度)) create index title_index on test_index(title(10)); 查看索引 show index 查看索引 show index from 表名; show index from test_index; 删除索引 drop index 删除索引 drop index 索引名称 on 表名; drop index title_index on test_index; 索引查询测试demo 创建测试表testindex create table test_index(title varchar(10)); 表中插入数据 使用python通过pymsql模块 向表中加入十万条数据 from pymysql import connect def main(): # 创建Connection连接 conn = connect(host='localhost',port=3306,database='jing_dong',user='root',password='mysql',charset='utf8') # 获得Cursor对象 cursor = conn.cursor() # 插入10万次数据 for i in range(100000): cursor.execute(\"insert into test_index values('ha-%d')\" % i) # 提交数据 conn.commit() if __name__ == \"__main__\": main() 查询测试 开启运行时间监测： set profiling=1; 查找第1万条数据ha-99999 select * from test_index where title='ha-99999'; 查看执行的时间： show profiles; 为表title_index的title列创建索引： create index title_index on test_index(title(10)); 执行查询语句： select * from test_index where title='ha-99999'; 再次查看执行的时间 show profiles; 注意： 要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。 建立索引会占用磁盘空间 账户管理 在生产环境下操作数据库时，绝对不可以使用root账户连接，而是创建特定的账户，授予这个账户特定的操作权限，然后连接进行操作，主要的操作就是数据的crud 账户的操作主要包括创建账户、删除账户、修改密码、授权权限等 MySQL账户体系：根据账户所具有的权限的不同，MySQL的账户可以分为以下几种 服务实例级账号：，启动了一个mysqld，即为一个数据库实例；如果某用户如root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表 数据库级别账号：对特定数据库执行增删改查的所有操作 数据表级别账号：对特定表执行增删改查等所有操作 字段级别的权限：对某些表的特定字段进行操作 存储程序级别的账号：对存储程序进行增删改查的操作 注意： 进行账户操作时，需要使用root账户登录，这个账户拥有最高的实例级权限 通常都使用数据库级操作权限 查看所有用户 所有用户及权限信息存储在mysql数据库的user表中 查看user表的结构 use mysql; desc user; 查看所有用户 select host,user,authentication_string from user; +-----------+------+-------------------------------------------+ | host | user | authentication_string | +-----------+------+-------------------------------------------+ | localhost | root | *7B8548874FE70CF8EB7AEF2C2EDFFD494534A84E | +-----------+------+-------------------------------------------+ 1 row in set (0.000 sec) Host表示允许访问的主机 User表示用户名 authentication_string表示密码，为加密后的值 创建账户&授权 需要使用实例级账户登录后操作，以root为例 常用权限主要包括：create、alter、drop、insert、update、delete、select 如果分配所有权限，可以使用all privileges grant 权限列表 on 数据库 to '用户名'@'访问主机' identified by '密码'; 示例1 创建一个laowang的账号，密码为123456，只能通过本地访问, 并且只能对jing_dong数据库中的所有表进行读操作 step1：使用root登录 mysql -uroot -p step2：创建账户并授予所有权限 grant select on jing_dong.* to 'laowang'@'localhost' identified by '123456'; 说明 可以操作python数据库的所有表，方式为:jing_dong.* 访问主机通常使用 百分号% 表示此账户可以使用任何ip的主机登录访问此数据库 访问主机可以设置成 localhost或具体的ip，表示只允许本机或特定主机访问 step3：查看用户有哪些权限 show grants for laowang@localhost; step4：退出root的登录 quit step5：使用laowang账户登录 mysql -ulaowang -p 修改权限 grant 权限名称 on 数据库 to 账户@主机 with grant option; 修改密码 使用root登录，修改mysql数据库的user表 使用password()函数进行密码加密 update user set authentication_string=password('新密码') where user='用户名'; 例： update user set authentication_string=password('123') where user='laowang'; 注意修改完成后需要刷新权限 flush privileges 删除账户 使用root登录 drop user '用户名'@'主机'; 例： drop user 'laowang'@'%'; -- 操作结束之后需要刷新权限 flush privileges 或者使用root登录，删除mysql数据库的user表中数据 delete from user where user='用户名'; 例： delete from user where user='laowang'; -- 操作结束之后需要刷新权限 flush privileges MySQL主从同步 主从同步的定义 主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。 使用主从同步的好处： 通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。 提高数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能 主从同步的机制 Mysql服务器之间的主从同步是基于二进制日志机制，主服务器使用二进制日志来记录数据库的变动情况，从服务器通过读取和执行该日志文件来保持和主服务器的数据一致。 在使用二进制日志时，主服务器的所有操作都会被记录下来，然后从服务器会接收到该日志的一个副本。从服务器可以指定执行该日志中的哪一类事件（譬如只插入数据或者只更新数据），默认会执行日志中的所有语句。 每一个从服务器会记录关于二进制日志的信息：文件名和已经处理过的语句，这样意味着不同的从服务器可以分别执行同一个二进制日志的不同部分，并且从服务器可以随时连接或者中断和服务器的连接。 主服务器和每一个从服务器都必须配置一个唯一的ID号（在my.cnf文件的[mysqld]模块下有一个server-id配置项），另外，每一个从服务器还需要通过CHANGE MASTER TO语句来配置它要连接的主服务器的ip地址，日志文件名称和该日志里面的位置（这些信息存储在主服务器的数据库里）。 配置主从同步的基本步骤 有很多种配置主从同步的方法，可以总结为如下的步骤： 在主服务器上，必须开启二进制日志机制和配置一个独立的ID 在每一个从服务器上，配置一个唯一的ID，创建一个用来专门复制主服务器数据的账号 在开始复制进程前，在主服务器上记录二进制文件的位置信息 如果在开始复制之前，数据库中已经有数据，就必须先创建一个数据快照（可以使用mysqldump导出数据库，或者直接复制数据文件） 配置从服务器要连接的主服务器的IP地址和登陆授权，二进制日志文件名和位置 python操作MySQL数据库 Python 中操作 MySQL 步骤 引入模块 在py文件中引入pymysql模块 from pymysql import * Connection对象 用于建立与数据库的连接 对象的方法 connect()连接 close()关闭连接 commit()提交 cursor()返回Cursor对象，用于执行sql语句并获得结果 connect()方法 创建对象，调用connect()方法 conn=connect(参数列表) 参数host：连接的mysql主机，如果本机是'localhost' 参数port：连接的mysql主机的端口，默认是3306 参数database：数据库的名称 参数user：连接的用户名 参数password：连接的密码 参数charset：通信采用的编码方式，推荐使用utf8 Cursor对象 用于执行sql语句，使用频度最高的语句为select、insert、update、delete 获取Cursor对象 获取Cursor对象：调用Connection对象的cursor()方法 cs1=conn.cursor() 对象的方法 close()关闭 execute(operation [, parameters ])执行语句，返回受影响的行数，主要用于执行insert、update、delete语句，也可以执行create、alter、drop等语句 fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组 fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回 对象的属性 rowcount只读属性，表示最近一次execute()执行后受影响的行数 connection获得当前连接对象 数据库设计 数据库设计范式(Normal Form) 第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。 【联系人】（姓名，性别，电话） 如果一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即： 【联系人】（姓名，性别，家庭电话，公司电话） 第二范式（2NF）：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName） 因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是（OrderID，ProductID）。显而易见 Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。 可以把【OrderDetail】表拆分为 【OrderDetail】（OrderID，ProductID，Discount，Quantity）。 【Product】（ProductID，UnitPrice，ProductName） 来消除原订单表中UnitPrice，ProductName多次重复的情况。 第三范式（3NF）：非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity） 主键是（OrderID）。 其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。 通过拆分【Order】为 【Order】（OrderID，OrderDate，CustomerID） 【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity） 从而达到 3NF。 第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。 常见问题 解决sudo登陆问题 python:连接mysql出现1045或1698 \"Access denied for user...\"错误提示 很可能是因为mysql 登录每次都需要用sudo造成的 mysql -u root -p Enter password: ERROR 1698 (28000): Access denied for user 'root'@'localhost' sudo 登陆mysql sudo mysql -u root -p 查看一下user表，错误的起因就是在这里， root的plugin被修改成了auth_socket，用密码登陆的plugin应该是mysql_native_password。 MariaDB [(none)]> select user, plugin from mysql.user; +------+-------------+ | user | plugin | +------+-------------+ | root | unix_socket | +------+-------------+ 1 row in set (0.000 sec) MariaDB [(none)]> update mysql.user set authentication_string=PASSWORD('7878'), plugin='mysql_native_password' where user='root'; Query OK, 1 row affected (0.001 sec) Rows matched: 1 Changed: 1 Warnings: 0 MariaDB [(none)]> select user, plugin from mysql.user; +------+-----------------------+ | user | plugin | +------+-----------------------+ | root | mysql_native_password | +------+-----------------------+ 1 row in set (0.000 sec) MariaDB [(none)]> flush privileges; Query OK, 0 rows affected (0.000 sec) 重启服务，问题就解决了 sudo service mysql restart mysql中文乱码问题 三层因素： 因素1： mysql自身的设计 因素2：操作系统的语言集 因素3：文件存储格式 $ mysql> show variables like 'character%'; 查看所有应用的字符集 $ mysql -uroot -p123456 --default_character_set=gbk 指定字符集登录数据库 mysql> show variables like 'character%'; 影响了与客户端相关联的 3处 (最外层) 在这种状态下执行use mydb2; mysql> select * from employee; 查看输出，会出现乱码。 原来的三条数据，是以utf8的形式存储到数据库中，当使用gbk连接以后，数据库仍按照utf8的形式将数据返回，出错。 在该环境下插入带有中文的一行数据。 mysql> insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(10,'张三疯',1,'1983-09-21',15000,'2012-06-24','一个老牛'); ERROR 1366 (HY000): Incorrect string value: '\\x80\\xE4\\xB8\\xAA\\xE8\\x80...' for column 'resume' at row 1 因素2：操作系统的语言集 linux操作系统 是一个 多用户的操作 [root@localhost ~]# cat /etc/sysconfig/i18n LANG=\"zh_CN.UTF-8\" 操作系统的菜单按照zh_CN显示, 文件存储按照utf8 linux操作系统语言环境 和 用户的配置的语言环境LANG 相互影响 [mysql01@localhost ~]$ echo $LANG zh_CN.UTF-8 修改用户下的.bash_profile 中的LANG，屏蔽操作系统的LANG设置。再查数据库 mysql> select * from employee; 结论： 用户的LANG设置，影响了应用程序的语言环境,导致myql的语言环境发生了改变： mysql> show variables like 'character%'; 在此环境下，检索中文会出现乱码。 在上述环境之下，向数据库中插入中文。 insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(5,'张三疯',1,'1987-05-21',15000,'2014-06-24','一个老牛'); 数据能插入到数据库中，没 有 报 任 何 错 误！但显示不正确。 因素3：文件存储格式 "},"shu-ju-ku/mongodb.html":{"url":"shu-ju-ku/mongodb.html","title":"MongoDB","keywords":"","body":"MongoDBMongoDB简介MongoDB的安装管理MongoDBmongodb和sql对应关系文档(记录行)集合(表)分布式数据库系统mongo常用数据类型登陆数据库use创建/切换数据库show显示所有数据库名db查看当前数据库的名称dropDatabase删除当前的数据库集合show查看所有的collection文档insert插入文档find查询文档remove删除文档update修改文档索引聚合副本集MongoDB关于C++的API简介MongoDB MongoDB简介 MongoDB的安装 管理MongoDB mongodb和sql对应关系 文档(记录行) 集合(表) 分布式数据库系统 mongo常用数据类型 登陆 数据库 use创建/切换数据库 show显示所有数据库名 db查看当前数据库的名称 dropDatabase删除当前的数据库 集合 show查看所有的collection 文档 insert插入文档 find查询文档 remove删除文档 update修改文档 索引 聚合 副本集 MongoDB关于C++的API简介 [TOC] MongoDB简介 MongoDB是一个开源的，基于分布式的，面向文档存储的非关系型数据库，是非关系型数据库当中比较像关系型数据库的。MongoDB由C++编写,起名字来源于”humongous”这个单词,宗旨在于处理大量数据。 MongoDB的特点: 面向集合存储，易存储对象类型的数据。 模式自由。集合中没有行和列的概念,每个文档可以有不同的key,key的值不要求一致的数据类型。 支持动态查询。支持丰富的查询的表达式,查询指令可以使用JSON形式表达式。 支持索引。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象（如视频等）。 自动处理碎片，以支持云计算层次的扩展性。 支持C/C++，PHP,RUBY，PYTHON，JAVA，等多种语言。 文件存储格式为BSON（一种JSON的扩展,JSON的二进制） MongoDB应用场景: 京东,中国著名电商,使用MongoDB存储商品信息,支持比价和关注功能. 赶集网,中国著名分类信息网站,使用MongoDB记录pv浏览计数 奇虎360,著名病毒软件防护和移动应用平台,使用MongoDB支撑的HULK平台每天接受200亿次的查询. 百度云,使用MongoDB管理百度云盘中500亿条关于文件源信息的记录. CERN，著名的粒子物理研究所，欧洲核子研究中心大型强子对撞机的数据使用MongoDB 纽约时报，领先的在线新闻门户网站之一，使用MongoDB sourceforge.net，资源网站查找，创建和发布开源软件免费，使用MongoDB的后端存储 MongoDB的安装 Ubuntu安装MongoDB sudo apt install -y mongodb 管理MongoDB 默认情况下，MongoDB被配置为自动启动服务器。 禁用开机自动启动： sudo systemctl disable mongodb 开机自动启动： sudo systemctl enable mongodb 服务的状态： sudo systemctl status mongodb 停止服务器： sudo systemctl stop mongodb 启动服务器： sudo systemctl start mongodb 重新启动服务器： sudo systemctl restart mongodb mongodb和sql对应关系 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 嵌入文档 表连接,MongoDB不支持,可通过内嵌和包含关联ID实现 primary key primary key 主键,MongoDB自动将_id字段设置为主键 文档(记录行) 文档是一个键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。 如： {\"site\":\"www.baidu.com\", \"name\":\"百度\"} 注意事项： 文档中的键/值对是有序的。 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。 MongoDB区分类型和大小写。 MongoDB的文档不能有重复的键。 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。 文档键不能含有\\0 (空字符)。这个字符用来表示键的结尾。 文档命名.和$有特别的意义，只有在特定环境下才能使用。 文档命名以下划线\"_\"开头的键是保留的(不是严格要求的)。 集合(表) 文档组，类似于关系数据库中的表格。 集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。 比如，我们可以将以下不同数据结构的文档插入到集合中： {\"site\":\"www.baidu.com\"} {\"site\":\"www.google.com\",\"name\":\"Google\"} {\"site\":\"www.itcast.cn\",\"name\":\"传智教程\",\"num\":5} 当第一个文档插入时，集合就会被创建。 分布式数据库系统 由分布于多个计算机结点上的若干个数据库系统组成,它提供有效的存取手段来操纵这些结点上的子数据库。分布式数据库在使用上可视为一个完整的数据库,而实际上它是分布在地理分散的各个结点上。当然,分布在各个结点上的子数据库在逻辑上是相关的。 mongo常用数据类型 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Arrays 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 登陆 使用用户名和密码连接到 MongoDB 服务器，你必须使用 'username:password@hostname/dbname' 格式，'username'为用户名，'password' 为密码。 使用用户名和密码连接登陆到默认test数据库： chao@deepin:~$ mongo MongoDB shell version: 3.2.11 connecting to: test 默认连接到test库,test可以不存在 使用用户 admin 使用密码 123456 连接到本地的 MongoDB 服务上。输出结果如下所示： > mongodb://admin:123456@localhost/ 使用用户名和密码连接登陆到指定数据库，格式如下： mongodb://admin:123456@localhost/test 数据库 use创建/切换数据库 use DATABASE_NAME show显示所有数据库名 show dbs db查看当前数据库的名称 db dropDatabase删除当前的数据库 db.dropDatabase() MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。 集合 show查看所有的collection show collections 文档 insert插入文档 MongoDB 使用 insert() 或 save() 方法向集合中插入文档： db.COLLECTION_NAME.insert(document) 例如： db.test.insert({ title: 'mongo test', description: 'MongoDB是Nosql数据库', url: 'http://mongodb.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 200 }) 区别： 1.save函数实际就是根据参数条件,调用了insert或update函数.如果想插入的数据对象存在, insert函数会报错, 而save函数是改变原来的对象;如果想插入的对象不存在,那么它们执行相同的插入操作. 这里可以用几个字来概括它们两的区别,即所谓\"有则改之,无则加之\". 2.insert可以一次性插入一个列表，而不用遍历，效率高， save则需要遍历列表，一个个插入. 3.如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。 find查询文档 查询格式如下： db.COLLECTION_NAME.find({COND},{FIELDS}) find() 方法以非结构化的方式来显示所有文档。 如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下： db.test.find().pretty() { \"_id\" : ObjectId(\"56ece7acf5fec0105618da63\"), \"title\" : \"22mongo test\", \"description\" : \"MongoDB是Nosql数据库\", \"url\" : \"http://www.baidu.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 200 } 一次返回１个结果: db.test.findone() MongoDB 与 RDBMS Where 语句比较 操作 格式 范例 RDBMS中的类似语句 等于 {:} db.test.find({\"title\":\"mongo\"}).pretty() where title = 'mongo' 小于 {:{$lt:}} db.test.find({\"likes\":{$lt:50}}).pretty() where likes 小于或等于 {:{$lte:}} db.test.find({\"likes\":{$lte:50}}).pretty() where likes 大于 {:{$gt:}} db.test.find({\"likes\":{$gt:50}}).pretty() where likes > 50 大于或等于 {:{$gte:}} db.test.find({\"likes\":{$gte:50}}).pretty() where likes >= 50 不等于 {:{$ne:}} db.test.find({\"likes\":{$ne:50}}).pretty() where likes != 50 remove删除文档 执行remove()函数前先执行find()命令来判断执行的条件是否正确 db.collection.remove( , { justOne: , writeConcern: } ) 参数说明： query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档.默认是true writeConcern :（可选）抛出异常的级别。 例如： db.test.remove({\"_id\" : ObjectId(\"56ece690f5fec0105618da62\")}) update修改文档 更新数据格式如下： db.collection.update( , , { upsert: , multi: , writeConcern: } ) 参数说明： query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$set...）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew, true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true, 就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 实例: 我们在集合test中插入如下数据： >db.col.insert({ title: 'MongoDB 教程', description: 'MongoDB 是一个 Nosql 数据库', url: 'http://www.baidu.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 }) 接着我们通过 update() 方法来更新标题(title): >db.col.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) # 输出信息 可以看到标题(title)由原来的 \"MongoDB 教程\" 更新为了 \"MongoDB\"。以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。 >db.col.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}},{multi:true}) *WriteConcern的几种抛出异常的级别参数： WriteConcern.NONE:没有异常抛出 WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常(默认) WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。(特殊情况可以使用该级别 ) WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。 WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。 WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。 WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。 索引 索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构 语法: db.COLLECTION_NAME.ensureIndex({KEY:1}) 语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。 聚合 MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等) ，并返回计算后的数据结果。有点类似sql语句中的 count(*)。 MongoDB中聚合的方法使用aggregate()。 语法: db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) 实例: { _id: ObjectId(7df78ad8902c) title: 'MongoDB Overview', description: 'MongoDB is no sql database', by_user: 'w3cschool.cc', url: 'http://www.w3cschool.cc', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 }, { _id: ObjectId(7df78ad8902d) title: 'NoSQL Overview', description: 'No sql database is very fast', by_user: 'w3cschool.cc', url: 'http://www.w3cschool.cc', tags: ['mongodb', 'database', 'NoSQL'], likes: 10 }, { _id: ObjectId(7df78ad8902e) title: 'Neo4j Overview', description: 'Neo4j is no sql database', by_user: 'Neo4j', url: 'http://www.neo4j.com', tags: ['neo4j', 'database', 'NoSQL'], likes: 750 }, 现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下： > db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : 1}}}]) { \"result\" : [ { \"_id\" : \"w3cschool.cc\", \"num_tutorial\" : 2 }, { \"_id\" : \"Neo4j\", \"num_tutorial\" : 1 } ], \"ok\" : 1 } 以上实例类似sql语句： select by_user, count(*) from mycol group by by_user 在上面的例子中，我们通过字段by_user字段对数据进行分组，并计算by_user字段相同值的总和。 副本集 MongoDB复制是将数据同步在多个服务器的过程。 复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。复制还允许您从硬件故障和服务中断中恢复数据。 为什么要进行复制? 保障数据的安全性 数据高可用性 (24*7) 灾难恢复 无需停机维护（如备份，重建索引，压缩） 分布式读取数据 如何实现复制? mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。 mongodb各个节点常见的搭配方式为：一主一从、一主多从。 主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。 MongoDB关于C++的API简介 主要API介绍,对应头文件为dbclientinterface.h 说明: IN表示输入参数; OUT表示输出参数; 1.构造函数 DBClientConnection(bool auto_connect, 0, double so_timeout); auto_connect(IN)：连接失败后自动重连 so_timeout(IN)：非连接超时，tcp的读写超时 2.连接函数 bool connect(string server, &string errmsg); 返回值：成功/失败 server(IN)：连接的服务器 errmsg(OUT)：出错信息 示例: bool auto_connect = true; double so_timeout = 3; string host = \"127.0.0.1\"; string port = \"27017\"; string errmsg = \"\"; DBClientConnection pConn = new DBClientConnection(auto_connect, 0, so_timeout); pConn->connect(host+\":\"+port, errmsg); 3.查询 auto_ptr query(const string &ns, Query query, int nToReturn, int nToSkip, const BSONObj *fieldsToReturn, int queryOptions , int batchSize); 返回值：结果集 ns(IN)：命名空间，db_name.collection_name query(IN)：查询的条件，相当于mysql中的where nToReturn：返回结果条数，相当于limit nToSkip：跳过的结果条数，相当于skip fieldsToReturn：返回列集合 queryOptions：详见QueryOptions这个枚举，填0即可 batchSize：未说明 示例： string db = \"shool\"; string collection = \"student\"; Query condition = QUERY(\"age\"query(db+\".\"+collection, condition, limit, offset, columns, 0, 0); 其效果相当于： select uid,name from shool.student where age=20 limit 5,10; 对结果集的操作： int uid=0; string name=\"\"; while(cursor->more()){ BSONObj p = cursor->next(); uid = p[\"uid\"].Int(); name = p[\"name\"].String(); count 4.插入 void insert(const string &ns, BSONObj obj, int flags); ns(IN)：命名空间，db_name.collection_name obj(IN)：插入的列 flags(IN)：详见API文档，默认填零即可 示例： BSONObj insert = BSON(\"uid\"insert(db+\".\"+collection, insert, 0); 其效果相当于： insert into shool.student (uid, name) values (10001, “skean1017″); 5.删除 void remove(const string &ns, Query query, bool justOne); ns(IN)：命名空间，db_name.collection_name query(IN)：查询条件 justOne(IN)：是否只删除匹配的第一条 示例： Query query = QUERY(\"name\"remove(db+\".\"+collection, query, true); 其效果相当于： delete from shool.student where name=”skean1017″; 6.修改 void update(const string &ns , Query query , BSONObj obj , bool upser , bool multi); ns(IN)：命名空间，db_name.collection_name query(IN)：查询条件 obj(IN)：修改后的值 upser(IN)：是否upser，如果不存在则插入记录 multi(IN)：是否为符合文档 示例： Query query = QUERY(\"uid\" 其效果相当于： update shool.student set name=”habadog1203” where uid=10001; mongodb的api的异常处理 mongodb为我们提供了DBException异常类,如果有错误会进行抛出,我们可以通过try catch的方式捕捉该类错误,然后通过打印 what()显示错误详细信息.具体所在头文件: assert_util.h.除了捕获mongo提供的异常信息,还需要捕获标准库的错误信息,最后有一个兜底的所有异常捕捉. 使用方法: catch( mongo::DBException& e ) { printf(\"MONGO Exception(set): %s\\n\", e.what()); return -1; } catch (std::exception& e) { printf(\"MONGO Exception(set): %s\\n\", e.what()); return -1; } catch (...){ printf(“MONGO Exception\\n”); return -1; } "}}